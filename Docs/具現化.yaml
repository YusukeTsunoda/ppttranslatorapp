# 翻訳履歴機能の実装計画
実装項目:
  - 履歴一覧表示の改善
  - 詳細表示機能の追加
  - フィルタリング機能の実装
  - ソート機能の実装

実装順序:
  1. データモデルの拡張
  2. APIエンドポイントの拡張
  3. 履歴一覧表示の改善
  4. 詳細表示機能の追加
  5. フィルタリング機能の実装
  6. ソート機能の実装

関連ファイル:
  - app/(dashboard)/history/page.tsx: 履歴一覧表示ページ
  - app/api/history/route.ts: 履歴データ取得API
  - app/(dashboard)/history/[id]/page.tsx: 詳細表示ページ（新規作成）
  - app/api/history/[id]/route.ts: 詳細データ取得API（新規作成）
  - lib/hooks/useHistoryFilter.ts: フィルタリングロジック（新規作成）
  - components/history/HistoryFilter.tsx: フィルタリングコンポーネント（新規作成）
  - components/history/HistorySort.tsx: ソートコンポーネント（新規作成）
  - components/history/HistoryDetail.tsx: 詳細表示コンポーネント（新規作成）
  - prisma/schema.prisma: データモデル定義

データモデル拡張:
  TranslationHistoryモデル拡張:
    既存フィールド:
      - id: String @id @default(cuid())
      - userId: String
      - fileName: String
      - pageCount: Int @default(0)
      - status: String
      - creditsUsed: Int
      - sourceLang: Language
      - targetLang: Language
      - model: String
      - createdAt: DateTime @default(now())
      - updatedAt: DateTime @updatedAt
    追加フィールド:
      - fileSize: Int @default(0) # ファイルサイズ（バイト）
      - processingTime: Int @default(0) # 処理時間（ミリ秒）
      - thumbnailPath: String? # サムネイル画像パス
      - tags: Json? # タグ情報（JSON配列）
      - metadata: Json? # 追加メタデータ

APIエンドポイント拡張:
  GET /api/history:
    機能追加:
      - クエリパラメータによるフィルタリング
      - ソートオプション
      - ページネーション
    クエリパラメータ:
      - page: ページ番号
      - limit: 1ページあたりの件数
      - sort: ソートフィールド
      - order: ソート順序（asc/desc）
      - search: 検索キーワード
      - startDate: 開始日
      - endDate: 終了日
      - status: ステータスフィルター
      - sourceLang: ソース言語フィルター
      - targetLang: ターゲット言語フィルター
    レスポンス:
      成功時 (200 OK):
        - data: TranslationHistory[] # 履歴データの配列
        - total: number # 全件数
        - page: number # 現在のページ
        - limit: number # 1ページあたりの件数
      失敗時 (4xx/5xx):
        - error: string # エラーメッセージ

  GET /api/history/[id]:
    機能:
      - 特定の履歴項目の詳細情報を取得
      - 関連するスライド情報も含める
    レスポンス:
      成功時 (200 OK):
        - data: TranslationHistory & { slides: SlideInfo[] } # 詳細データと関連スライド情報
      失敗時 (404 Not Found / 5xx):
        - error: string # エラーメッセージ

UI実装:
  履歴一覧表示の改善:
    コンポーネント:
      - HistoryTable: 履歴テーブルコンポーネント
        - 表示項目: サムネイル, ファイル名, ページ数, ファイルサイズ, クレジット, ステータス, 翻訳言語ペア, 処理日時, アクションボタン
      - HistoryCard: モバイル向けカードビュー
        - 表示項目: サムネイル, ファイル名, ステータス, 処理日時
      - Pagination: ページネーションコンポーネント
    機能:
      - レスポンシブデザイン（テーブル/カード切替）
      - サムネイル表示
      - ステータスバッジのデザイン改善
      - ページネーション
      - クイックアクション（詳細表示、再翻訳）
      - メタデータの詳細表示
      - 再翻訳ボタン
      - エクスポートオプション（CSVなど）

  詳細表示機能:
    実装方法:
      - 動的ルーティングを使用した専用ページ
      - モーダルでのプレビュー表示
    コンポーネント:
      - HistoryDetail: 詳細情報表示
      - SlidePreview: スライドプレビュー
      - MetadataPanel: メタデータ表示パネル
    機能:
      - 翻訳前後のテキスト比較表示
      - スライドプレビュー
      - メタデータの詳細表示
      - 再翻訳ボタン
      - エクスポートオプション

  フィルタリング機能:
    コンポーネント:
      - FilterPanel: フィルターパネル
      - DateRangePicker: 日付範囲選択
      - SearchInput: 検索入力
      - FilterChips: 適用中フィルターチップ
    機能:
      - 日付範囲フィルター
      - ファイル名検索
      - ステータスフィルター
      - 言語ペアフィルター
      - フィルター状態のURL保存
      - キーワード検索（ファイル名）
      - 日付範囲指定
      - フィルター状態のリセット機能

  ソート機能:
    コンポーネント:
      - SortDropdown: ソートオプションドロップダウン
      - SortDirectionToggle: 昇順/降順切替
    ソートオプション:
      - 日付（昇順/降順）
      - ファイル名（昇順/降順）
      - ファイルサイズ（昇順/降順）
      - ページ数（昇順/降順）
      - クレジット使用量（昇順/降順）
      - 処理時間（昇順/降順）

実装ステップ詳細:
  ステップ1: データモデルの拡張
    - Prismaスキーマに新しいフィールドを追加
    - マイグレーションを実行
    - 既存データの互換性を確保
    - バックアップを作成してからマイグレーション実行
    - 確認・検証:
      - マイグレーションが正常に完了すること
      - 既存データの型や値が維持されていること
      - 新フィールドにデフォルト値が設定されていること

  ステップ2: APIエンドポイントの拡張
    - GET /api/history の拡張
    - クエリパラメータの処理を追加
    - フィルタリングとソートロジックの実装
    - ページネーション対応
    - GET /api/history/[id] の新規作成
    - 確認・検証:
      - 各クエリパラメータ（フィルタ, ソート, ページネーション）が正しく機能すること
      - 不正なパラメータに対するエラーハンドリングが機能すること
      - 詳細APIが正しいデータを返すこと（関連スライド情報含む）
      - 認証と認可（ユーザー固有データのみ取得）が正しく機能すること

  ステップ3: 履歴一覧表示の改善
    - 既存の履歴ページのリファクタリング
    - テーブルレイアウトの最適化
    - レスポンシブデザインの実装
    - ページネーションの追加
    - 確認・検証:
      - APIから取得したデータが正しく表示されること
      - レスポンシブデザインが各画面サイズで適切に機能すること
      - ページネーションが正しく機能すること
      - クイックアクションボタンが動作すること

  ステップ4: 詳細表示機能の追加
    - 詳細表示ページの作成（またはモーダル実装）
    - 詳細コンポーネントの実装
    - スライドプレビューの実装
    - メタデータ表示の実装
    - 確認・検証:
      - 詳細APIから取得したデータ（テキスト比較、プレビュー、メタデータ）が正しく表示されること
      - 再翻訳、エクスポートボタンが機能すること
      - URLルーティングまたはモーダルの表示/非表示が正しく機能すること

  ステップ5: フィルタリング機能の実装
    - フィルターフックの作成 (useHistoryFilter)
    - フィルターコンポーネントの実装
    - URLクエリパラメータとの連携
    - フィルター状態の保持
    - 確認・検証:
      - 各フィルター（キーワード, 日付, ステータス, 言語）が正しく機能すること
      - フィルター適用時にAPIリクエストが正しく送信されること
      - フィルター状態がURLに反映され、リロードしても維持されること
      - フィルターリセット機能が動作すること

  ステップ6: ソート機能の実装
    - ソートロジックの実装 (API連携)
    - ソートコンポーネントの実装
    - URLクエリパラメータとの連携
    - 確認・検証:
      - 各ソートオプション（日付, ファイル名など）が正しく機能すること
      - 昇順/降順の切り替えが正しく機能すること
      - ソート状態がURLに反映され、リロードしても維持されること

テスト計画:
  ユニットテスト:
    - フィルタリングロジックのテスト
    - ソートロジックのテスト
    - APIレスポンス処理のテスト
  
  統合テスト:
    - APIエンドポイントのテスト
    - フィルターとソートの連携テスト
    - ページネーションのテスト
  
  E2Eテスト:
    - 履歴一覧表示のテスト
    - 詳細表示機能のテスト
    - フィルタリングとソートの操作テスト

パフォーマンス考慮事項:
  - 大量の履歴データがある場合のページネーション最適化
  - 画像サムネイルの遅延ロードと最適化
  - クエリパラメータによるサーバーサイドフィルタリング
  - クライアントサイドキャッシュの活用

セキュリティ考慮事項:
  - ユーザー固有の履歴データのアクセス制御
  - APIエンドポイントの認証確認
  - 入力値のバリデーション
  - SQLインジェクション対策

アクセシビリティ考慮事項:
  - キーボードナビゲーション対応
  - スクリーンリーダー対応
  - 色のコントラスト比の確保
  - フォーカス管理の最適化

---

# 次に取り組むべき主要タスク: 実装計画

このセクションでは、「次に取り組むべき主要タスク」として挙げられた4項目について、具体的な実装計画、関連ファイル、注意点などを記述します。

## 1. 翻訳履歴機能の実装

**目的:** ユーザーが過去に行った翻訳の結果を保存し、後で確認・再利用できるようにする。

**実装手順:**

1.  **DBスキーマ定義:**
    *   `prisma/schema.prisma` に `TranslationHistory` モデルを追加。
    *   **カラム案:** `id`, `userId` (Userリレーション), `originalFileName`, `translatedFileUrl` (or key), `sourceLanguage`, `targetLanguage`, `slideCount`, `translatedAt`, `status` (e.g., COMPLETED, FAILED), `errorMessage` (if failed) など。
    *   `User` モデルとのリレーション (`history TranslationHistory[]`) を追加。
    *   `@db.Text` など適切なデータ型を指定。`userId` と `translatedAt` にインデックスを設定検討。
2.  **DBマイグレーション:**
    *   `npm run prisma:migrate` (or `npx prisma migrate dev --name add_translation_history`) を実行。
3.  **履歴保存ロジック:**
    *   翻訳処理が成功した箇所 (例: `app/api/translate/route.ts` の最後) で、`prisma.translationHistory.create()` を呼び出し、履歴データを保存する。
    *   失敗した場合も、`status` を FAILED に設定し、エラーメッセージと共に履歴を保存することを検討。
4.  **履歴取得API:**
    *   `app/api/history/route.ts` (GET):
        *   `getSession()` でユーザーIDを取得。
        *   `prisma.translationHistory.findMany()` で該当ユーザーの履歴を取得 (新しい順にソート)。
        *   ページネーションを実装 (例: `take`, `skip`)。
        *   RLSポリシーと併用してアクセス制御を確実にする。
5.  **履歴詳細API (オプション):**
    *   `app/api/history/[id]/route.ts` (GET):
        *   パスパラメータから `id` を取得。
        *   `getSession()` でユーザーIDを取得。
        *   `prisma.translationHistory.findUnique()` で指定IDの履歴を取得。**必ず `userId` も条件に含める** ことでアクセス制御。
6.  **履歴一覧UI:**
    *   `app/(dashboard)/history/page.tsx` を作成。
    *   SWR (`useSWR`) またはサーバーアクションで `/api/history` からデータをフェッチ。
    *   `components/history/HistoryTable.tsx` などを作成し、取得したデータをテーブル表示。
    *   列: 元ファイル名, 翻訳言語, スライド数, 翻訳日時, ステータス, アクション(詳細/再ダウンロード)。
    *   ページネーションUIを実装。
7.  **再ダウンロード機能 (オプション):**
    *   履歴テーブルのアクションボタンから、翻訳済みファイルをダウンロードするAPI (`/api/download/[historyId]` など) を呼び出す。
    *   API側では、`historyId` からファイルURL/キーを取得し、アクセス制御を確認の上、ファイルダウンロードレスポンスを返す。
8.  **テスト:**
    *   APIエンドポイントのユニット/結合テスト (Jest)。
    *   履歴一覧ページのコンポーネントテスト (React Testing Library)。
    *   履歴作成から表示、ダウンロードまでの一連のE2Eテスト (Cypress)。

**関連ファイル:**

*   `prisma/schema.prisma`
*   `app/api/translate/route.ts`
*   `app/api/history/route.ts`
*   `app/api/history/[id]/route.ts` (Optional)
*   `app/api/download/[historyId]/route.ts` (Optional)
*   `app/(dashboard)/history/page.tsx`
*   `components/history/HistoryTable.tsx`
*   `lib/actions/history.ts` (Server Actionsの場合)
*   `lib/types/history.ts` (型定義)

**注意点/反省点:**

*   **アクセス制御:** Supabase RLSポリシーとAPIレベルでの `userId` チェックを徹底する。過去にRLS設定漏れで他ユーザー情報が見えた経験を活かす。
*   **パフォーマンス:** 履歴が増加した場合に備え、DBクエリのインデックス、APIのページネーションは初期から実装する。
*   **ファイル管理:** 翻訳済みファイルの実体 (S3など) と履歴DBの整合性を保つ。ファイル削除時の考慮。
*   **エラーハンドリング:** 翻訳失敗時の履歴ステータスとエラーメッセージ記録。
*   **スキーマ変更:** 将来的な機能追加（例: お気に入り、タグ付け）を見越して、拡張性のあるスキーマ設計を心がける。

## 2. パフォーマンス最適化

**目的:** 特に大きなPPTXファイルの処理速度向上と、アプリケーション全体のメモリ使用量削減。

**実装手順:**

1.  **ボトルネック特定:**
    *   **バックエンド (API):**
        *   大きなPPTXファイルを用意し、`app/api/pptx/parse` や `app/api/pptx/generate` の処理時間を計測 (Node.js `performance.now()` or `console.time`)。
        *   Node.jsのプロファイラ (例: `node --prof`, Chrome DevTools for Node) を使用し、CPU負荷の高い箇所を特定。
        *   メモリ使用量を監視 (例: `process.memoryUsage()`)。
    *   **フロントエンド:**
        *   Chrome DevTools (Performance, Network, Lighthouse) でレンダリング時間、バンドルサイズ、TTIなどを計測。
        *   `next/bundle-analyzer` でバンドル内容を確認。
2.  **バックエンド最適化:**
    *   **メモリ:**
        *   ファイルI/O: 可能であればストリーミングAPIを使用。一度にメモリに読み込むデータ量を減らす。
        *   ライブラリ: 使用しているPPTX処理ライブラリ (`pptx-ts`?) がメモリ効率的か確認。代替ライブラリ検討。
        *   データ構造: 巨大な中間オブジェクト生成を避ける。ジェネレーターの活用。
        *   ガベージコレクション: `gc.collect()` は最終手段。まずは不要な参照を速やかに切る。
    *   **速度:**
        *   非同期処理: 時間のかかるI/O (ファイル読み書き、外部API呼び出し) を `async/await` で適切に処理し、ブロッキングを防ぐ。`Promise.all` などで並列化できる箇所を探す。
        *   アルゴリズム: 処理ロジック自体に無駄がないか見直す。
3.  **フロントエンド最適化:**
    *   **レンダリング:**
        *   `React.lazy` / `next/dynamic` で初期表示に不要なコンポーネント（例: モーダル、重いチャート）を遅延ロード。
        *   ページの特性に応じてSSR/SSG/ISR/CSRを使い分ける。インタラクティブ性が低いマーケティングページはSSG/ISR、ダッシュボードはSSR/CSRを検討。
    *   **画像:**
        *   `next/image` を徹底活用。`priority` 属性を適切に設定。
    *   **バンドルサイズ:**
        *   不要な依存関係の削除。
        *   ライブラリのimport方法を見直し、Tree Shakingが効くようにする (例: `import { specificFunction } from 'library'` vs `import library from 'library'`)。
    *   **キャッシュ:**
        *   SWR/React Queryのキャッシュ機能を活用。`stale-while-revalidate` 戦略を理解する。
        *   頻繁に変わらないデータはAPIルートハンドラでキャッシュヘッダーを設定 (Vercel Edge Cache)。
4.  **計測と改善の反復:**
    *   修正を加えるたびに、一貫した方法でパフォーマンスを再計測し、効果を確認する。

**関連ファイル:**

*   `app/api/pptx/parse/route.ts`
*   `app/api/pptx/generate/route.ts`
*   `app/api/translate/route.ts`
*   `lib/pptx_utils.ts` (or similar)
*   各 `app/(...)/page.tsx`
*   `components/**/*.tsx`
*   `next.config.js`
*   `package.json` (dependencies)

**注意点/反省点:**

*   **計測の重要性:** 感覚ではなく、計測に基づいてボトルネックを特定する。過去に推測で最適化して効果がなかった反省を活かす。
*   **トレードオフ:** 速度とメモリ使用量、開発コストとパフォーマンスはトレードオフの関係にある場合が多い。どこまで最適化するか目標を設定する。
*   **複雑性:** 過度な最適化はコードを複雑にし、保守性を下げる可能性がある。
*   **環境差:** ローカル環境と本番環境 (Vercel) ではパフォーマンスが異なる。本番に近い環境でのテスト・計測を心がける。
*   **メモリリーク調査:** 長時間稼働させてメモリ使用量を監視するテストが必要。

## 3. 翻訳テキストの位置ずれ修正

**目的:** 翻訳後のテキストが元の図形やテキストボックスからずれる問題を修正する。

**実装手順:**

1.  **問題再現と分析:**
    *   位置ずれが発生するPPTXファイルと、そのファイル内の特定のスライド/図形、翻訳言語を特定。
    *   元のテキストボックスのプロパティを詳細に調査:
        *   位置 (`x`, `y`), サイズ (`width`, `height`)
        *   テキストフィット設定 (`autofit` type: None, Normal, Shape)
        *   内部マージン (`margin_left`, `margin_right`, etc.)
        *   フォント (`font.name`, `font.size`, `font.bold`, `font.italic`)
        *   段落設定 (`alignment`, `line_spacing`)
    *   翻訳後テキストの長さ、改行数、使用フォントなどを確認。
    *   使用ライブラリ (`pptx-ts`?) のドキュメントで関連するプロパティの扱いを確認。
2.  **修正アプローチ:**
    *   **Autofitの活用/調整:**
        *   元の `autofit` 設定を尊重しつつ、翻訳後テキストに合わせて再適用、あるいはプログラムでサイズを調整。`python-pptx` の `text_frame.fit_text()` に相当する機能を探す/実装する。
        *   翻訳後テキストが長すぎる場合、フォントサイズを段階的に縮小するロジックを追加。
    *   **サイズ/位置の再計算:**
        *   翻訳後テキストのレンダリング後のサイズを推定し（フォントメトリクスが必要な場合があり難しい）、テキストボックスのサイズを調整。
        *   特に縦書きや複雑な形状の場合、より高度な計算が必要になる可能性。
    *   **フォント考慮:**
        *   処理環境で利用可能なフォントと元ファイルのフォントを確認。必要ならフォント置換のロジックや、適切なフォールバックフォントを指定。
        *   ライブラリ限界への対応:**
        *   ライブラリが対応していないプロパティがあれば、基盤となるXML (Office Open XML) を直接操作することも検討 (ただし複雑度が高い)。
3.  **実装とテスト:**
    *   修正ロジックを `app/api/pptx/generate/route.ts` 等に実装。
    *   問題が再現したファイル、および多様なレイアウト（テキストボックス、図形、表、SmartArt）、言語、フォントを含むテスト用PPTXファイル群で繰り返し検証。目視確認が重要。

**関連ファイル:**

*   `app/api/pptx/generate/route.ts`
*   `app/api/pptx/parse/route.ts` (元のプロパティ読み取りのため)
*   `lib/pptx_utils.ts` (or similar)
*   PPTX処理ライブラリの型定義ファイル

**注意点/反省点:**

*   **複雑性:** PPTXの仕様は非常に複雑。すべてのケースを完璧にカバーするのは難しい。重要なユースケースから対応。
*   **ライブラリ依存:** ライブラリの機能やバグに大きく依存する。ライブラリのアップデートも注視。
*   **フォント問題:** 環境によるフォントの有無が結果に影響する。Docker環境などでフォントを統一するなどの対策が必要な場合も。過去にローカルとデプロイ環境でフォントが異なり、ずれが発生した経験。
*   **テストの難しさ:** 自動テストでのピクセルパーフェクトな検証は困難。目視確認を補完する形で、テキストがボックス内に収まっているか等の基本的な自動チェックは実装したい。
*   **言語特性:** アジア言語（日本語、中国語など）とラテン文字言語では文字幅や改行の扱いが異なる。言語ペアごとの調整が必要になる可能性。

## 4. テストカバレッジ向上

**目的:** APIエンドポイントとUIコンポーネントを中心に、自動テストのカバレッジを向上させ、コードの品質と信頼性を高める。

**実装手順:**

1.  **現状把握:**
    *   `npm run test -- --coverage` を実行し、カバレッジレポート（`coverage/lcov-report/index.html`）を確認。ファイルごと、行ごとのカバレッジが低い箇所を特定。
2.  **テスト戦略:**
    *   **API (Jest):** ユニットテスト/結合テスト。DBや外部APIはモック化 (`@jest/globals`, `jest.mock`, Prisma Mock, MSW)。リクエスト/レスポンス、ビジネスロジック、エラーハンドリングを重点的にテスト。
    *   **UIコンポーネント (Jest + RTL):** ユニットテスト。propsの変更、ユーザーインタラクション（クリック、入力）、状態変化に応じた表示の検証。アクセシビリティを意識したセレクタを使用。
    *   **E2E (Cypress):** 主要なユーザーフローのテスト。APIはモックする場合と、実際のAPIを叩く場合を使い分ける。
3.  **APIテスト拡充:**
    *   カバレッジの低いAPIルート (`app/api/.../route.ts`) から着手。
    *   正常系、異常系（バリデーションエラー、認証/認可エラー、リソースNotFound、サーバーエラー）、境界値テストを追加。
    *   `try...catch` ブロック内のエラーハンドリングパスもテストする。
4.  **UIコンポーネントテスト拡充:**
    *   カバレッジの低いコンポーネント (`components/**/*.tsx`) から着手。
    *   特に条件分岐 (`if`, 三項演算子) やループ (`map`) でレンダリング内容が変わる部分を網羅するようにテストケースを追加。
    *   カスタムフック (`hooks/*.ts`) のテストも検討。
5.  **テストの質向上:**
    *   壊れにくいテスト: 実装の詳細に依存しない（例: CSSクラス名ではなく `data-testid` や `role` を使う）。
    *   読みやすいテスト: `describe`, `it`, `expect` を適切に使い、テストの意図が明確になるように記述。 AAA (Arrange-Act-Assert) パターンを意識。
    *   DRY原則: 共通のセットアップ処理などは `beforeEach`, `afterEach` やヘルパー関数にまとめる。
6.  **CI連携:**
    *   `.github/workflows/ci-cd.yml` でテストが自動実行され、カバレッジレポートが生成・アップロードされるように設定。Pull Request時にカバレッジチェックを行うことも検討。
7.  **反復:** テストを追加 → カバレッジ計測 → レポート確認 → さらにテスト追加、を繰り返す。

**関連ファイル:**

*   `**/*.test.ts`, `**/*.test.tsx` (Jest tests)
*   `cypress/e2e/**/*.cy.ts` (Cypress tests)
*   `jest.config.js`, `jest.setup.js`
*   `cypress.config.ts`, `cypress/support/e2e.ts`
*   `lib/mocks/*`, `prisma/seed.ts` (Test data setup)
*   `.github/workflows/ci-cd.yml`

**注意点/反省点:**

*   **設定の複雑さ:** Jest, Cypress, TS, Next.js, Prisma, Supabase Auth など多くのツールが絡むため、設定ファイル (tsconfig, jest.config, etc.) の整合性を保つ。過去に ESM/CJS 混在や `paths` 設定で苦労した経験を活かす。
*   **モック戦略:** 適切な粒度でのモックが重要。モックしすぎるとテストが現実から乖離し、モックしないとテストが遅く不安定になる。MSWのようなツールはAPIレベルでのモックに有効。
*   **E2Eの不安定さ:** 非同期処理の待機 (`cy.intercept`, `should('exist')` など)、テスト間の状態分離 (`beforeEach` でのクリーンアップ) を徹底する。`cy.wait(number)` は避ける。
*   **カバレッジの罠:** 100%を目指すことが目的ではない。テストの質と、重要なロジックがカバーされているかが重要。テストされていない行がなぜ残っているのか分析する。
*   **テストデータ管理:** 再現性があり、保守しやすいテストデータの作成・管理方法を確立する (ファクトリ、シーディング)。

---

進捗:
  - バッチアップロードAPI/進捗API: API本実装・E2E検証中
  - APIキー外部連携: API設計中・近日実装予定
  - 請求書メール送信: API設計中・近日実装予定
  - 統計エクスポート: API設計中・近日実装予定
  - RLS/監査ログ: API設計中・近日実装予定