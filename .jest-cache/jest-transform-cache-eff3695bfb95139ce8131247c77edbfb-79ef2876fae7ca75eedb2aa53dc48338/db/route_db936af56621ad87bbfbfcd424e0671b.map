{"version":3,"sources":["/Users/yusuketsunoda/Documents/cursor/ppttranslatorapp/worktrees/cicd-setup/app/api/history/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth/auth-options';\nimport { prisma } from '@/lib/db/prisma';\nimport { Language, Prisma } from '@prisma/client';\nimport { TranslationStatus } from '@prisma/client';\n\nexport const dynamic = 'force-dynamic';\n\n// ソート可能なフィールドのリスト\nconst allowedSortFields: (keyof Prisma.TranslationHistoryOrderByWithRelationInput | 'originalFileName')[] = [\n  'createdAt', 'updatedAt', 'pageCount', 'status', 'creditsUsed', 'sourceLang', 'targetLang', 'model', 'fileSize', 'processingTime', 'originalFileName'\n];\n\nexport async function GET(req: Request) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session || !session.user) {\n      return NextResponse.json({ error: '認証が必要です' }, { status: 401 });\n    }\n\n    const userId = session.user.id;\n\n    const url = new URL(req.url);\n    const searchParams = url.searchParams;\n\n    const pageParam = searchParams.get('page');\n    const limitParam = searchParams.get('limit');\n    const sortParam = searchParams.get('sort') || 'createdAt';\n    const orderParam = searchParams.get('order') || 'desc';\n    const search = searchParams.get('search') || '';\n    const startDate = searchParams.get('startDate');\n    const endDate = searchParams.get('endDate');\n    const statusParam = searchParams.get('status');\n    const sourceLangParam = searchParams.get('sourceLang');\n    const targetLangParam = searchParams.get('targetLang');\n\n    const page = pageParam ? parseInt(pageParam) : 1;\n    const limit = limitParam ? parseInt(limitParam) : 10;\n\n    if (isNaN(page) || page < 1) {\n      return NextResponse.json({ error: '無効なページ番号です' }, { status: 400 });\n    }\n    if (isNaN(limit) || limit < 1 || limit > 100) {\n      return NextResponse.json({ error: '無効な制限数です' }, { status: 400 });\n    }\n\n    if (orderParam !== 'asc' && orderParam !== 'desc') {\n      return NextResponse.json({ error: '無効なソート順序です' }, { status: 400 });\n    }\n\n    // Allow sorting by originalFileName via relation\n    const effectiveSortParam = sortParam === 'originalFileName' ? 'file' : sortParam;\n    if (!allowedSortFields.includes(sortParam as any)) {\n        return NextResponse.json({ error: `無効なソートキーです: ${sortParam}` }, { status: 400 });\n    }\n\n    const sourceLang = sourceLangParam && Object.values(Language).includes(sourceLangParam as Language)\n                       ? sourceLangParam as Language\n                       : null;\n    const targetLang = targetLangParam && Object.values(Language).includes(targetLangParam as Language)\n                       ? targetLangParam as Language\n                       : null;\n    // Validate status param against Enum\n    const status = statusParam && Object.values(TranslationStatus).includes(statusParam as TranslationStatus)\n                   ? statusParam as TranslationStatus\n                   : null;\n\n    const skip = (page - 1) * limit;\n\n    const whereCondition: Prisma.TranslationHistoryWhereInput = {\n      userId: userId,\n    };\n\n    if (search) {\n      // Search by originalName in the related File model\n      whereCondition.file = {\n        originalName: {\n          contains: search,\n          mode: 'insensitive',\n        }\n      };\n    }\n\n    const dateFilter: Prisma.DateTimeFilter = {};\n    if (startDate) {\n      try {\n        dateFilter.gte = new Date(startDate);\n      } catch { /* ignore invalid date */ }\n    }\n    if (endDate) {\n      try {\n        dateFilter.lte = new Date(endDate);\n      } catch { /* ignore invalid date */ }\n    }\n    if (dateFilter.gte || dateFilter.lte) {\n      whereCondition.createdAt = dateFilter;\n    }\n\n    if (status) {\n      whereCondition.status = status; // Use validated enum value\n    }\n\n    if (sourceLang) {\n      whereCondition.sourceLang = sourceLang;\n    }\n\n    if (targetLang) {\n      whereCondition.targetLang = targetLang;\n    }\n\n    // Handle sorting by related field\n    let orderByCondition: Prisma.TranslationHistoryOrderByWithRelationInput | Prisma.TranslationHistoryOrderByWithRelationInput[];\n    if (sortParam === 'originalFileName') {\n        orderByCondition = {\n            file: {\n                originalName: orderParam,\n            },\n        };\n    } else {\n        orderByCondition = {\n            [sortParam]: orderParam,\n        } as Prisma.TranslationHistoryOrderByWithRelationInput;\n    }\n\n    const [totalCount, history] = await prisma.$transaction([\n      prisma.translationHistory.count({ where: whereCondition }),\n      prisma.translationHistory.findMany({\n        where: whereCondition,\n        orderBy: orderByCondition,\n        skip,\n        take: limit,\n        include: {\n          file: {\n            select: {\n              originalName: true,\n            },\n          },\n        },\n      }),\n    ]);\n\n    // Add originalFileNameと新フィールドをhistory objectsに追加\n    const historyWithFileName = history.map(item => ({\n        ...item,\n        originalFileName: item.file.originalName,\n        tags: item.tags,\n        metadata: item.metadata,\n        thumbnailPath: item.thumbnailPath,\n        processingTime: item.processingTime,\n        fileSize: item.fileSize,\n      }));\n\n    return NextResponse.json({\n      data: historyWithFileName,\n      total: totalCount,\n      page,\n      limit,\n    });\n\n  } catch (error) {\n    console.error('履歴取得APIエラー:', error);\n    let errorMessage = '履歴の取得中にエラーが発生しました';\n    if (error instanceof Error) {\n      errorMessage = `詳細: ${error.message}`;\n    }\n    return NextResponse.json({ error: errorMessage }, { status: 500 });\n  }\n}\n"],"names":["GET","dynamic","allowedSortFields","req","session","getServerSession","authOptions","user","NextResponse","json","error","status","userId","id","url","URL","searchParams","pageParam","get","limitParam","sortParam","orderParam","search","startDate","endDate","statusParam","sourceLangParam","targetLangParam","page","parseInt","limit","isNaN","effectiveSortParam","includes","sourceLang","Object","values","Language","targetLang","TranslationStatus","skip","whereCondition","file","originalName","contains","mode","dateFilter","gte","Date","lte","createdAt","orderByCondition","totalCount","history","prisma","$transaction","translationHistory","count","where","findMany","orderBy","take","include","select","historyWithFileName","map","item","originalFileName","tags","metadata","thumbnailPath","processingTime","fileSize","data","total","console","errorMessage","Error","message"],"mappings":"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"}