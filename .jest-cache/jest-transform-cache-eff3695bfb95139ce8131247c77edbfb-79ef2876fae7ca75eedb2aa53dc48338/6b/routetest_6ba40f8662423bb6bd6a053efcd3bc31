ab0d60512a48be72a39b1c707a0dd9e2
"use strict";
// getTokenのモック
jest.mock('next-auth/jwt', ()=>({
        getToken: jest.fn()
    }));
// upload-helpersのモック
jest.mock('@/lib/utils/upload-helpers', ()=>({
        uploadFilesToUserDir: jest.fn(),
        processFiles: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _interop_require_default = require("@swc/helpers/_/_interop_require_default");
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _route = require("@/app/api/upload/route");
const _server = require("next/server");
const _jwt = require("next-auth/jwt");
const _mockSetup = require("@/tests/helpers/mockSetup");
const _uploadhelpers = /*#__PURE__*/ _interop_require_wildcard._(require("@/lib/utils/upload-helpers"));
const _uuid = require("uuid");
const _path = /*#__PURE__*/ _interop_require_default._(require("path"));
// console.logのモック
const mockConsoleLog = jest.spyOn(console, 'log').mockImplementation();
const mockConsoleError = jest.spyOn(console, 'error').mockImplementation();
const prismaMock = (0, _mockSetup.createPrismaMock)();
const getTokenMock = _jwt.getToken;
describe('POST /api/upload', ()=>{
    beforeEach(()=>{
        (0, _mockSetup.clearAllMocks)();
    });
    afterEach(()=>{
        mockConsoleLog.mockClear();
        mockConsoleError.mockClear();
    });
    it('should upload file successfully', async ()=>{
        const mockUser = (0, _mockSetup.createMockUser)({
            id: 'test-user-id'
        });
        getTokenMock.mockResolvedValue({
            sub: mockUser.id
        });
        const mockFile = {
            filepath: _path.default.join('public', 'uploads', mockUser.id, 'test.pptx'),
            originalFilename: 'test.pptx',
            newFilename: '1234567890_test.pptx',
            size: 1024,
            mimetype: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
            hash: (0, _uuid.v4)()
        };
        _uploadhelpers.uploadFilesToUserDir.mockResolvedValue([
            {},
            {
                file: mockFile
            }
        ]);
        _uploadhelpers.processFiles.mockReturnValue([
            mockFile
        ]);
        const createdFile = {
            id: mockFile.hash,
            userId: mockUser.id,
            originalName: mockFile.originalFilename,
            storagePath: mockFile.filepath,
            fileSize: mockFile.size,
            mimeType: mockFile.mimetype,
            createdAt: new Date()
        };
        prismaMock.file.create.mockResolvedValue(createdFile);
        prismaMock.activityLog.create.mockResolvedValue({
            id: 'test-activity-id',
            userId: mockUser.id,
            type: 'FILE_UPLOAD',
            description: '1個のファイルをアップロードしました'
        });
        const formData = new FormData();
        formData.append('file', new Blob([
            'test file content'
        ]), 'test.pptx');
        const req = new _server.NextRequest('http://localhost/api/upload', {
            method: 'POST',
            body: formData
        });
        const response = await (0, _route.POST)(req);
        const responseBody = await response.json();
        expect(response.status).toBe(200);
        expect(responseBody.success).toBe(true);
        expect(responseBody.files).toHaveLength(1);
        expect(responseBody.files[0]).toEqual({
            id: createdFile.id,
            originalName: createdFile.originalName,
            size: createdFile.fileSize,
            mimeType: createdFile.mimeType,
            createdAt: createdFile.createdAt.toISOString()
        });
        expect(prismaMock.file.create).toHaveBeenCalledWith({
            data: {
                id: mockFile.hash,
                userId: mockUser.id,
                originalName: mockFile.originalFilename,
                storagePath: mockFile.filepath,
                fileSize: mockFile.size,
                mimeType: mockFile.mimetype
            }
        });
        expect(prismaMock.activityLog.create).toHaveBeenCalledWith({
            data: {
                userId: mockUser.id,
                type: 'FILE_UPLOAD',
                description: '1個のファイルをアップロードしました',
                metadata: {
                    fileCount: 1,
                    fileIds: [
                        createdFile.id
                    ]
                }
            }
        });
    });
    it('should return 401 if not authenticated', async ()=>{
        getTokenMock.mockResolvedValue(null);
        const formData = new FormData();
        formData.append('file', new Blob([
            'test file content'
        ]), 'test.pptx');
        const req = new _server.NextRequest('http://localhost/api/upload', {
            method: 'POST',
            body: formData
        });
        const response = await (0, _route.POST)(req);
        const responseBody = await response.json();
        expect(response.status).toBe(401);
        expect(responseBody.error).toBe('認証が必要です');
    });
    it('should return 400 if no files uploaded', async ()=>{
        const mockUser = (0, _mockSetup.createMockUser)({
            id: 'test-user-id'
        });
        getTokenMock.mockResolvedValue({
            sub: mockUser.id
        });
        _uploadhelpers.uploadFilesToUserDir.mockResolvedValue([
            {},
            {}
        ]);
        _uploadhelpers.processFiles.mockReturnValue([]);
        const formData = new FormData();
        const req = new _server.NextRequest('http://localhost/api/upload', {
            method: 'POST',
            body: formData
        });
        const response = await (0, _route.POST)(req);
        const responseBody = await response.json();
        expect(response.status).toBe(400);
        expect(responseBody.error).toBe('ファイルがアップロードされていません');
    });
    it('should handle upload errors', async ()=>{
        const mockUser = (0, _mockSetup.createMockUser)({
            id: 'test-user-id'
        });
        getTokenMock.mockResolvedValue({
            sub: mockUser.id
        });
        _uploadhelpers.uploadFilesToUserDir.mockRejectedValue(new Error('Upload failed'));
        const formData = new FormData();
        formData.append('file', new Blob([
            'test file content'
        ]), 'test.pptx');
        const req = new _server.NextRequest('http://localhost/api/upload', {
            method: 'POST',
            body: formData
        });
        const response = await (0, _route.POST)(req);
        const responseBody = await response.json();
        expect(response.status).toBe(500);
        expect(responseBody.error).toBe('ファイルアップロード中にエラーが発生しました');
        expect(mockConsoleError).toHaveBeenCalled();
    });
    it('should handle database errors', async ()=>{
        const mockUser = (0, _mockSetup.createMockUser)({
            id: 'test-user-id'
        });
        getTokenMock.mockResolvedValue({
            sub: mockUser.id
        });
        const mockFile = {
            filepath: _path.default.join('public', 'uploads', mockUser.id, 'test.pptx'),
            originalFilename: 'test.pptx',
            newFilename: '1234567890_test.pptx',
            size: 1024,
            mimetype: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
            hash: (0, _uuid.v4)()
        };
        _uploadhelpers.uploadFilesToUserDir.mockResolvedValue([
            {},
            {
                file: mockFile
            }
        ]);
        _uploadhelpers.processFiles.mockReturnValue([
            mockFile
        ]);
        prismaMock.file.create.mockRejectedValue(new Error('Database error'));
        const formData = new FormData();
        formData.append('file', new Blob([
            'test file content'
        ]), 'test.pptx');
        const req = new _server.NextRequest('http://localhost/api/upload', {
            method: 'POST',
            body: formData
        });
        const response = await (0, _route.POST)(req);
        const responseBody = await response.json();
        expect(response.status).toBe(500);
        expect(responseBody.error).toBe('ファイルアップロード中にエラーが発生しました');
        expect(mockConsoleError).toHaveBeenCalled();
    });
});
