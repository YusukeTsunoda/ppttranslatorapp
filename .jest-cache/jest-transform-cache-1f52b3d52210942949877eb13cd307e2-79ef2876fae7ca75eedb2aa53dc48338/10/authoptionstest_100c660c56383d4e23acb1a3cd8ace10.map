{"version":3,"sources":["/Users/yusuketsunoda/Documents/cursor/ppttranslatorapp/worktrees/feature-test-coverage-improvement/tests/lib/auth/auth-options.test.ts"],"sourcesContent":["import { authOptions } from '@/lib/auth/auth-options';\nimport { prisma } from '@/lib/db/prisma';\nimport { comparePasswords } from '@/lib/auth/password';\nimport { DeepMockProxy, mockDeep } from 'jest-mock-extended';\nimport { User } from '@prisma/client';\nimport { JWT } from 'next-auth/jwt';\nimport { Session } from 'next-auth';\n\n// Prisma Clientのモック\njest.mock('@/lib/db/prisma', () => ({\n  prisma: mockDeep<DeepMockProxy<typeof prisma>>(),\n}));\n\n// comparePasswordsのモック\njest.mock('@/lib/auth/password', () => ({\n  ...jest.requireActual('@/lib/auth/password'), // hashPassword など他の関数はそのまま使う可能性を考慮\n  comparePasswords: jest.fn(),\n}));\n\nconst prismaMock = prisma as unknown as DeepMockProxy<typeof prisma>;\nconst comparePasswordsMock = comparePasswords as jest.Mock;\n\ndescribe('authOptions - CredentialsProvider - authorize', () => {\n  let authorize: ((credentials: Record<string, string> | undefined) => Promise<any>) | undefined;\n\n  beforeAll(() => {\n    // authOptionsからauthorize関数を取得\n    const credentialsProvider = authOptions.providers.find(\n      (provider) => provider.name === 'credentials'\n    );\n    if (credentialsProvider && 'authorize' in credentialsProvider) {\n      authorize = credentialsProvider.authorize;\n    }\n  });\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    comparePasswordsMock.mockResolvedValue(true); // デフォルトでパスワード一致\n  });\n\n  it('should throw error if authorize function is not found (config issue)', () => {\n    if (!authorize) { // このテストケースはauthorizeが見つからない場合に実行される\n      expect(true).toBe(true); // authorize が undefined ならテストは実質的にパス\n      console.warn('Authorize function not found in authOptions.Providers.Credentials. Test skipped.');\n      return;\n    }\n    // authorizeが見つかれば、このテストは意味がないので、別の形で表明する\n    expect(authorize).toBeDefined();\n  });\n\n  it('should throw error if email or password is not provided', async () => {\n    if (!authorize) return; // authorize がなければテストスキップ\n    await expect(authorize({ email: 'test@example.com' })).rejects.toThrow(\n      'メールアドレスとパスワードは必須です'\n    );\n    await expect(authorize({ password: 'password123' })).rejects.toThrow(\n      'メールアドレスとパスワードは必須です'\n    );\n    await expect(authorize({})).rejects.toThrow('メールアドレスとパスワードは必須です');\n  });\n\n  it('should throw error if user is not found', async () => {\n    if (!authorize) return;\n    prismaMock.user.findUnique.mockResolvedValue(null);\n    await expect(\n      authorize({ email: 'nonexistent@example.com', password: 'password123' })\n    ).rejects.toThrow('メールアドレスまたはパスワードが正しくありません');\n  });\n\n  it('should throw error if user has no password set (e.g. OAuth user)', async () => {\n    if (!authorize) return;\n    const mockUserWithoutPassword = {\n      id: 'user1', email: 'test@example.com', name: 'Test User', password: null \n    } as unknown as User; // passwordがnullのケース\n    prismaMock.user.findUnique.mockResolvedValue(mockUserWithoutPassword);\n    await expect(\n      authorize({ email: 'test@example.com', password: 'password123' })\n    ).rejects.toThrow('メールアドレスまたはパスワードが正しくありません');\n  });\n\n  it('should throw error if password comparison fails', async () => {\n    if (!authorize) return;\n    const mockUser = {\n      id: 'user1', email: 'test@example.com', name: 'Test User', password: 'hashedPassword'\n    } as User;\n    prismaMock.user.findUnique.mockResolvedValue(mockUser);\n    comparePasswordsMock.mockResolvedValue(false); // パスワード不一致\n\n    await expect(\n      authorize({ email: 'test@example.com', password: 'wrongpassword' })\n    ).rejects.toThrow('メールアドレスまたはパスワードが正しくありません');\n  });\n\n  it('should return user object and update user on successful authorization', async () => {\n    if (!authorize) return;\n    const mockUser = {\n      id: 'user1',\n      email: 'test@example.com',\n      name: 'Test User',\n      password: 'hashedPassword',\n      // ... other fields that might be needed for prisma.user.update\n      updatedAt: new Date(),\n    } as User;\n    prismaMock.user.findUnique.mockResolvedValue(mockUser);\n    comparePasswordsMock.mockResolvedValue(true);\n    prismaMock.user.update.mockResolvedValue(mockUser); // モックされた更新後のユーザー\n\n    const result = await authorize({ email: 'test@example.com', password: 'password123' });\n\n    expect(result).toEqual({\n      id: mockUser.id,\n      email: mockUser.email,\n      name: mockUser.name,\n    });\n    expect(prismaMock.user.findUnique).toHaveBeenCalledWith({ where: { email: 'test@example.com' } });\n    expect(comparePasswordsMock).toHaveBeenCalledWith('password123', 'hashedPassword');\n    expect(prismaMock.user.update).toHaveBeenCalledWith({\n      where: { id: mockUser.id },\n      data: { updatedAt: expect.any(Date) },\n    });\n  });\n});\n\ndescribe('authOptions - callbacks.jwt', () => {\n  let jwtCallback: ((args: { token: JWT; user?: any; account?: any; profile?: any; isNewUser?: boolean; trigger?: string; session?: any; }) => Promise<JWT>) | undefined;\n  const mockInitialToken: JWT = {\n    name: 'Initial Name',\n    email: 'initial@example.com',\n    picture: 'initial_pic',\n    sub: 'initial_sub',\n    iat: Math.floor(Date.now() / 1000) - 3600, // 1時間前\n    exp: Math.floor(Date.now() / 1000) + 3600, // 1時間後\n  };\n\n  beforeAll(() => {\n    if (authOptions.callbacks && typeof authOptions.callbacks.jwt === 'function') {\n      jwtCallback = authOptions.callbacks.jwt;\n    }\n  });\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    // refreshToken内のprisma.user.findUniqueのデフォルトモック\n    prismaMock.user.findUnique.mockResolvedValue(null); \n    // refreshToken内のprisma.user.updateのデフォルトモック\n    prismaMock.user.update.mockResolvedValue({} as any); \n  });\n\n  it('should add user info to token on initial sign in', async () => {\n    if (!jwtCallback) return;\n    const mockUser = {\n      id: 'user123',\n      email: 'newuser@example.com',\n      name: 'New User',\n    };\n    const tokenArg = { ...mockInitialToken }; // 初期トークン (内容はjwtコールバック内で上書きされる)\n\n    const result = await jwtCallback({ token: tokenArg, user: mockUser });\n\n    expect(result.id).toBe(mockUser.id);\n    expect(result.email).toBe(mockUser.email);\n    expect(result.name).toBe(mockUser.name);\n    expect(result.iat).toBeCloseTo(Math.floor(Date.now() / 1000), -1);\n    expect(result.exp).toBeCloseTo(Math.floor(Date.now() / 1000) + 24 * 60 * 60, -1);\n    // uaのテストはwindowがないためここでは省略 (E2Eで確認)\n  });\n\n  it('should update token name if trigger is update and session has userName', async () => {\n    if (!jwtCallback) return;\n    const updatedName = 'Updated Name';\n    const tokenArg = { ...mockInitialToken, email: 'test@example.com' }; // emailが必要なため設定\n    const sessionArg = { user: { name: updatedName } };\n\n    // refreshTokenがDBアクセスしないようにモック (expを十分に未来にする)\n    tokenArg.exp = Math.floor(Date.now() / 1000) + 2 * 24 * 60 * 60; // 2日後\n    \n    const result = await jwtCallback({ token: tokenArg, trigger: 'update', session: sessionArg });\n\n    expect(result.name).toBe(updatedName);\n  });\n\n  it('should call refreshToken and return its result (expiring soon case)', async () => {\n    if (!jwtCallback) return;\n    const expiringToken = {\n      ...mockInitialToken,\n      email: 'refresh@example.com', // refreshToken内のDB検索で使う\n      exp: Math.floor(Date.now() / 1000) + 60, // 1分後に期限切れ\n    };\n    const refreshedDbUser = {\n      id: 'refreshed-id', email: 'refresh@example.com', name: 'Refreshed User'\n    } as User;\n\n    prismaMock.user.findUnique.mockResolvedValue(refreshedDbUser);\n    // prisma.user.updateはデフォルトモックでOK\n\n    const result = await jwtCallback({ token: expiringToken });\n\n    expect(prismaMock.user.findUnique).toHaveBeenCalledWith({ where: { email: expiringToken.email } });\n    expect(prismaMock.user.update).toHaveBeenCalledWith({\n      where: { id: refreshedDbUser.id },\n      data: { updatedAt: expect.any(Date) },\n    });\n    expect(result.exp).toBeGreaterThan(expiringToken.exp as number);\n    expect(result.exp).toBeCloseTo(Math.floor(Date.now() / 1000) + 24 * 60 * 60, -1);\n  });\n\n   it('should call refreshToken and return its result (no exp case)', async () => {\n    if (!jwtCallback) return;\n    const tokenWithoutExp = {\n      ...mockInitialToken,\n      email: 'noexp@example.com',\n    };\n    delete tokenWithoutExp.exp; // expを削除\n    const dbUser = {\n      id: 'noexp-id', email: 'noexp@example.com', name: 'No Exp User'\n    } as User;\n\n    // refreshTokenはexpがない場合、DBアクセスはしない (現在の実装では)\n    // しかし、emailがtokenにあれば、userを探しに行くロジックになっている。\n    // そのため、findUniqueは呼ばれる。\n    prismaMock.user.findUnique.mockResolvedValue(dbUser);\n\n    const result = await jwtCallback({ token: tokenWithoutExp });\n    \n    expect(result.exp).toBeDefined();\n    expect(result.exp).toBeCloseTo(Math.floor(Date.now() / 1000) + 24 * 60 * 60, -1);\n    // expがない場合、refreshToken内でDBアクセスが走るかどうかはrefreshTokenの実装による\n    // 現状の実装(auth-options.ts)では、token.emailがあればfindUniqueが呼ばれる\n    expect(prismaMock.user.findUnique).toHaveBeenCalledWith({ where: { email: tokenWithoutExp.email } });\n    // userが見つかればupdateも呼ばれる\n    expect(prismaMock.user.update).toHaveBeenCalledWith({\n        where: {id: dbUser.id},\n        data: {updatedAt: expect.any(Date)}\n    });\n  });\n\n  it('should not refresh token if expiry is not soon and exp exists', async () => {\n    if (!jwtCallback) return;\n    const validToken = {\n      ...mockInitialToken,\n      email: 'valid@example.com',\n      exp: Math.floor(Date.now() / 1000) + 10 * 60, // 10分後 (リフレッシュマージンより大きい)\n    };\n\n    const result = await jwtCallback({ token: validToken });\n\n    expect(prismaMock.user.findUnique).not.toHaveBeenCalled();\n    expect(prismaMock.user.update).not.toHaveBeenCalled();\n    expect(result.exp).toBe(validToken.exp);\n  });\n});\n\ndescribe('authOptions - callbacks.session', () => {\n  let sessionCallback: ((args: { session: Session; token: JWT; user: any; }) => Promise<Session>) | undefined;\n\n  beforeAll(() => {\n    if (authOptions.callbacks && typeof authOptions.callbacks.session === 'function') {\n      sessionCallback = authOptions.callbacks.session;\n    }\n  });\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should transfer id, email, name from token to session.user', async () => {\n    if (!sessionCallback) return;\n    const mockToken: JWT = {\n      id: 'token-user-id',\n      email: 'token@example.com',\n      name: 'Token User Name',\n      sub: 'tokensub',\n      iat: Date.now() / 1000,\n      exp: Date.now() / 1000 + 3600, // 1時間後\n      ua: 'test-user-agent', // uaもテストケースに含める\n    };\n    const mockInitialSession: Session = {\n      user: {\n        // 初期セッションのuserは一部未定義かもしれない\n      },\n      expires: 'some-initial-expiry',\n    };\n\n    const result = await sessionCallback({ session: mockInitialSession, token: mockToken, user: {} /* userは使われない */ });\n\n    expect(result.user.id).toBe(mockToken.id);\n    expect(result.user.email).toBe(mockToken.email);\n    expect(result.user.name).toBe(mockToken.name);\n  });\n\n  it('should add expires to session from token.exp', async () => {\n    if (!sessionCallback) return;\n    const tokenExp = Math.floor(Date.now() / 1000) + 2 * 60 * 60; // 2時間後\n    const mockToken: JWT = {\n      id: 'user1', email: 'e@e.co', name: 'N', // 必須なものを適当に設定\n      exp: tokenExp,\n    };\n    const mockInitialSession: Session = {\n      user: {},\n      expires: 'initial',\n    };\n\n    const result = await sessionCallback({ session: mockInitialSession, token: mockToken, user: {} });\n\n    expect(result.expires).toBe(new Date(tokenExp * 1000).toISOString());\n  });\n\n  it('should handle token without name gracefully', async () => {\n    if (!sessionCallback) return;\n    const mockTokenWithoutName: JWT = {\n      id: 'user-no-name',\n      email: 'noname@example.com',\n      // name is intentionally omitted or null\n      name: null,\n      exp: Date.now() / 1000 + 3600,\n    };\n    const mockInitialSession: Session = { user: {}, expires: 'initial' };\n\n    const result = await sessionCallback({ session: mockInitialSession, token: mockTokenWithoutName, user: {} });\n\n    expect(result.user.name).toBeNull();\n  });\n  \n  it('should proceed without error if token.ua or window is not present', async () => {\n    if (!sessionCallback) return;\n    const mockTokenWithoutUA: JWT = {\n      id: 'user-no-ua',\n      email: 'noua@example.com',\n      name: 'No UA User',\n      exp: Date.now() / 1000 + 3600,\n      // ua is omitted\n    };\n    const mockInitialSession: Session = { user: {}, expires: 'initial' };\n\n    // windowオブジェクトがない環境 (Node.js/Jest) をシミュレート\n    const originalWindow = global.window;\n    // @ts-ignore\n    delete global.window;\n\n    let errorOccurred = false;\n    try {\n        await sessionCallback({ session: mockInitialSession, token: mockTokenWithoutUA, user: {} });\n    } catch (e) {\n        errorOccurred = true;\n    }\n    expect(errorOccurred).toBe(false);\n\n    // windowオブジェクトを元に戻す\n    global.window = originalWindow;\n  });\n\n  // uaミスマッチの警告テストは、console.warnのモックとwindow.navigator.userAgentの操作が必要で複雑になるため、\n  // E2Eテストでカバーする方が適切かもしれません。ここでは基本的なパススルーを確認します。\n});\n\n// TODO: refreshToken 関数のテスト (auth-options.ts内でexportされていれば) "],"names":["jest","mock","prisma","mockDeep","requireActual","comparePasswords","fn","prismaMock","comparePasswordsMock","describe","authorize","beforeAll","credentialsProvider","authOptions","providers","find","provider","name","beforeEach","clearAllMocks","mockResolvedValue","it","expect","toBe","console","warn","toBeDefined","email","rejects","toThrow","password","user","findUnique","mockUserWithoutPassword","id","mockUser","updatedAt","Date","update","result","toEqual","toHaveBeenCalledWith","where","data","any","jwtCallback","mockInitialToken","picture","sub","iat","Math","floor","now","exp","callbacks","jwt","tokenArg","token","toBeCloseTo","updatedName","sessionArg","trigger","session","expiringToken","refreshedDbUser","toBeGreaterThan","tokenWithoutExp","dbUser","validToken","not","toHaveBeenCalled","sessionCallback","mockToken","ua","mockInitialSession","expires","tokenExp","toISOString","mockTokenWithoutName","toBeNull","mockTokenWithoutUA","originalWindow","global","window","errorOccurred","e"],"mappings":"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"}