9d1f4829a35da207a480d57b3291ebe5
"use strict";
// Prisma Clientのモック
jest.mock('@/lib/db/prisma', ()=>({
        prisma: (0, _jestmockextended.mockDeep)()
    }));
// comparePasswordsのモック
jest.mock('@/lib/auth/password', ()=>({
        ...jest.requireActual('@/lib/auth/password'),
        comparePasswords: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _authoptions = require("@/lib/auth/auth-options");
const _prisma = require("@/lib/db/prisma");
const _password = require("@/lib/auth/password");
const _jestmockextended = require("jest-mock-extended");
const prismaMock = _prisma.prisma;
const comparePasswordsMock = _password.comparePasswords;
describe('authOptions - CredentialsProvider - authorize', ()=>{
    let authorize;
    beforeAll(()=>{
        // authOptionsからauthorize関数を取得
        const credentialsProvider = _authoptions.authOptions.providers.find((provider)=>provider.name === 'credentials');
        if (credentialsProvider && 'authorize' in credentialsProvider) {
            authorize = credentialsProvider.authorize;
        }
    });
    beforeEach(()=>{
        jest.clearAllMocks();
        comparePasswordsMock.mockResolvedValue(true); // デフォルトでパスワード一致
    });
    it('should throw error if authorize function is not found (config issue)', ()=>{
        if (!authorize) {
            expect(true).toBe(true); // authorize が undefined ならテストは実質的にパス
            console.warn('Authorize function not found in authOptions.Providers.Credentials. Test skipped.');
            return;
        }
        // authorizeが見つかれば、このテストは意味がないので、別の形で表明する
        expect(authorize).toBeDefined();
    });
    it('should throw error if email or password is not provided', async ()=>{
        if (!authorize) return; // authorize がなければテストスキップ
        await expect(authorize({
            email: 'test@example.com'
        })).rejects.toThrow('メールアドレスとパスワードは必須です');
        await expect(authorize({
            password: 'password123'
        })).rejects.toThrow('メールアドレスとパスワードは必須です');
        await expect(authorize({})).rejects.toThrow('メールアドレスとパスワードは必須です');
    });
    it('should throw error if user is not found', async ()=>{
        if (!authorize) return;
        prismaMock.user.findUnique.mockResolvedValue(null);
        await expect(authorize({
            email: 'nonexistent@example.com',
            password: 'password123'
        })).rejects.toThrow('メールアドレスまたはパスワードが正しくありません');
    });
    it('should throw error if user has no password set (e.g. OAuth user)', async ()=>{
        if (!authorize) return;
        const mockUserWithoutPassword = {
            id: 'user1',
            email: 'test@example.com',
            name: 'Test User',
            password: null
        }; // passwordがnullのケース
        prismaMock.user.findUnique.mockResolvedValue(mockUserWithoutPassword);
        await expect(authorize({
            email: 'test@example.com',
            password: 'password123'
        })).rejects.toThrow('メールアドレスまたはパスワードが正しくありません');
    });
    it('should throw error if password comparison fails', async ()=>{
        if (!authorize) return;
        const mockUser = {
            id: 'user1',
            email: 'test@example.com',
            name: 'Test User',
            password: 'hashedPassword'
        };
        prismaMock.user.findUnique.mockResolvedValue(mockUser);
        comparePasswordsMock.mockResolvedValue(false); // パスワード不一致
        await expect(authorize({
            email: 'test@example.com',
            password: 'wrongpassword'
        })).rejects.toThrow('メールアドレスまたはパスワードが正しくありません');
    });
    it('should return user object and update user on successful authorization', async ()=>{
        if (!authorize) return;
        const mockUser = {
            id: 'user1',
            email: 'test@example.com',
            name: 'Test User',
            password: 'hashedPassword',
            // ... other fields that might be needed for prisma.user.update
            updatedAt: new Date()
        };
        prismaMock.user.findUnique.mockResolvedValue(mockUser);
        comparePasswordsMock.mockResolvedValue(true);
        prismaMock.user.update.mockResolvedValue(mockUser); // モックされた更新後のユーザー
        const result = await authorize({
            email: 'test@example.com',
            password: 'password123'
        });
        expect(result).toEqual({
            id: mockUser.id,
            email: mockUser.email,
            name: mockUser.name
        });
        expect(prismaMock.user.findUnique).toHaveBeenCalledWith({
            where: {
                email: 'test@example.com'
            }
        });
        expect(comparePasswordsMock).toHaveBeenCalledWith('password123', 'hashedPassword');
        expect(prismaMock.user.update).toHaveBeenCalledWith({
            where: {
                id: mockUser.id
            },
            data: {
                updatedAt: expect.any(Date)
            }
        });
    });
});
describe('authOptions - callbacks.jwt', ()=>{
    let jwtCallback;
    const mockInitialToken = {
        name: 'Initial Name',
        email: 'initial@example.com',
        picture: 'initial_pic',
        sub: 'initial_sub',
        iat: Math.floor(Date.now() / 1000) - 3600,
        exp: Math.floor(Date.now() / 1000) + 3600
    };
    beforeAll(()=>{
        if (_authoptions.authOptions.callbacks && typeof _authoptions.authOptions.callbacks.jwt === 'function') {
            jwtCallback = _authoptions.authOptions.callbacks.jwt;
        }
    });
    beforeEach(()=>{
        jest.clearAllMocks();
        // refreshToken内のprisma.user.findUniqueのデフォルトモック
        prismaMock.user.findUnique.mockResolvedValue(null);
        // refreshToken内のprisma.user.updateのデフォルトモック
        prismaMock.user.update.mockResolvedValue({});
    });
    it('should add user info to token on initial sign in', async ()=>{
        if (!jwtCallback) return;
        const mockUser = {
            id: 'user123',
            email: 'newuser@example.com',
            name: 'New User'
        };
        const tokenArg = {
            ...mockInitialToken
        }; // 初期トークン (内容はjwtコールバック内で上書きされる)
        const result = await jwtCallback({
            token: tokenArg,
            user: mockUser
        });
        expect(result.id).toBe(mockUser.id);
        expect(result.email).toBe(mockUser.email);
        expect(result.name).toBe(mockUser.name);
        expect(result.iat).toBeCloseTo(Math.floor(Date.now() / 1000), -1);
        expect(result.exp).toBeCloseTo(Math.floor(Date.now() / 1000) + 24 * 60 * 60, -1);
    // uaのテストはwindowがないためここでは省略 (E2Eで確認)
    });
    it('should update token name if trigger is update and session has userName', async ()=>{
        if (!jwtCallback) return;
        const updatedName = 'Updated Name';
        const tokenArg = {
            ...mockInitialToken,
            email: 'test@example.com'
        }; // emailが必要なため設定
        const sessionArg = {
            user: {
                name: updatedName
            }
        };
        // refreshTokenがDBアクセスしないようにモック (expを十分に未来にする)
        tokenArg.exp = Math.floor(Date.now() / 1000) + 2 * 24 * 60 * 60; // 2日後
        const result = await jwtCallback({
            token: tokenArg,
            trigger: 'update',
            session: sessionArg
        });
        expect(result.name).toBe(updatedName);
    });
    it('should call refreshToken and return its result (expiring soon case)', async ()=>{
        if (!jwtCallback) return;
        const expiringToken = {
            ...mockInitialToken,
            email: 'refresh@example.com',
            exp: Math.floor(Date.now() / 1000) + 60
        };
        const refreshedDbUser = {
            id: 'refreshed-id',
            email: 'refresh@example.com',
            name: 'Refreshed User'
        };
        prismaMock.user.findUnique.mockResolvedValue(refreshedDbUser);
        // prisma.user.updateはデフォルトモックでOK
        const result = await jwtCallback({
            token: expiringToken
        });
        expect(prismaMock.user.findUnique).toHaveBeenCalledWith({
            where: {
                email: expiringToken.email
            }
        });
        expect(prismaMock.user.update).toHaveBeenCalledWith({
            where: {
                id: refreshedDbUser.id
            },
            data: {
                updatedAt: expect.any(Date)
            }
        });
        expect(result.exp).toBeGreaterThan(expiringToken.exp);
        expect(result.exp).toBeCloseTo(Math.floor(Date.now() / 1000) + 24 * 60 * 60, -1);
    });
    it('should call refreshToken and return its result (no exp case)', async ()=>{
        if (!jwtCallback) return;
        const tokenWithoutExp = {
            ...mockInitialToken,
            email: 'noexp@example.com'
        };
        delete tokenWithoutExp.exp; // expを削除
        const dbUser = {
            id: 'noexp-id',
            email: 'noexp@example.com',
            name: 'No Exp User'
        };
        // refreshTokenはexpがない場合、DBアクセスはしない (現在の実装では)
        // しかし、emailがtokenにあれば、userを探しに行くロジックになっている。
        // そのため、findUniqueは呼ばれる。
        prismaMock.user.findUnique.mockResolvedValue(dbUser);
        const result = await jwtCallback({
            token: tokenWithoutExp
        });
        expect(result.exp).toBeDefined();
        expect(result.exp).toBeCloseTo(Math.floor(Date.now() / 1000) + 24 * 60 * 60, -1);
        // expがない場合、refreshToken内でDBアクセスが走るかどうかはrefreshTokenの実装による
        // 現状の実装(auth-options.ts)では、token.emailがあればfindUniqueが呼ばれる
        expect(prismaMock.user.findUnique).toHaveBeenCalledWith({
            where: {
                email: tokenWithoutExp.email
            }
        });
        // userが見つかればupdateも呼ばれる
        expect(prismaMock.user.update).toHaveBeenCalledWith({
            where: {
                id: dbUser.id
            },
            data: {
                updatedAt: expect.any(Date)
            }
        });
    });
    it('should not refresh token if expiry is not soon and exp exists', async ()=>{
        if (!jwtCallback) return;
        const validToken = {
            ...mockInitialToken,
            email: 'valid@example.com',
            exp: Math.floor(Date.now() / 1000) + 10 * 60
        };
        const result = await jwtCallback({
            token: validToken
        });
        expect(prismaMock.user.findUnique).not.toHaveBeenCalled();
        expect(prismaMock.user.update).not.toHaveBeenCalled();
        expect(result.exp).toBe(validToken.exp);
    });
});
describe('authOptions - callbacks.session', ()=>{
    let sessionCallback;
    beforeAll(()=>{
        if (_authoptions.authOptions.callbacks && typeof _authoptions.authOptions.callbacks.session === 'function') {
            sessionCallback = _authoptions.authOptions.callbacks.session;
        }
    });
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    it('should transfer id, email, name from token to session.user', async ()=>{
        if (!sessionCallback) return;
        const mockToken = {
            id: 'token-user-id',
            email: 'token@example.com',
            name: 'Token User Name',
            sub: 'tokensub',
            iat: Date.now() / 1000,
            exp: Date.now() / 1000 + 3600,
            ua: 'test-user-agent'
        };
        const mockInitialSession = {
            user: {
            },
            expires: 'some-initial-expiry'
        };
        const result = await sessionCallback({
            session: mockInitialSession,
            token: mockToken,
            user: {} /* userは使われない */ 
        });
        expect(result.user.id).toBe(mockToken.id);
        expect(result.user.email).toBe(mockToken.email);
        expect(result.user.name).toBe(mockToken.name);
    });
    it('should add expires to session from token.exp', async ()=>{
        if (!sessionCallback) return;
        const tokenExp = Math.floor(Date.now() / 1000) + 2 * 60 * 60; // 2時間後
        const mockToken = {
            id: 'user1',
            email: 'e@e.co',
            name: 'N',
            exp: tokenExp
        };
        const mockInitialSession = {
            user: {},
            expires: 'initial'
        };
        const result = await sessionCallback({
            session: mockInitialSession,
            token: mockToken,
            user: {}
        });
        expect(result.expires).toBe(new Date(tokenExp * 1000).toISOString());
    });
    it('should handle token without name gracefully', async ()=>{
        if (!sessionCallback) return;
        const mockTokenWithoutName = {
            id: 'user-no-name',
            email: 'noname@example.com',
            // name is intentionally omitted or null
            name: null,
            exp: Date.now() / 1000 + 3600
        };
        const mockInitialSession = {
            user: {},
            expires: 'initial'
        };
        const result = await sessionCallback({
            session: mockInitialSession,
            token: mockTokenWithoutName,
            user: {}
        });
        expect(result.user.name).toBeNull();
    });
    it('should proceed without error if token.ua or window is not present', async ()=>{
        if (!sessionCallback) return;
        const mockTokenWithoutUA = {
            id: 'user-no-ua',
            email: 'noua@example.com',
            name: 'No UA User',
            exp: Date.now() / 1000 + 3600
        };
        const mockInitialSession = {
            user: {},
            expires: 'initial'
        };
        // windowオブジェクトがない環境 (Node.js/Jest) をシミュレート
        const originalWindow = global.window;
        // @ts-ignore
        delete global.window;
        let errorOccurred = false;
        try {
            await sessionCallback({
                session: mockInitialSession,
                token: mockTokenWithoutUA,
                user: {}
            });
        } catch (e) {
            errorOccurred = true;
        }
        expect(errorOccurred).toBe(false);
        // windowオブジェクトを元に戻す
        global.window = originalWindow;
    });
// uaミスマッチの警告テストは、console.warnのモックとwindow.navigator.userAgentの操作が必要で複雑になるため、
// E2Eテストでカバーする方が適切かもしれません。ここでは基本的なパススルーを確認します。
}); // TODO: refreshToken 関数のテスト (auth-options.ts内でexportされていれば) 

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95dXN1a2V0c3Vub2RhL0RvY3VtZW50cy9jdXJzb3IvcHB0dHJhbnNsYXRvcmFwcC93b3JrdHJlZXMvZmVhdHVyZS10ZXN0LWNvdmVyYWdlLWltcHJvdmVtZW50L3Rlc3RzL2xpYi9hdXRoL2F1dGgtb3B0aW9ucy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF1dGhPcHRpb25zIH0gZnJvbSAnQC9saWIvYXV0aC9hdXRoLW9wdGlvbnMnO1xuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSAnQC9saWIvZGIvcHJpc21hJztcbmltcG9ydCB7IGNvbXBhcmVQYXNzd29yZHMgfSBmcm9tICdAL2xpYi9hdXRoL3Bhc3N3b3JkJztcbmltcG9ydCB7IERlZXBNb2NrUHJveHksIG1vY2tEZWVwIH0gZnJvbSAnamVzdC1tb2NrLWV4dGVuZGVkJztcbmltcG9ydCB7IFVzZXIgfSBmcm9tICdAcHJpc21hL2NsaWVudCc7XG5pbXBvcnQgeyBKV1QgfSBmcm9tICduZXh0LWF1dGgvand0JztcbmltcG9ydCB7IFNlc3Npb24gfSBmcm9tICduZXh0LWF1dGgnO1xuXG4vLyBQcmlzbWEgQ2xpZW5044Gu44Oi44OD44KvXG5qZXN0Lm1vY2soJ0AvbGliL2RiL3ByaXNtYScsICgpID0+ICh7XG4gIHByaXNtYTogbW9ja0RlZXA8RGVlcE1vY2tQcm94eTx0eXBlb2YgcHJpc21hPj4oKSxcbn0pKTtcblxuLy8gY29tcGFyZVBhc3N3b3Jkc+OBruODouODg+OCr1xuamVzdC5tb2NrKCdAL2xpYi9hdXRoL3Bhc3N3b3JkJywgKCkgPT4gKHtcbiAgLi4uamVzdC5yZXF1aXJlQWN0dWFsKCdAL2xpYi9hdXRoL3Bhc3N3b3JkJyksIC8vIGhhc2hQYXNzd29yZCDjgarjganku5bjga7plqLmlbDjga/jgZ3jga7jgb7jgb7kvb/jgYblj6/og73mgKfjgpLogIPmha5cbiAgY29tcGFyZVBhc3N3b3JkczogamVzdC5mbigpLFxufSkpO1xuXG5jb25zdCBwcmlzbWFNb2NrID0gcHJpc21hIGFzIHVua25vd24gYXMgRGVlcE1vY2tQcm94eTx0eXBlb2YgcHJpc21hPjtcbmNvbnN0IGNvbXBhcmVQYXNzd29yZHNNb2NrID0gY29tcGFyZVBhc3N3b3JkcyBhcyBqZXN0Lk1vY2s7XG5cbmRlc2NyaWJlKCdhdXRoT3B0aW9ucyAtIENyZWRlbnRpYWxzUHJvdmlkZXIgLSBhdXRob3JpemUnLCAoKSA9PiB7XG4gIGxldCBhdXRob3JpemU6ICgoY3JlZGVudGlhbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWQpID0+IFByb21pc2U8YW55PikgfCB1bmRlZmluZWQ7XG5cbiAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICAvLyBhdXRoT3B0aW9uc+OBi+OCiWF1dGhvcml6ZemWouaVsOOCkuWPluW+l1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzUHJvdmlkZXIgPSBhdXRoT3B0aW9ucy5wcm92aWRlcnMuZmluZChcbiAgICAgIChwcm92aWRlcikgPT4gcHJvdmlkZXIubmFtZSA9PT0gJ2NyZWRlbnRpYWxzJ1xuICAgICk7XG4gICAgaWYgKGNyZWRlbnRpYWxzUHJvdmlkZXIgJiYgJ2F1dGhvcml6ZScgaW4gY3JlZGVudGlhbHNQcm92aWRlcikge1xuICAgICAgYXV0aG9yaXplID0gY3JlZGVudGlhbHNQcm92aWRlci5hdXRob3JpemU7XG4gICAgfVxuICB9KTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBjb21wYXJlUGFzc3dvcmRzTW9jay5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTsgLy8g44OH44OV44Kp44Or44OI44Gn44OR44K544Ov44O844OJ5LiA6Ie0XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgYXV0aG9yaXplIGZ1bmN0aW9uIGlzIG5vdCBmb3VuZCAoY29uZmlnIGlzc3VlKScsICgpID0+IHtcbiAgICBpZiAoIWF1dGhvcml6ZSkgeyAvLyDjgZPjga7jg4bjgrnjg4jjgrHjg7zjgrnjga9hdXRob3JpemXjgYzopovjgaTjgYvjgonjgarjgYTloLTlkIjjgavlrp/ooYzjgZXjgozjgotcbiAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpOyAvLyBhdXRob3JpemUg44GMIHVuZGVmaW5lZCDjgarjgonjg4bjgrnjg4jjga/lrp/os6rnmoTjgavjg5HjgrlcbiAgICAgIGNvbnNvbGUud2FybignQXV0aG9yaXplIGZ1bmN0aW9uIG5vdCBmb3VuZCBpbiBhdXRoT3B0aW9ucy5Qcm92aWRlcnMuQ3JlZGVudGlhbHMuIFRlc3Qgc2tpcHBlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYXV0aG9yaXpl44GM6KaL44Gk44GL44KM44Gw44CB44GT44Gu44OG44K544OI44Gv5oSP5ZGz44GM44Gq44GE44Gu44Gn44CB5Yil44Gu5b2i44Gn6KGo5piO44GZ44KLXG4gICAgZXhwZWN0KGF1dGhvcml6ZSkudG9CZURlZmluZWQoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBpZiBlbWFpbCBvciBwYXNzd29yZCBpcyBub3QgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFhdXRob3JpemUpIHJldHVybjsgLy8gYXV0aG9yaXplIOOBjOOBquOBkeOCjOOBsOODhuOCueODiOOCueOCreODg+ODl1xuICAgIGF3YWl0IGV4cGVjdChhdXRob3JpemUoeyBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0pKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAn44Oh44O844Or44Ki44OJ44Os44K544Go44OR44K544Ov44O844OJ44Gv5b+F6aCI44Gn44GZJ1xuICAgICk7XG4gICAgYXdhaXQgZXhwZWN0KGF1dGhvcml6ZSh7IHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnIH0pKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAn44Oh44O844Or44Ki44OJ44Os44K544Go44OR44K544Ov44O844OJ44Gv5b+F6aCI44Gn44GZJ1xuICAgICk7XG4gICAgYXdhaXQgZXhwZWN0KGF1dGhvcml6ZSh7fSkpLnJlamVjdHMudG9UaHJvdygn44Oh44O844Or44Ki44OJ44Os44K544Go44OR44K544Ov44O844OJ44Gv5b+F6aCI44Gn44GZJyk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgdXNlciBpcyBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFhdXRob3JpemUpIHJldHVybjtcbiAgICBwcmlzbWFNb2NrLnVzZXIuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICBhd2FpdCBleHBlY3QoXG4gICAgICBhdXRob3JpemUoeyBlbWFpbDogJ25vbmV4aXN0ZW50QGV4YW1wbGUuY29tJywgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycgfSlcbiAgICApLnJlamVjdHMudG9UaHJvdygn44Oh44O844Or44Ki44OJ44Os44K544G+44Gf44Gv44OR44K544Ov44O844OJ44GM5q2j44GX44GP44GC44KK44G+44Gb44KTJyk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgdXNlciBoYXMgbm8gcGFzc3dvcmQgc2V0IChlLmcuIE9BdXRoIHVzZXIpJywgYXN5bmMgKCkgPT4ge1xuICAgIGlmICghYXV0aG9yaXplKSByZXR1cm47XG4gICAgY29uc3QgbW9ja1VzZXJXaXRob3V0UGFzc3dvcmQgPSB7XG4gICAgICBpZDogJ3VzZXIxJywgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJywgbmFtZTogJ1Rlc3QgVXNlcicsIHBhc3N3b3JkOiBudWxsIFxuICAgIH0gYXMgdW5rbm93biBhcyBVc2VyOyAvLyBwYXNzd29yZOOBjG51bGzjga7jgrHjg7zjgrlcbiAgICBwcmlzbWFNb2NrLnVzZXIuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcldpdGhvdXRQYXNzd29yZCk7XG4gICAgYXdhaXQgZXhwZWN0KFxuICAgICAgYXV0aG9yaXplKHsgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJywgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycgfSlcbiAgICApLnJlamVjdHMudG9UaHJvdygn44Oh44O844Or44Ki44OJ44Os44K544G+44Gf44Gv44OR44K544Ov44O844OJ44GM5q2j44GX44GP44GC44KK44G+44Gb44KTJyk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgcGFzc3dvcmQgY29tcGFyaXNvbiBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWF1dGhvcml6ZSkgcmV0dXJuO1xuICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgaWQ6ICd1c2VyMScsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsIG5hbWU6ICdUZXN0IFVzZXInLCBwYXNzd29yZDogJ2hhc2hlZFBhc3N3b3JkJ1xuICAgIH0gYXMgVXNlcjtcbiAgICBwcmlzbWFNb2NrLnVzZXIuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG4gICAgY29tcGFyZVBhc3N3b3Jkc01vY2subW9ja1Jlc29sdmVkVmFsdWUoZmFsc2UpOyAvLyDjg5Hjgrnjg6/jg7zjg4nkuI3kuIDoh7RcblxuICAgIGF3YWl0IGV4cGVjdChcbiAgICAgIGF1dGhvcml6ZSh7IGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcgfSlcbiAgICApLnJlamVjdHMudG9UaHJvdygn44Oh44O844Or44Ki44OJ44Os44K544G+44Gf44Gv44OR44K544Ov44O844OJ44GM5q2j44GX44GP44GC44KK44G+44Gb44KTJyk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmV0dXJuIHVzZXIgb2JqZWN0IGFuZCB1cGRhdGUgdXNlciBvbiBzdWNjZXNzZnVsIGF1dGhvcml6YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFhdXRob3JpemUpIHJldHVybjtcbiAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgIGlkOiAndXNlcjEnLFxuICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgcGFzc3dvcmQ6ICdoYXNoZWRQYXNzd29yZCcsXG4gICAgICAvLyAuLi4gb3RoZXIgZmllbGRzIHRoYXQgbWlnaHQgYmUgbmVlZGVkIGZvciBwcmlzbWEudXNlci51cGRhdGVcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB9IGFzIFVzZXI7XG4gICAgcHJpc21hTW9jay51c2VyLmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuICAgIGNvbXBhcmVQYXNzd29yZHNNb2NrLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuICAgIHByaXNtYU1vY2sudXNlci51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpOyAvLyDjg6Ljg4Pjgq/jgZXjgozjgZ/mm7TmlrDlvozjga7jg6bjg7zjgrbjg7xcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhvcml6ZSh7IGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnIH0pO1xuXG4gICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICBpZDogbW9ja1VzZXIuaWQsXG4gICAgICBlbWFpbDogbW9ja1VzZXIuZW1haWwsXG4gICAgICBuYW1lOiBtb2NrVXNlci5uYW1lLFxuICAgIH0pO1xuICAgIGV4cGVjdChwcmlzbWFNb2NrLnVzZXIuZmluZFVuaXF1ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyB3aGVyZTogeyBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0gfSk7XG4gICAgZXhwZWN0KGNvbXBhcmVQYXNzd29yZHNNb2NrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgncGFzc3dvcmQxMjMnLCAnaGFzaGVkUGFzc3dvcmQnKTtcbiAgICBleHBlY3QocHJpc21hTW9jay51c2VyLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgd2hlcmU6IHsgaWQ6IG1vY2tVc2VyLmlkIH0sXG4gICAgICBkYXRhOiB7IHVwZGF0ZWRBdDogZXhwZWN0LmFueShEYXRlKSB9LFxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnYXV0aE9wdGlvbnMgLSBjYWxsYmFja3Muand0JywgKCkgPT4ge1xuICBsZXQgand0Q2FsbGJhY2s6ICgoYXJnczogeyB0b2tlbjogSldUOyB1c2VyPzogYW55OyBhY2NvdW50PzogYW55OyBwcm9maWxlPzogYW55OyBpc05ld1VzZXI/OiBib29sZWFuOyB0cmlnZ2VyPzogc3RyaW5nOyBzZXNzaW9uPzogYW55OyB9KSA9PiBQcm9taXNlPEpXVD4pIHwgdW5kZWZpbmVkO1xuICBjb25zdCBtb2NrSW5pdGlhbFRva2VuOiBKV1QgPSB7XG4gICAgbmFtZTogJ0luaXRpYWwgTmFtZScsXG4gICAgZW1haWw6ICdpbml0aWFsQGV4YW1wbGUuY29tJyxcbiAgICBwaWN0dXJlOiAnaW5pdGlhbF9waWMnLFxuICAgIHN1YjogJ2luaXRpYWxfc3ViJyxcbiAgICBpYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gMzYwMCwgLy8gMeaZgumWk+WJjVxuICAgIGV4cDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAzNjAwLCAvLyAx5pmC6ZaT5b6MXG4gIH07XG5cbiAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICBpZiAoYXV0aE9wdGlvbnMuY2FsbGJhY2tzICYmIHR5cGVvZiBhdXRoT3B0aW9ucy5jYWxsYmFja3Muand0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBqd3RDYWxsYmFjayA9IGF1dGhPcHRpb25zLmNhbGxiYWNrcy5qd3Q7XG4gICAgfVxuICB9KTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAvLyByZWZyZXNoVG9rZW7lhoXjga5wcmlzbWEudXNlci5maW5kVW5pcXVl44Gu44OH44OV44Kp44Or44OI44Oi44OD44KvXG4gICAgcHJpc21hTW9jay51c2VyLmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IFxuICAgIC8vIHJlZnJlc2hUb2tlbuWGheOBrnByaXNtYS51c2VyLnVwZGF0ZeOBruODh+ODleOCqeODq+ODiOODouODg+OCr1xuICAgIHByaXNtYU1vY2sudXNlci51cGRhdGUubW9ja1Jlc29sdmVkVmFsdWUoe30gYXMgYW55KTsgXG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWRkIHVzZXIgaW5mbyB0byB0b2tlbiBvbiBpbml0aWFsIHNpZ24gaW4nLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFqd3RDYWxsYmFjaykgcmV0dXJuO1xuICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgaWQ6ICd1c2VyMTIzJyxcbiAgICAgIGVtYWlsOiAnbmV3dXNlckBleGFtcGxlLmNvbScsXG4gICAgICBuYW1lOiAnTmV3IFVzZXInLFxuICAgIH07XG4gICAgY29uc3QgdG9rZW5BcmcgPSB7IC4uLm1vY2tJbml0aWFsVG9rZW4gfTsgLy8g5Yid5pyf44OI44O844Kv44OzICjlhoXlrrnjga9qd3TjgrPjg7zjg6vjg5Djg4Pjgq/lhoXjgafkuIrmm7jjgY3jgZXjgozjgospXG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBqd3RDYWxsYmFjayh7IHRva2VuOiB0b2tlbkFyZywgdXNlcjogbW9ja1VzZXIgfSk7XG5cbiAgICBleHBlY3QocmVzdWx0LmlkKS50b0JlKG1vY2tVc2VyLmlkKTtcbiAgICBleHBlY3QocmVzdWx0LmVtYWlsKS50b0JlKG1vY2tVc2VyLmVtYWlsKTtcbiAgICBleHBlY3QocmVzdWx0Lm5hbWUpLnRvQmUobW9ja1VzZXIubmFtZSk7XG4gICAgZXhwZWN0KHJlc3VsdC5pYXQpLnRvQmVDbG9zZVRvKE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLCAtMSk7XG4gICAgZXhwZWN0KHJlc3VsdC5leHApLnRvQmVDbG9zZVRvKE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgMjQgKiA2MCAqIDYwLCAtMSk7XG4gICAgLy8gdWHjga7jg4bjgrnjg4jjga93aW5kb3fjgYzjgarjgYTjgZ/jgoHjgZPjgZPjgafjga/nnIHnlaUgKEUyReOBp+eiuuiqjSlcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB1cGRhdGUgdG9rZW4gbmFtZSBpZiB0cmlnZ2VyIGlzIHVwZGF0ZSBhbmQgc2Vzc2lvbiBoYXMgdXNlck5hbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFqd3RDYWxsYmFjaykgcmV0dXJuO1xuICAgIGNvbnN0IHVwZGF0ZWROYW1lID0gJ1VwZGF0ZWQgTmFtZSc7XG4gICAgY29uc3QgdG9rZW5BcmcgPSB7IC4uLm1vY2tJbml0aWFsVG9rZW4sIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfTsgLy8gZW1haWzjgYzlv4XopoHjgarjgZ/jgoHoqK3lrppcbiAgICBjb25zdCBzZXNzaW9uQXJnID0geyB1c2VyOiB7IG5hbWU6IHVwZGF0ZWROYW1lIH0gfTtcblxuICAgIC8vIHJlZnJlc2hUb2tlbuOBjERC44Ki44Kv44K744K544GX44Gq44GE44KI44GG44Gr44Oi44OD44KvIChleHDjgpLljYHliIbjgavmnKrmnaXjgavjgZnjgospXG4gICAgdG9rZW5BcmcuZXhwID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAyICogMjQgKiA2MCAqIDYwOyAvLyAy5pel5b6MXG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgand0Q2FsbGJhY2soeyB0b2tlbjogdG9rZW5BcmcsIHRyaWdnZXI6ICd1cGRhdGUnLCBzZXNzaW9uOiBzZXNzaW9uQXJnIH0pO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5uYW1lKS50b0JlKHVwZGF0ZWROYW1lKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBjYWxsIHJlZnJlc2hUb2tlbiBhbmQgcmV0dXJuIGl0cyByZXN1bHQgKGV4cGlyaW5nIHNvb24gY2FzZSknLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFqd3RDYWxsYmFjaykgcmV0dXJuO1xuICAgIGNvbnN0IGV4cGlyaW5nVG9rZW4gPSB7XG4gICAgICAuLi5tb2NrSW5pdGlhbFRva2VuLFxuICAgICAgZW1haWw6ICdyZWZyZXNoQGV4YW1wbGUuY29tJywgLy8gcmVmcmVzaFRva2Vu5YaF44GuRELmpJzntKLjgafkvb/jgYZcbiAgICAgIGV4cDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyA2MCwgLy8gMeWIhuW+jOOBq+acn+mZkOWIh+OCjFxuICAgIH07XG4gICAgY29uc3QgcmVmcmVzaGVkRGJVc2VyID0ge1xuICAgICAgaWQ6ICdyZWZyZXNoZWQtaWQnLCBlbWFpbDogJ3JlZnJlc2hAZXhhbXBsZS5jb20nLCBuYW1lOiAnUmVmcmVzaGVkIFVzZXInXG4gICAgfSBhcyBVc2VyO1xuXG4gICAgcHJpc21hTW9jay51c2VyLmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUocmVmcmVzaGVkRGJVc2VyKTtcbiAgICAvLyBwcmlzbWEudXNlci51cGRhdGXjga/jg4fjg5Xjgqnjg6vjg4jjg6Ljg4Pjgq/jgadPS1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgand0Q2FsbGJhY2soeyB0b2tlbjogZXhwaXJpbmdUb2tlbiB9KTtcblxuICAgIGV4cGVjdChwcmlzbWFNb2NrLnVzZXIuZmluZFVuaXF1ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyB3aGVyZTogeyBlbWFpbDogZXhwaXJpbmdUb2tlbi5lbWFpbCB9IH0pO1xuICAgIGV4cGVjdChwcmlzbWFNb2NrLnVzZXIudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICB3aGVyZTogeyBpZDogcmVmcmVzaGVkRGJVc2VyLmlkIH0sXG4gICAgICBkYXRhOiB7IHVwZGF0ZWRBdDogZXhwZWN0LmFueShEYXRlKSB9LFxuICAgIH0pO1xuICAgIGV4cGVjdChyZXN1bHQuZXhwKS50b0JlR3JlYXRlclRoYW4oZXhwaXJpbmdUb2tlbi5leHAgYXMgbnVtYmVyKTtcbiAgICBleHBlY3QocmVzdWx0LmV4cCkudG9CZUNsb3NlVG8oTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAyNCAqIDYwICogNjAsIC0xKTtcbiAgfSk7XG5cbiAgIGl0KCdzaG91bGQgY2FsbCByZWZyZXNoVG9rZW4gYW5kIHJldHVybiBpdHMgcmVzdWx0IChubyBleHAgY2FzZSknLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFqd3RDYWxsYmFjaykgcmV0dXJuO1xuICAgIGNvbnN0IHRva2VuV2l0aG91dEV4cCA9IHtcbiAgICAgIC4uLm1vY2tJbml0aWFsVG9rZW4sXG4gICAgICBlbWFpbDogJ25vZXhwQGV4YW1wbGUuY29tJyxcbiAgICB9O1xuICAgIGRlbGV0ZSB0b2tlbldpdGhvdXRFeHAuZXhwOyAvLyBleHDjgpLliYrpmaRcbiAgICBjb25zdCBkYlVzZXIgPSB7XG4gICAgICBpZDogJ25vZXhwLWlkJywgZW1haWw6ICdub2V4cEBleGFtcGxlLmNvbScsIG5hbWU6ICdObyBFeHAgVXNlcidcbiAgICB9IGFzIFVzZXI7XG5cbiAgICAvLyByZWZyZXNoVG9rZW7jga9leHDjgYzjgarjgYTloLTlkIjjgIFEQuOCouOCr+OCu+OCueOBr+OBl+OBquOBhCAo54++5Zyo44Gu5a6f6KOF44Gn44GvKVxuICAgIC8vIOOBl+OBi+OBl+OAgWVtYWls44GMdG9rZW7jgavjgYLjgozjgbDjgIF1c2Vy44KS5o6i44GX44Gr6KGM44GP44Ot44K444OD44Kv44Gr44Gq44Gj44Gm44GE44KL44CCXG4gICAgLy8g44Gd44Gu44Gf44KB44CBZmluZFVuaXF1ZeOBr+WRvOOBsOOCjOOCi+OAglxuICAgIHByaXNtYU1vY2sudXNlci5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKGRiVXNlcik7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBqd3RDYWxsYmFjayh7IHRva2VuOiB0b2tlbldpdGhvdXRFeHAgfSk7XG4gICAgXG4gICAgZXhwZWN0KHJlc3VsdC5leHApLnRvQmVEZWZpbmVkKCk7XG4gICAgZXhwZWN0KHJlc3VsdC5leHApLnRvQmVDbG9zZVRvKE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgMjQgKiA2MCAqIDYwLCAtMSk7XG4gICAgLy8gZXhw44GM44Gq44GE5aC05ZCI44CBcmVmcmVzaFRva2Vu5YaF44GnRELjgqLjgq/jgrvjgrnjgYzotbDjgovjgYvjganjgYbjgYvjga9yZWZyZXNoVG9rZW7jga7lrp/oo4XjgavjgojjgotcbiAgICAvLyDnj77nirbjga7lrp/oo4UoYXV0aC1vcHRpb25zLnRzKeOBp+OBr+OAgXRva2VuLmVtYWls44GM44GC44KM44GwZmluZFVuaXF1ZeOBjOWRvOOBsOOCjOOCi1xuICAgIGV4cGVjdChwcmlzbWFNb2NrLnVzZXIuZmluZFVuaXF1ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyB3aGVyZTogeyBlbWFpbDogdG9rZW5XaXRob3V0RXhwLmVtYWlsIH0gfSk7XG4gICAgLy8gdXNlcuOBjOimi+OBpOOBi+OCjOOBsHVwZGF0ZeOCguWRvOOBsOOCjOOCi1xuICAgIGV4cGVjdChwcmlzbWFNb2NrLnVzZXIudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7aWQ6IGRiVXNlci5pZH0sXG4gICAgICAgIGRhdGE6IHt1cGRhdGVkQXQ6IGV4cGVjdC5hbnkoRGF0ZSl9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgbm90IHJlZnJlc2ggdG9rZW4gaWYgZXhwaXJ5IGlzIG5vdCBzb29uIGFuZCBleHAgZXhpc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgIGlmICghand0Q2FsbGJhY2spIHJldHVybjtcbiAgICBjb25zdCB2YWxpZFRva2VuID0ge1xuICAgICAgLi4ubW9ja0luaXRpYWxUb2tlbixcbiAgICAgIGVtYWlsOiAndmFsaWRAZXhhbXBsZS5jb20nLFxuICAgICAgZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDEwICogNjAsIC8vIDEw5YiG5b6MICjjg6rjg5Xjg6zjg4Pjgrfjg6Xjg57jg7zjgrjjg7PjgojjgorlpKfjgY3jgYQpXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGp3dENhbGxiYWNrKHsgdG9rZW46IHZhbGlkVG9rZW4gfSk7XG5cbiAgICBleHBlY3QocHJpc21hTW9jay51c2VyLmZpbmRVbmlxdWUpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgZXhwZWN0KHByaXNtYU1vY2sudXNlci51cGRhdGUpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgZXhwZWN0KHJlc3VsdC5leHApLnRvQmUodmFsaWRUb2tlbi5leHApO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnYXV0aE9wdGlvbnMgLSBjYWxsYmFja3Muc2Vzc2lvbicsICgpID0+IHtcbiAgbGV0IHNlc3Npb25DYWxsYmFjazogKChhcmdzOiB7IHNlc3Npb246IFNlc3Npb247IHRva2VuOiBKV1Q7IHVzZXI6IGFueTsgfSkgPT4gUHJvbWlzZTxTZXNzaW9uPikgfCB1bmRlZmluZWQ7XG5cbiAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICBpZiAoYXV0aE9wdGlvbnMuY2FsbGJhY2tzICYmIHR5cGVvZiBhdXRoT3B0aW9ucy5jYWxsYmFja3Muc2Vzc2lvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2Vzc2lvbkNhbGxiYWNrID0gYXV0aE9wdGlvbnMuY2FsbGJhY2tzLnNlc3Npb247XG4gICAgfVxuICB9KTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB0cmFuc2ZlciBpZCwgZW1haWwsIG5hbWUgZnJvbSB0b2tlbiB0byBzZXNzaW9uLnVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFzZXNzaW9uQ2FsbGJhY2spIHJldHVybjtcbiAgICBjb25zdCBtb2NrVG9rZW46IEpXVCA9IHtcbiAgICAgIGlkOiAndG9rZW4tdXNlci1pZCcsXG4gICAgICBlbWFpbDogJ3Rva2VuQGV4YW1wbGUuY29tJyxcbiAgICAgIG5hbWU6ICdUb2tlbiBVc2VyIE5hbWUnLFxuICAgICAgc3ViOiAndG9rZW5zdWInLFxuICAgICAgaWF0OiBEYXRlLm5vdygpIC8gMTAwMCxcbiAgICAgIGV4cDogRGF0ZS5ub3coKSAvIDEwMDAgKyAzNjAwLCAvLyAx5pmC6ZaT5b6MXG4gICAgICB1YTogJ3Rlc3QtdXNlci1hZ2VudCcsIC8vIHVh44KC44OG44K544OI44Kx44O844K544Gr5ZCr44KB44KLXG4gICAgfTtcbiAgICBjb25zdCBtb2NrSW5pdGlhbFNlc3Npb246IFNlc3Npb24gPSB7XG4gICAgICB1c2VyOiB7XG4gICAgICAgIC8vIOWIneacn+OCu+ODg+OCt+ODp+ODs+OBrnVzZXLjga/kuIDpg6jmnKrlrprnvqnjgYvjgoLjgZfjgozjgarjgYRcbiAgICAgIH0sXG4gICAgICBleHBpcmVzOiAnc29tZS1pbml0aWFsLWV4cGlyeScsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlc3Npb25DYWxsYmFjayh7IHNlc3Npb246IG1vY2tJbml0aWFsU2Vzc2lvbiwgdG9rZW46IG1vY2tUb2tlbiwgdXNlcjoge30gLyogdXNlcuOBr+S9v+OCj+OCjOOBquOBhCAqLyB9KTtcblxuICAgIGV4cGVjdChyZXN1bHQudXNlci5pZCkudG9CZShtb2NrVG9rZW4uaWQpO1xuICAgIGV4cGVjdChyZXN1bHQudXNlci5lbWFpbCkudG9CZShtb2NrVG9rZW4uZW1haWwpO1xuICAgIGV4cGVjdChyZXN1bHQudXNlci5uYW1lKS50b0JlKG1vY2tUb2tlbi5uYW1lKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBhZGQgZXhwaXJlcyB0byBzZXNzaW9uIGZyb20gdG9rZW4uZXhwJywgYXN5bmMgKCkgPT4ge1xuICAgIGlmICghc2Vzc2lvbkNhbGxiYWNrKSByZXR1cm47XG4gICAgY29uc3QgdG9rZW5FeHAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDIgKiA2MCAqIDYwOyAvLyAy5pmC6ZaT5b6MXG4gICAgY29uc3QgbW9ja1Rva2VuOiBKV1QgPSB7XG4gICAgICBpZDogJ3VzZXIxJywgZW1haWw6ICdlQGUuY28nLCBuYW1lOiAnTicsIC8vIOW/hemgiOOBquOCguOBruOCkumBqeW9k+OBq+ioreWumlxuICAgICAgZXhwOiB0b2tlbkV4cCxcbiAgICB9O1xuICAgIGNvbnN0IG1vY2tJbml0aWFsU2Vzc2lvbjogU2Vzc2lvbiA9IHtcbiAgICAgIHVzZXI6IHt9LFxuICAgICAgZXhwaXJlczogJ2luaXRpYWwnLFxuICAgIH07XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXNzaW9uQ2FsbGJhY2soeyBzZXNzaW9uOiBtb2NrSW5pdGlhbFNlc3Npb24sIHRva2VuOiBtb2NrVG9rZW4sIHVzZXI6IHt9IH0pO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5leHBpcmVzKS50b0JlKG5ldyBEYXRlKHRva2VuRXhwICogMTAwMCkudG9JU09TdHJpbmcoKSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaGFuZGxlIHRva2VuIHdpdGhvdXQgbmFtZSBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgIGlmICghc2Vzc2lvbkNhbGxiYWNrKSByZXR1cm47XG4gICAgY29uc3QgbW9ja1Rva2VuV2l0aG91dE5hbWU6IEpXVCA9IHtcbiAgICAgIGlkOiAndXNlci1uby1uYW1lJyxcbiAgICAgIGVtYWlsOiAnbm9uYW1lQGV4YW1wbGUuY29tJyxcbiAgICAgIC8vIG5hbWUgaXMgaW50ZW50aW9uYWxseSBvbWl0dGVkIG9yIG51bGxcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICBleHA6IERhdGUubm93KCkgLyAxMDAwICsgMzYwMCxcbiAgICB9O1xuICAgIGNvbnN0IG1vY2tJbml0aWFsU2Vzc2lvbjogU2Vzc2lvbiA9IHsgdXNlcjoge30sIGV4cGlyZXM6ICdpbml0aWFsJyB9O1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2Vzc2lvbkNhbGxiYWNrKHsgc2Vzc2lvbjogbW9ja0luaXRpYWxTZXNzaW9uLCB0b2tlbjogbW9ja1Rva2VuV2l0aG91dE5hbWUsIHVzZXI6IHt9IH0pO1xuXG4gICAgZXhwZWN0KHJlc3VsdC51c2VyLm5hbWUpLnRvQmVOdWxsKCk7XG4gIH0pO1xuICBcbiAgaXQoJ3Nob3VsZCBwcm9jZWVkIHdpdGhvdXQgZXJyb3IgaWYgdG9rZW4udWEgb3Igd2luZG93IGlzIG5vdCBwcmVzZW50JywgYXN5bmMgKCkgPT4ge1xuICAgIGlmICghc2Vzc2lvbkNhbGxiYWNrKSByZXR1cm47XG4gICAgY29uc3QgbW9ja1Rva2VuV2l0aG91dFVBOiBKV1QgPSB7XG4gICAgICBpZDogJ3VzZXItbm8tdWEnLFxuICAgICAgZW1haWw6ICdub3VhQGV4YW1wbGUuY29tJyxcbiAgICAgIG5hbWU6ICdObyBVQSBVc2VyJyxcbiAgICAgIGV4cDogRGF0ZS5ub3coKSAvIDEwMDAgKyAzNjAwLFxuICAgICAgLy8gdWEgaXMgb21pdHRlZFxuICAgIH07XG4gICAgY29uc3QgbW9ja0luaXRpYWxTZXNzaW9uOiBTZXNzaW9uID0geyB1c2VyOiB7fSwgZXhwaXJlczogJ2luaXRpYWwnIH07XG5cbiAgICAvLyB3aW5kb3fjgqrjg5bjgrjjgqfjgq/jg4jjgYzjgarjgYTnkrDlooMgKE5vZGUuanMvSmVzdCkg44KS44K344Of44Ol44Os44O844OIXG4gICAgY29uc3Qgb3JpZ2luYWxXaW5kb3cgPSBnbG9iYWwud2luZG93O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBkZWxldGUgZ2xvYmFsLndpbmRvdztcblxuICAgIGxldCBlcnJvck9jY3VycmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgc2Vzc2lvbkNhbGxiYWNrKHsgc2Vzc2lvbjogbW9ja0luaXRpYWxTZXNzaW9uLCB0b2tlbjogbW9ja1Rva2VuV2l0aG91dFVBLCB1c2VyOiB7fSB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2NjdXJyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBleHBlY3QoZXJyb3JPY2N1cnJlZCkudG9CZShmYWxzZSk7XG5cbiAgICAvLyB3aW5kb3fjgqrjg5bjgrjjgqfjgq/jg4jjgpLlhYPjgavmiLvjgZlcbiAgICBnbG9iYWwud2luZG93ID0gb3JpZ2luYWxXaW5kb3c7XG4gIH0pO1xuXG4gIC8vIHVh44Of44K544Oe44OD44OB44Gu6K2m5ZGK44OG44K544OI44Gv44CBY29uc29sZS53YXJu44Gu44Oi44OD44Kv44God2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnTjga7mk43kvZzjgYzlv4XopoHjgafopIfpm5HjgavjgarjgovjgZ/jgoHjgIFcbiAgLy8gRTJF44OG44K544OI44Gn44Kr44OQ44O844GZ44KL5pa544GM6YGp5YiH44GL44KC44GX44KM44G+44Gb44KT44CC44GT44GT44Gn44Gv5Z+65pys55qE44Gq44OR44K544K544Or44O844KS56K66KqN44GX44G+44GZ44CCXG59KTtcblxuLy8gVE9ETzogcmVmcmVzaFRva2VuIOmWouaVsOOBruODhuOCueODiCAoYXV0aC1vcHRpb25zLnRz5YaF44GnZXhwb3J044GV44KM44Gm44GE44KM44GwKSAiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJwcmlzbWEiLCJtb2NrRGVlcCIsInJlcXVpcmVBY3R1YWwiLCJjb21wYXJlUGFzc3dvcmRzIiwiZm4iLCJwcmlzbWFNb2NrIiwiY29tcGFyZVBhc3N3b3Jkc01vY2siLCJkZXNjcmliZSIsImF1dGhvcml6ZSIsImJlZm9yZUFsbCIsImNyZWRlbnRpYWxzUHJvdmlkZXIiLCJhdXRoT3B0aW9ucyIsInByb3ZpZGVycyIsImZpbmQiLCJwcm92aWRlciIsIm5hbWUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiaXQiLCJleHBlY3QiLCJ0b0JlIiwiY29uc29sZSIsIndhcm4iLCJ0b0JlRGVmaW5lZCIsImVtYWlsIiwicmVqZWN0cyIsInRvVGhyb3ciLCJwYXNzd29yZCIsInVzZXIiLCJmaW5kVW5pcXVlIiwibW9ja1VzZXJXaXRob3V0UGFzc3dvcmQiLCJpZCIsIm1vY2tVc2VyIiwidXBkYXRlZEF0IiwiRGF0ZSIsInVwZGF0ZSIsInJlc3VsdCIsInRvRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIndoZXJlIiwiZGF0YSIsImFueSIsImp3dENhbGxiYWNrIiwibW9ja0luaXRpYWxUb2tlbiIsInBpY3R1cmUiLCJzdWIiLCJpYXQiLCJNYXRoIiwiZmxvb3IiLCJub3ciLCJleHAiLCJjYWxsYmFja3MiLCJqd3QiLCJ0b2tlbkFyZyIsInRva2VuIiwidG9CZUNsb3NlVG8iLCJ1cGRhdGVkTmFtZSIsInNlc3Npb25BcmciLCJ0cmlnZ2VyIiwic2Vzc2lvbiIsImV4cGlyaW5nVG9rZW4iLCJyZWZyZXNoZWREYlVzZXIiLCJ0b0JlR3JlYXRlclRoYW4iLCJ0b2tlbldpdGhvdXRFeHAiLCJkYlVzZXIiLCJ2YWxpZFRva2VuIiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsInNlc3Npb25DYWxsYmFjayIsIm1vY2tUb2tlbiIsInVhIiwibW9ja0luaXRpYWxTZXNzaW9uIiwiZXhwaXJlcyIsInRva2VuRXhwIiwidG9JU09TdHJpbmciLCJtb2NrVG9rZW5XaXRob3V0TmFtZSIsInRvQmVOdWxsIiwibW9ja1Rva2VuV2l0aG91dFVBIiwib3JpZ2luYWxXaW5kb3ciLCJnbG9iYWwiLCJ3aW5kb3ciLCJlcnJvck9jY3VycmVkIiwiZSJdLCJtYXBwaW5ncyI6IjtBQVFBLG9CQUFvQjtBQUNwQkEsS0FBS0MsSUFBSSxDQUFDLG1CQUFtQixJQUFPLENBQUE7UUFDbENDLFFBQVFDLElBQUFBLDBCQUFRO0lBQ2xCLENBQUE7QUFFQSx1QkFBdUI7QUFDdkJILEtBQUtDLElBQUksQ0FBQyx1QkFBdUIsSUFBTyxDQUFBO1FBQ3RDLEdBQUdELEtBQUtJLGFBQWEsQ0FBQyxzQkFBc0I7UUFDNUNDLGtCQUFrQkwsS0FBS00sRUFBRTtJQUMzQixDQUFBOzs7OzZCQWpCNEI7d0JBQ0w7MEJBQ1U7a0NBQ087QUFnQnhDLE1BQU1DLGFBQWFMLGNBQU07QUFDekIsTUFBTU0sdUJBQXVCSCwwQkFBZ0I7QUFFN0NJLFNBQVMsaURBQWlEO0lBQ3hELElBQUlDO0lBRUpD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