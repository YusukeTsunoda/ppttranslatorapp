{"version":3,"sources":["/Users/yusuketsunoda/Documents/cursor/ppttranslatorapp/node_modules/@testing-library/jest-dom/dist/matchers-7fb38cd4.js"],"sourcesContent":["'use strict';\n\nvar redent = require('redent');\nvar cssTools = require('@adobe/css-tools');\nvar domAccessibilityApi = require('dom-accessibility-api');\nvar ariaQuery = require('aria-query');\nvar chalk = require('chalk');\nvar isEqualWith = require('lodash/isEqualWith.js');\nvar escape = require('css.escape');\n\nclass GenericTypeError extends Error {\n  constructor(expectedString, received, matcherFn, context) {\n    super();\n\n    /* istanbul ignore next */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, matcherFn);\n    }\n    let withType = '';\n    try {\n      withType = context.utils.printWithType(\n        'Received',\n        received,\n        context.utils.printReceived,\n      );\n    } catch (e) {\n      // Can throw for Document:\n      // https://github.com/jsdom/jsdom/issues/2304\n    }\n    this.message = [\n      context.utils.matcherHint(\n        `${context.isNot ? '.not' : ''}.${matcherFn.name}`,\n        'received',\n        '',\n      ),\n      '',\n      // eslint-disable-next-line new-cap\n      `${context.utils.RECEIVED_COLOR(\n        'received',\n      )} value must ${expectedString}.`,\n      withType,\n    ].join('\\n');\n  }\n}\n\nclass HtmlElementTypeError extends GenericTypeError {\n  constructor(...args) {\n    super('be an HTMLElement or an SVGElement', ...args);\n  }\n}\n\nclass NodeTypeError extends GenericTypeError {\n  constructor(...args) {\n    super('be a Node', ...args);\n  }\n}\n\nfunction checkHasWindow(htmlElement, ErrorClass, ...args) {\n  if (\n    !htmlElement ||\n    !htmlElement.ownerDocument ||\n    !htmlElement.ownerDocument.defaultView\n  ) {\n    throw new ErrorClass(htmlElement, ...args)\n  }\n}\n\nfunction checkNode(node, ...args) {\n  checkHasWindow(node, NodeTypeError, ...args);\n  const window = node.ownerDocument.defaultView;\n\n  if (!(node instanceof window.Node)) {\n    throw new NodeTypeError(node, ...args)\n  }\n}\n\nfunction checkHtmlElement(htmlElement, ...args) {\n  checkHasWindow(htmlElement, HtmlElementTypeError, ...args);\n  const window = htmlElement.ownerDocument.defaultView;\n\n  if (\n    !(htmlElement instanceof window.HTMLElement) &&\n    !(htmlElement instanceof window.SVGElement)\n  ) {\n    throw new HtmlElementTypeError(htmlElement, ...args)\n  }\n}\n\nclass InvalidCSSError extends Error {\n  constructor(received, matcherFn, context) {\n    super();\n\n    /* istanbul ignore next */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, matcherFn);\n    }\n    this.message = [\n      received.message,\n      '',\n      // eslint-disable-next-line new-cap\n      context.utils.RECEIVED_COLOR(`Failing css:`),\n      // eslint-disable-next-line new-cap\n      context.utils.RECEIVED_COLOR(`${received.css}`),\n    ].join('\\n');\n  }\n}\n\nfunction parseCSS(css, ...args) {\n  const ast = cssTools.parse(`selector { ${css} }`, {silent: true}).stylesheet;\n\n  if (ast.parsingErrors && ast.parsingErrors.length > 0) {\n    const {reason, line} = ast.parsingErrors[0];\n\n    throw new InvalidCSSError(\n      {\n        css,\n        message: `Syntax error parsing expected css: ${reason} on line: ${line}`,\n      },\n      ...args,\n    )\n  }\n\n  const parsedRules = ast.rules[0].declarations\n    .filter(d => d.type === 'declaration')\n    .reduce(\n      (obj, {property, value}) => Object.assign(obj, {[property]: value}),\n      {},\n    );\n  return parsedRules\n}\n\nfunction display(context, value) {\n  return typeof value === 'string' ? value : context.utils.stringify(value)\n}\n\nfunction getMessage(\n  context,\n  matcher,\n  expectedLabel,\n  expectedValue,\n  receivedLabel,\n  receivedValue,\n) {\n  return [\n    `${matcher}\\n`,\n    // eslint-disable-next-line new-cap\n    `${expectedLabel}:\\n${context.utils.EXPECTED_COLOR(\n      redent(display(context, expectedValue), 2),\n    )}`,\n    // eslint-disable-next-line new-cap\n    `${receivedLabel}:\\n${context.utils.RECEIVED_COLOR(\n      redent(display(context, receivedValue), 2),\n    )}`,\n  ].join('\\n')\n}\n\nfunction matches(textToMatch, matcher) {\n  if (matcher instanceof RegExp) {\n    return matcher.test(textToMatch)\n  } else {\n    return textToMatch.includes(String(matcher))\n  }\n}\n\nfunction deprecate(name, replacementText) {\n  // Notify user that they are using deprecated functionality.\n  // eslint-disable-next-line no-console\n  console.warn(\n    `Warning: ${name} has been deprecated and will be removed in future updates.`,\n    replacementText,\n  );\n}\n\nfunction normalize(text) {\n  return text.replace(/\\s+/g, ' ').trim()\n}\n\nfunction getTag(element) {\n  return element.tagName && element.tagName.toLowerCase()\n}\n\nfunction getSelectValue({multiple, options}) {\n  const selectedOptions = [...options].filter(option => option.selected);\n\n  if (multiple) {\n    return [...selectedOptions].map(opt => opt.value)\n  }\n  /* istanbul ignore if */\n  if (selectedOptions.length === 0) {\n    return undefined // Couldn't make this happen, but just in case\n  }\n  return selectedOptions[0].value\n}\n\nfunction getInputValue(inputElement) {\n  switch (inputElement.type) {\n    case 'number':\n      return inputElement.value === '' ? null : Number(inputElement.value)\n    case 'checkbox':\n      return inputElement.checked\n    default:\n      return inputElement.value\n  }\n}\n\nconst rolesSupportingValues = ['meter', 'progressbar', 'slider', 'spinbutton'];\nfunction getAccessibleValue(element) {\n  if (!rolesSupportingValues.includes(element.getAttribute('role'))) {\n    return undefined\n  }\n  return Number(element.getAttribute('aria-valuenow'))\n}\n\nfunction getSingleElementValue(element) {\n  /* istanbul ignore if */\n  if (!element) {\n    return undefined\n  }\n\n  switch (element.tagName.toLowerCase()) {\n    case 'input':\n      return getInputValue(element)\n    case 'select':\n      return getSelectValue(element)\n    default: {\n      return element.value ?? getAccessibleValue(element)\n    }\n  }\n}\n\nfunction toSentence(\n  array,\n  {wordConnector = ', ', lastWordConnector = ' and '} = {},\n) {\n  return [array.slice(0, -1).join(wordConnector), array[array.length - 1]].join(\n    array.length > 1 ? lastWordConnector : '',\n  )\n}\n\nfunction compareArraysAsSet(arr1, arr2) {\n  if (Array.isArray(arr1) && Array.isArray(arr2)) {\n    return [...new Set(arr1)].every(v => new Set(arr2).has(v))\n  }\n  return undefined\n}\n\nfunction toBeInTheDOM(element, container) {\n  deprecate(\n    'toBeInTheDOM',\n    'Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container.',\n  );\n\n  if (element) {\n    checkHtmlElement(element, toBeInTheDOM, this);\n  }\n\n  if (container) {\n    checkHtmlElement(container, toBeInTheDOM, this);\n  }\n\n  return {\n    pass: container ? container.contains(element) : !!element,\n    message: () => {\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeInTheDOM`,\n          'element',\n          '',\n        ),\n        '',\n        'Received:',\n        `  ${this.utils.printReceived(\n          element ? element.cloneNode(false) : element,\n        )}`,\n      ].join('\\n')\n    },\n  }\n}\n\nfunction toBeInTheDocument(element) {\n  if (element !== null || !this.isNot) {\n    checkHtmlElement(element, toBeInTheDocument, this);\n  }\n\n  const pass =\n    element === null\n      ? false\n      : element.ownerDocument === element.getRootNode({composed: true});\n\n  const errorFound = () => {\n    return `expected document not to contain element, found ${this.utils.stringify(\n      element.cloneNode(true),\n    )} instead`\n  };\n  const errorNotFound = () => {\n    return `element could not be found in the document`\n  };\n\n  return {\n    pass,\n    message: () => {\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeInTheDocument`,\n          'element',\n          '',\n        ),\n        '',\n        // eslint-disable-next-line new-cap\n        this.utils.RECEIVED_COLOR(this.isNot ? errorFound() : errorNotFound()),\n      ].join('\\n')\n    },\n  }\n}\n\nfunction toBeEmpty(element) {\n  deprecate(\n    'toBeEmpty',\n    'Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM.',\n  );\n  checkHtmlElement(element, toBeEmpty, this);\n\n  return {\n    pass: element.innerHTML === '',\n    message: () => {\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeEmpty`,\n          'element',\n          '',\n        ),\n        '',\n        'Received:',\n        `  ${this.utils.printReceived(element.innerHTML)}`,\n      ].join('\\n')\n    },\n  }\n}\n\nfunction toBeEmptyDOMElement(element) {\n  checkHtmlElement(element, toBeEmptyDOMElement, this);\n\n  return {\n    pass: isEmptyElement(element),\n    message: () => {\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeEmptyDOMElement`,\n          'element',\n          '',\n        ),\n        '',\n        'Received:',\n        `  ${this.utils.printReceived(element.innerHTML)}`,\n      ].join('\\n')\n    },\n  }\n}\n\n/**\n * Identifies if an element doesn't contain child nodes (excluding comments)\n * â„¹ Node.COMMENT_NODE can't be used because of the following issue \n * https://github.com/jsdom/jsdom/issues/2220\n *\n * @param {*} element an HtmlElement or SVGElement\n * @return {*} true if the element only contains comments or none\n */\nfunction isEmptyElement(element){\n  const nonCommentChildNodes = [...element.childNodes].filter(node => node.nodeType !== 8);\n  return nonCommentChildNodes.length === 0;\n}\n\nfunction toContainElement(container, element) {\n  checkHtmlElement(container, toContainElement, this);\n\n  if (element !== null) {\n    checkHtmlElement(element, toContainElement, this);\n  }\n\n  return {\n    pass: container.contains(element),\n    message: () => {\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toContainElement`,\n          'element',\n          'element',\n        ),\n        '',\n        // eslint-disable-next-line new-cap\n        this.utils.RECEIVED_COLOR(`${this.utils.stringify(\n          container.cloneNode(false),\n        )} ${\n          this.isNot ? 'contains:' : 'does not contain:'\n        } ${this.utils.stringify(element ? element.cloneNode(false) : element)}\n        `),\n      ].join('\\n')\n    },\n  }\n}\n\nfunction getNormalizedHtml(container, htmlText) {\n  const div = container.ownerDocument.createElement('div');\n  div.innerHTML = htmlText;\n  return div.innerHTML\n}\n\nfunction toContainHTML(container, htmlText) {\n  checkHtmlElement(container, toContainHTML, this);\n\n  if (typeof htmlText !== 'string') {\n    throw new Error(`.toContainHTML() expects a string value, got ${htmlText}`)\n  }\n\n  return {\n    pass: container.outerHTML.includes(getNormalizedHtml(container, htmlText)),\n    message: () => {\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toContainHTML`,\n          'element',\n          '',\n        ),\n        'Expected:',\n        // eslint-disable-next-line new-cap\n        `  ${this.utils.EXPECTED_COLOR(htmlText)}`,\n        'Received:',\n        `  ${this.utils.printReceived(container.cloneNode(true))}`,\n      ].join('\\n')\n    },\n  }\n}\n\nfunction toHaveTextContent(\n  node,\n  checkWith,\n  options = {normalizeWhitespace: true},\n) {\n  checkNode(node, toHaveTextContent, this);\n\n  const textContent = options.normalizeWhitespace\n    ? normalize(node.textContent)\n    : node.textContent.replace(/\\u00a0/g, ' '); // Replace &nbsp; with normal spaces\n\n  const checkingWithEmptyString = textContent !== '' && checkWith === '';\n\n  return {\n    pass: !checkingWithEmptyString && matches(textContent, checkWith),\n    message: () => {\n      const to = this.isNot ? 'not to' : 'to';\n      return getMessage(\n        this,\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toHaveTextContent`,\n          'element',\n          '',\n        ),\n        checkingWithEmptyString\n          ? `Checking with empty string will always match, use .toBeEmptyDOMElement() instead`\n          : `Expected element ${to} have text content`,\n        checkWith,\n        'Received',\n        textContent,\n      )\n    },\n  }\n}\n\nfunction toHaveAccessibleDescription(\n  htmlElement,\n  expectedAccessibleDescription,\n) {\n  checkHtmlElement(htmlElement, toHaveAccessibleDescription, this);\n  const actualAccessibleDescription = domAccessibilityApi.computeAccessibleDescription(htmlElement);\n  const missingExpectedValue = arguments.length === 1;\n\n  let pass = false;\n  if (missingExpectedValue) {\n    // When called without an expected value we only want to validate that the element has an\n    // accessible description, whatever it may be.\n    pass = actualAccessibleDescription !== '';\n  } else {\n    pass =\n      expectedAccessibleDescription instanceof RegExp\n        ? expectedAccessibleDescription.test(actualAccessibleDescription)\n        : this.equals(\n            actualAccessibleDescription,\n            expectedAccessibleDescription,\n          );\n  }\n\n  return {\n    pass,\n\n    message: () => {\n      const to = this.isNot ? 'not to' : 'to';\n      return getMessage(\n        this,\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.${toHaveAccessibleDescription.name}`,\n          'element',\n          '',\n        ),\n        `Expected element ${to} have accessible description`,\n        expectedAccessibleDescription,\n        'Received',\n        actualAccessibleDescription,\n      )\n    },\n  }\n}\n\nconst ariaInvalidName = 'aria-invalid';\nconst validStates = ['false'];\n\n// See `aria-errormessage` spec at https://www.w3.org/TR/wai-aria-1.2/#aria-errormessage\nfunction toHaveAccessibleErrorMessage(\n  htmlElement,\n  expectedAccessibleErrorMessage,\n) {\n  checkHtmlElement(htmlElement, toHaveAccessibleErrorMessage, this);\n  const to = this.isNot ? 'not to' : 'to';\n  const method = this.isNot\n    ? '.not.toHaveAccessibleErrorMessage'\n    : '.toHaveAccessibleErrorMessage';\n\n  // Enforce Valid Id\n  const errormessageId = htmlElement.getAttribute('aria-errormessage');\n  const errormessageIdInvalid = !!errormessageId && /\\s+/.test(errormessageId);\n\n  if (errormessageIdInvalid) {\n    return {\n      pass: false,\n      message: () => {\n        return getMessage(\n          this,\n          this.utils.matcherHint(method, 'element'),\n          \"Expected element's `aria-errormessage` attribute to be empty or a single, valid ID\",\n          '',\n          'Received',\n          `aria-errormessage=\"${errormessageId}\"`,\n        )\n      },\n    }\n  }\n\n  // See `aria-invalid` spec at https://www.w3.org/TR/wai-aria-1.2/#aria-invalid\n  const ariaInvalidVal = htmlElement.getAttribute(ariaInvalidName);\n  const fieldValid =\n    !htmlElement.hasAttribute(ariaInvalidName) ||\n    validStates.includes(ariaInvalidVal);\n\n  // Enforce Valid `aria-invalid` Attribute\n  if (fieldValid) {\n    return {\n      pass: false,\n      message: () => {\n        return getMessage(\n          this,\n          this.utils.matcherHint(method, 'element'),\n          'Expected element to be marked as invalid with attribute',\n          `${ariaInvalidName}=\"${String(true)}\"`,\n          'Received',\n          htmlElement.hasAttribute('aria-invalid')\n            ? `${ariaInvalidName}=\"${htmlElement.getAttribute(ariaInvalidName)}`\n            : null,\n        )\n      },\n    }\n  }\n\n  const error = normalize(\n    htmlElement.ownerDocument.getElementById(errormessageId)?.textContent ?? '',\n  );\n\n  return {\n    pass:\n      expectedAccessibleErrorMessage === undefined\n        ? Boolean(error)\n        : expectedAccessibleErrorMessage instanceof RegExp\n        ? expectedAccessibleErrorMessage.test(error)\n        : this.equals(error, expectedAccessibleErrorMessage),\n\n    message: () => {\n      return getMessage(\n        this,\n        this.utils.matcherHint(method, 'element'),\n        `Expected element ${to} have accessible error message`,\n        expectedAccessibleErrorMessage ?? '',\n        'Received',\n        error,\n      )\n    },\n  }\n}\n\nconst elementRoleList = buildElementRoleList(ariaQuery.elementRoles);\n\nfunction toHaveRole(htmlElement, expectedRole) {\n  checkHtmlElement(htmlElement, toHaveRole, this);\n\n  const actualRoles = getExplicitOrImplicitRoles(htmlElement);\n  const pass = actualRoles.some(el => el === expectedRole);\n\n  return {\n    pass,\n\n    message: () => {\n      const to = this.isNot ? 'not to' : 'to';\n      return getMessage(\n        this,\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.${toHaveRole.name}`,\n          'element',\n          '',\n        ),\n        `Expected element ${to} have role`,\n        expectedRole,\n        'Received',\n        actualRoles.join(', '),\n      )\n    },\n  }\n}\n\nfunction getExplicitOrImplicitRoles(htmlElement) {\n  const hasExplicitRole = htmlElement.hasAttribute('role');\n\n  if (hasExplicitRole) {\n    const roleValue = htmlElement.getAttribute('role');\n\n    // Handle fallback roles, such as role=\"switch button\"\n    // testing-library gates this behind the `queryFallbacks` flag; it is\n    // unclear why, but it makes sense to support this pattern out of the box\n    // https://testing-library.com/docs/queries/byrole/#queryfallbacks\n    return roleValue.split(' ').filter(Boolean)\n  }\n\n  const implicitRoles = getImplicitAriaRoles(htmlElement);\n\n  return implicitRoles\n}\n\nfunction getImplicitAriaRoles(currentNode) {\n  for (const {match, roles} of elementRoleList) {\n    if (match(currentNode)) {\n      return [...roles]\n    }\n  }\n\n  /* istanbul ignore next */\n  return [] // this does not get reached in practice, since elements have at least a 'generic' role\n}\n\n/**\n * Transform the roles map (with required attributes and constraints) to a list\n * of roles. Each item in the list has functions to match an element against it.\n *\n * Essentially copied over from [dom-testing-library's\n * helpers](https://github.com/testing-library/dom-testing-library/blob/bd04cf95a1ed85a2238f7dfc1a77d5d16b4f59dc/src/role-helpers.js#L80)\n *\n * TODO: If we are truly just copying over stuff, would it make sense to move\n * this to a separate package?\n *\n * TODO: This technique relies on CSS selectors; are those consistently\n * available in all jest-dom environments? Why do other matchers in this package\n * not use them like this?\n */\nfunction buildElementRoleList(elementRolesMap) {\n  function makeElementSelector({name, attributes}) {\n    return `${name}${attributes\n      .map(({name: attributeName, value, constraints = []}) => {\n        const shouldNotExist = constraints.indexOf('undefined') !== -1;\n        if (shouldNotExist) {\n          return `:not([${attributeName}])`\n        } else if (value) {\n          return `[${attributeName}=\"${value}\"]`\n        } else {\n          return `[${attributeName}]`\n        }\n      })\n      .join('')}`\n  }\n\n  function getSelectorSpecificity({attributes = []}) {\n    return attributes.length\n  }\n\n  function bySelectorSpecificity(\n    {specificity: leftSpecificity},\n    {specificity: rightSpecificity},\n  ) {\n    return rightSpecificity - leftSpecificity\n  }\n\n  function match(element) {\n    let {attributes = []} = element;\n\n    // https://github.com/testing-library/dom-testing-library/issues/814\n    const typeTextIndex = attributes.findIndex(\n      attribute =>\n        attribute.value &&\n        attribute.name === 'type' &&\n        attribute.value === 'text',\n    );\n\n    if (typeTextIndex >= 0) {\n      // not using splice to not mutate the attributes array\n      attributes = [\n        ...attributes.slice(0, typeTextIndex),\n        ...attributes.slice(typeTextIndex + 1),\n      ];\n    }\n\n    const selector = makeElementSelector({...element, attributes});\n\n    return node => {\n      if (typeTextIndex >= 0 && node.type !== 'text') {\n        return false\n      }\n\n      return node.matches(selector)\n    }\n  }\n\n  let result = [];\n\n  for (const [element, roles] of elementRolesMap.entries()) {\n    result = [\n      ...result,\n      {\n        match: match(element),\n        roles: Array.from(roles),\n        specificity: getSelectorSpecificity(element),\n      },\n    ];\n  }\n\n  return result.sort(bySelectorSpecificity)\n}\n\nfunction toHaveAccessibleName(htmlElement, expectedAccessibleName) {\n  checkHtmlElement(htmlElement, toHaveAccessibleName, this);\n  const actualAccessibleName = domAccessibilityApi.computeAccessibleName(htmlElement);\n  const missingExpectedValue = arguments.length === 1;\n\n  let pass = false;\n  if (missingExpectedValue) {\n    // When called without an expected value we only want to validate that the element has an\n    // accessible name, whatever it may be.\n    pass = actualAccessibleName !== '';\n  } else {\n    pass =\n      expectedAccessibleName instanceof RegExp\n        ? expectedAccessibleName.test(actualAccessibleName)\n        : this.equals(actualAccessibleName, expectedAccessibleName);\n  }\n\n  return {\n    pass,\n\n    message: () => {\n      const to = this.isNot ? 'not to' : 'to';\n      return getMessage(\n        this,\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.${toHaveAccessibleName.name}`,\n          'element',\n          '',\n        ),\n        `Expected element ${to} have accessible name`,\n        expectedAccessibleName,\n        'Received',\n        actualAccessibleName,\n      )\n    },\n  }\n}\n\nfunction printAttribute(stringify, name, value) {\n  return value === undefined ? name : `${name}=${stringify(value)}`\n}\n\nfunction getAttributeComment(stringify, name, value) {\n  return value === undefined\n    ? `element.hasAttribute(${stringify(name)})`\n    : `element.getAttribute(${stringify(name)}) === ${stringify(value)}`\n}\n\nfunction toHaveAttribute(htmlElement, name, expectedValue) {\n  checkHtmlElement(htmlElement, toHaveAttribute, this);\n  const isExpectedValuePresent = expectedValue !== undefined;\n  const hasAttribute = htmlElement.hasAttribute(name);\n  const receivedValue = htmlElement.getAttribute(name);\n  return {\n    pass: isExpectedValuePresent\n      ? hasAttribute && this.equals(receivedValue, expectedValue)\n      : hasAttribute,\n    message: () => {\n      const to = this.isNot ? 'not to' : 'to';\n      const receivedAttribute = hasAttribute\n        ? printAttribute(this.utils.stringify, name, receivedValue)\n        : null;\n      const matcher = this.utils.matcherHint(\n        `${this.isNot ? '.not' : ''}.toHaveAttribute`,\n        'element',\n        this.utils.printExpected(name),\n        {\n          secondArgument: isExpectedValuePresent\n            ? this.utils.printExpected(expectedValue)\n            : undefined,\n          comment: getAttributeComment(\n            this.utils.stringify,\n            name,\n            expectedValue,\n          ),\n        },\n      );\n      return getMessage(\n        this,\n        matcher,\n        `Expected the element ${to} have attribute`,\n        printAttribute(this.utils.stringify, name, expectedValue),\n        'Received',\n        receivedAttribute,\n      )\n    },\n  }\n}\n\nfunction getExpectedClassNamesAndOptions(params) {\n  const lastParam = params.pop();\n  let expectedClassNames, options;\n\n  if (typeof lastParam === 'object' && !(lastParam instanceof RegExp)) {\n    expectedClassNames = params;\n    options = lastParam;\n  } else {\n    expectedClassNames = params.concat(lastParam);\n    options = {exact: false};\n  }\n  return {expectedClassNames, options}\n}\n\nfunction splitClassNames(str) {\n  if (!str) return []\n  return str.split(/\\s+/).filter(s => s.length > 0)\n}\n\nfunction isSubset$1(subset, superset) {\n  return subset.every(strOrRegexp =>\n    typeof strOrRegexp === 'string'\n      ? superset.includes(strOrRegexp)\n      : superset.some(className => strOrRegexp.test(className)),\n  )\n}\n\nfunction toHaveClass(htmlElement, ...params) {\n  checkHtmlElement(htmlElement, toHaveClass, this);\n  const {expectedClassNames, options} = getExpectedClassNamesAndOptions(params);\n\n  const received = splitClassNames(htmlElement.getAttribute('class'));\n  const expected = expectedClassNames.reduce(\n    (acc, className) =>\n      acc.concat(\n        typeof className === 'string' || !className\n          ? splitClassNames(className)\n          : className,\n      ),\n    [],\n  );\n\n  const hasRegExp = expected.some(className => className instanceof RegExp);\n  if (options.exact && hasRegExp) {\n    throw new Error('Exact option does not support RegExp expected class names')\n  }\n\n  if (options.exact) {\n    return {\n      pass: isSubset$1(expected, received) && expected.length === received.length,\n      message: () => {\n        const to = this.isNot ? 'not to' : 'to';\n        return getMessage(\n          this,\n          this.utils.matcherHint(\n            `${this.isNot ? '.not' : ''}.toHaveClass`,\n            'element',\n            this.utils.printExpected(expected.join(' ')),\n          ),\n          `Expected the element ${to} have EXACTLY defined classes`,\n          expected.join(' '),\n          'Received',\n          received.join(' '),\n        )\n      },\n    }\n  }\n\n  return expected.length > 0\n    ? {\n        pass: isSubset$1(expected, received),\n        message: () => {\n          const to = this.isNot ? 'not to' : 'to';\n          return getMessage(\n            this,\n            this.utils.matcherHint(\n              `${this.isNot ? '.not' : ''}.toHaveClass`,\n              'element',\n              this.utils.printExpected(expected.join(' ')),\n            ),\n            `Expected the element ${to} have class`,\n            expected.join(' '),\n            'Received',\n            received.join(' '),\n          )\n        },\n      }\n    : {\n        pass: this.isNot ? received.length > 0 : false,\n        message: () =>\n          this.isNot\n            ? getMessage(\n                this,\n                this.utils.matcherHint('.not.toHaveClass', 'element', ''),\n                'Expected the element to have classes',\n                '(none)',\n                'Received',\n                received.join(' '),\n              )\n            : [\n                this.utils.matcherHint(`.toHaveClass`, 'element'),\n                'At least one expected class must be provided.',\n              ].join('\\n'),\n      }\n}\n\nfunction getStyleDeclaration(document, css) {\n  const styles = {};\n\n  // The next block is necessary to normalize colors\n  const copy = document.createElement('div');\n  Object.keys(css).forEach(property => {\n    copy.style[property] = css[property];\n    styles[property] = copy.style[property];\n  });\n\n  return styles\n}\n\nfunction isSubset(styles, computedStyle) {\n  return (\n    !!Object.keys(styles).length &&\n    Object.entries(styles).every(([prop, value]) => {\n      const isCustomProperty = prop.startsWith('--');\n      const spellingVariants = [prop];\n      if (!isCustomProperty) spellingVariants.push(prop.toLowerCase());\n\n      return spellingVariants.some(\n        name =>\n          computedStyle[name] === value ||\n          computedStyle.getPropertyValue(name) === value,\n      )\n    })\n  )\n}\n\nfunction printoutStyles(styles) {\n  return Object.keys(styles)\n    .sort()\n    .map(prop => `${prop}: ${styles[prop]};`)\n    .join('\\n')\n}\n\n// Highlights only style rules that were expected but were not found in the\n// received computed styles\nfunction expectedDiff(diffFn, expected, computedStyles) {\n  const received = Array.from(computedStyles)\n    .filter(prop => expected[prop] !== undefined)\n    .reduce(\n      (obj, prop) =>\n        Object.assign(obj, {[prop]: computedStyles.getPropertyValue(prop)}),\n      {},\n    );\n  const diffOutput = diffFn(printoutStyles(expected), printoutStyles(received));\n  // Remove the \"+ Received\" annotation because this is a one-way diff\n  return diffOutput.replace(`${chalk.red('+ Received')}\\n`, '')\n}\n\nfunction toHaveStyle(htmlElement, css) {\n  checkHtmlElement(htmlElement, toHaveStyle, this);\n  const parsedCSS =\n    typeof css === 'object' ? css : parseCSS(css, toHaveStyle, this);\n  const {getComputedStyle} = htmlElement.ownerDocument.defaultView;\n\n  const expected = getStyleDeclaration(htmlElement.ownerDocument, parsedCSS);\n  const received = getComputedStyle(htmlElement);\n\n  return {\n    pass: isSubset(expected, received),\n    message: () => {\n      const matcher = `${this.isNot ? '.not' : ''}.toHaveStyle`;\n      return [\n        this.utils.matcherHint(matcher, 'element', ''),\n        expectedDiff(this.utils.diff, expected, received),\n      ].join('\\n\\n')\n    },\n  }\n}\n\nfunction toHaveFocus(element) {\n  checkHtmlElement(element, toHaveFocus, this);\n\n  return {\n    pass: element.ownerDocument.activeElement === element,\n    message: () => {\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toHaveFocus`,\n          'element',\n          '',\n        ),\n        '',\n        ...(this.isNot\n          ? [\n              'Received element is focused:',\n              `  ${this.utils.printReceived(element)}`,\n            ]\n          : [\n              'Expected element with focus:',\n              `  ${this.utils.printExpected(element)}`,\n              'Received element with focus:',\n              `  ${this.utils.printReceived(\n                element.ownerDocument.activeElement,\n              )}`,\n            ]),\n      ].join('\\n')\n    },\n  }\n}\n\n// Returns the combined value of several elements that have the same name\n// e.g. radio buttons or groups of checkboxes\nfunction getMultiElementValue(elements) {\n  const types = [...new Set(elements.map(element => element.type))];\n  if (types.length !== 1) {\n    throw new Error(\n      'Multiple form elements with the same name must be of the same type',\n    )\n  }\n  switch (types[0]) {\n    case 'radio': {\n      const theChosenOne = elements.find(radio => radio.checked);\n      return theChosenOne ? theChosenOne.value : undefined\n    }\n    case 'checkbox':\n      return elements\n        .filter(checkbox => checkbox.checked)\n        .map(checkbox => checkbox.value)\n    default:\n      // NOTE: Not even sure this is a valid use case, but just in case...\n      return elements.map(element => element.value)\n  }\n}\n\nfunction getFormValue(container, name) {\n  const elements = [...container.querySelectorAll(`[name=\"${escape(name)}\"]`)];\n  /* istanbul ignore if */\n  if (elements.length === 0) {\n    return undefined // shouldn't happen, but just in case\n  }\n  switch (elements.length) {\n    case 1:\n      return getSingleElementValue(elements[0])\n    default:\n      return getMultiElementValue(elements)\n  }\n}\n\n// Strips the `[]` suffix off a form value name\nfunction getPureName(name) {\n  return /\\[\\]$/.test(name) ? name.slice(0, -2) : name\n}\n\nfunction getAllFormValues(container) {\n  const names = Array.from(container.elements).map(element => element.name);\n  return names.reduce(\n    (obj, name) => ({\n      ...obj,\n      [getPureName(name)]: getFormValue(container, name),\n    }),\n    {},\n  )\n}\n\nfunction toHaveFormValues(formElement, expectedValues) {\n  checkHtmlElement(formElement, toHaveFormValues, this);\n  if (!formElement.elements) {\n    // TODO: Change condition to use instanceof against the appropriate element classes instead\n    throw new Error('toHaveFormValues must be called on a form or a fieldset')\n  }\n  const formValues = getAllFormValues(formElement);\n  return {\n    pass: Object.entries(expectedValues).every(([name, expectedValue]) =>\n      isEqualWith(formValues[name], expectedValue, compareArraysAsSet),\n    ),\n    message: () => {\n      const to = this.isNot ? 'not to' : 'to';\n      const matcher = `${this.isNot ? '.not' : ''}.toHaveFormValues`;\n      const commonKeyValues = Object.keys(formValues)\n        .filter(key => expectedValues.hasOwnProperty(key))\n        .reduce((obj, key) => ({...obj, [key]: formValues[key]}), {});\n      return [\n        this.utils.matcherHint(matcher, 'element', ''),\n        `Expected the element ${to} have form values`,\n        this.utils.diff(expectedValues, commonKeyValues),\n      ].join('\\n\\n')\n    },\n  }\n}\n\nfunction isStyleVisible(element) {\n  const {getComputedStyle} = element.ownerDocument.defaultView;\n\n  const {display, visibility, opacity} = getComputedStyle(element);\n  return (\n    display !== 'none' &&\n    visibility !== 'hidden' &&\n    visibility !== 'collapse' &&\n    opacity !== '0' &&\n    opacity !== 0\n  )\n}\n\nfunction isAttributeVisible(element, previousElement) {\n  let detailsVisibility;\n\n  if (previousElement) {\n    detailsVisibility =\n      element.nodeName === 'DETAILS' && previousElement.nodeName !== 'SUMMARY'\n        ? element.hasAttribute('open')\n        : true;\n  } else {\n    detailsVisibility =\n      element.nodeName === 'DETAILS' ? element.hasAttribute('open') : true;\n  }\n\n  return !element.hasAttribute('hidden') && detailsVisibility\n}\n\nfunction isElementVisible(element, previousElement) {\n  return (\n    isStyleVisible(element) &&\n    isAttributeVisible(element, previousElement) &&\n    (!element.parentElement || isElementVisible(element.parentElement, element))\n  )\n}\n\nfunction toBeVisible(element) {\n  checkHtmlElement(element, toBeVisible, this);\n  const isInDocument =\n    element.ownerDocument === element.getRootNode({composed: true});\n  const isVisible = isInDocument && isElementVisible(element);\n  return {\n    pass: isVisible,\n    message: () => {\n      const is = isVisible ? 'is' : 'is not';\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeVisible`,\n          'element',\n          '',\n        ),\n        '',\n        `Received element ${is} visible${\n          isInDocument ? '' : ' (element is not in the document)'\n        }:`,\n        `  ${this.utils.printReceived(element.cloneNode(false))}`,\n      ].join('\\n')\n    },\n  }\n}\n\n// form elements that support 'disabled'\nconst FORM_TAGS$2 = [\n  'fieldset',\n  'input',\n  'select',\n  'optgroup',\n  'option',\n  'button',\n  'textarea',\n];\n\n/*\n * According to specification:\n * If <fieldset> is disabled, the form controls that are its descendants,\n * except descendants of its first optional <legend> element, are disabled\n *\n * https://html.spec.whatwg.org/multipage/form-elements.html#concept-fieldset-disabled\n *\n * This method tests whether element is first legend child of fieldset parent\n */\nfunction isFirstLegendChildOfFieldset(element, parent) {\n  return (\n    getTag(element) === 'legend' &&\n    getTag(parent) === 'fieldset' &&\n    element.isSameNode(\n      Array.from(parent.children).find(child => getTag(child) === 'legend'),\n    )\n  )\n}\n\nfunction isElementDisabledByParent(element, parent) {\n  return (\n    isElementDisabled(parent) && !isFirstLegendChildOfFieldset(element, parent)\n  )\n}\n\nfunction isCustomElement(tag) {\n  return tag.includes('-')\n}\n\n/*\n * Only certain form elements and custom elements can actually be disabled:\n * https://html.spec.whatwg.org/multipage/semantics-other.html#disabled-elements\n */\nfunction canElementBeDisabled(element) {\n  const tag = getTag(element);\n  return FORM_TAGS$2.includes(tag) || isCustomElement(tag)\n}\n\nfunction isElementDisabled(element) {\n  return canElementBeDisabled(element) && element.hasAttribute('disabled')\n}\n\nfunction isAncestorDisabled(element) {\n  const parent = element.parentElement;\n  return (\n    Boolean(parent) &&\n    (isElementDisabledByParent(element, parent) || isAncestorDisabled(parent))\n  )\n}\n\nfunction isElementOrAncestorDisabled(element) {\n  return (\n    canElementBeDisabled(element) &&\n    (isElementDisabled(element) || isAncestorDisabled(element))\n  )\n}\n\nfunction toBeDisabled(element) {\n  checkHtmlElement(element, toBeDisabled, this);\n\n  const isDisabled = isElementOrAncestorDisabled(element);\n\n  return {\n    pass: isDisabled,\n    message: () => {\n      const is = isDisabled ? 'is' : 'is not';\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeDisabled`,\n          'element',\n          '',\n        ),\n        '',\n        `Received element ${is} disabled:`,\n        `  ${this.utils.printReceived(element.cloneNode(false))}`,\n      ].join('\\n')\n    },\n  }\n}\n\nfunction toBeEnabled(element) {\n  checkHtmlElement(element, toBeEnabled, this);\n\n  const isEnabled = !isElementOrAncestorDisabled(element);\n\n  return {\n    pass: isEnabled,\n    message: () => {\n      const is = isEnabled ? 'is' : 'is not';\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeEnabled`,\n          'element',\n          '',\n        ),\n        '',\n        `Received element ${is} enabled:`,\n        `  ${this.utils.printReceived(element.cloneNode(false))}`,\n      ].join('\\n')\n    },\n  }\n}\n\n// form elements that support 'required'\nconst FORM_TAGS$1 = ['select', 'textarea'];\n\nconst ARIA_FORM_TAGS = ['input', 'select', 'textarea'];\n\nconst UNSUPPORTED_INPUT_TYPES = [\n  'color',\n  'hidden',\n  'range',\n  'submit',\n  'image',\n  'reset',\n];\n\nconst SUPPORTED_ARIA_ROLES = [\n  'checkbox',\n  'combobox',\n  'gridcell',\n  'listbox',\n  'radiogroup',\n  'spinbutton',\n  'textbox',\n  'tree',\n];\n\nfunction isRequiredOnFormTagsExceptInput(element) {\n  return FORM_TAGS$1.includes(getTag(element)) && element.hasAttribute('required')\n}\n\nfunction isRequiredOnSupportedInput(element) {\n  return (\n    getTag(element) === 'input' &&\n    element.hasAttribute('required') &&\n    ((element.hasAttribute('type') &&\n      !UNSUPPORTED_INPUT_TYPES.includes(element.getAttribute('type'))) ||\n      !element.hasAttribute('type'))\n  )\n}\n\nfunction isElementRequiredByARIA(element) {\n  return (\n    element.hasAttribute('aria-required') &&\n    element.getAttribute('aria-required') === 'true' &&\n    (ARIA_FORM_TAGS.includes(getTag(element)) ||\n      (element.hasAttribute('role') &&\n        SUPPORTED_ARIA_ROLES.includes(element.getAttribute('role'))))\n  )\n}\n\nfunction toBeRequired(element) {\n  checkHtmlElement(element, toBeRequired, this);\n\n  const isRequired =\n    isRequiredOnFormTagsExceptInput(element) ||\n    isRequiredOnSupportedInput(element) ||\n    isElementRequiredByARIA(element);\n\n  return {\n    pass: isRequired,\n    message: () => {\n      const is = isRequired ? 'is' : 'is not';\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeRequired`,\n          'element',\n          '',\n        ),\n        '',\n        `Received element ${is} required:`,\n        `  ${this.utils.printReceived(element.cloneNode(false))}`,\n      ].join('\\n')\n    },\n  }\n}\n\nconst FORM_TAGS = ['form', 'input', 'select', 'textarea'];\n\nfunction isElementHavingAriaInvalid(element) {\n  return (\n    element.hasAttribute('aria-invalid') &&\n    element.getAttribute('aria-invalid') !== 'false'\n  )\n}\n\nfunction isSupportsValidityMethod(element) {\n  return FORM_TAGS.includes(getTag(element))\n}\n\nfunction isElementInvalid(element) {\n  const isHaveAriaInvalid = isElementHavingAriaInvalid(element);\n  if (isSupportsValidityMethod(element)) {\n    return isHaveAriaInvalid || !element.checkValidity()\n  } else {\n    return isHaveAriaInvalid\n  }\n}\n\nfunction toBeInvalid(element) {\n  checkHtmlElement(element, toBeInvalid, this);\n\n  const isInvalid = isElementInvalid(element);\n\n  return {\n    pass: isInvalid,\n    message: () => {\n      const is = isInvalid ? 'is' : 'is not';\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeInvalid`,\n          'element',\n          '',\n        ),\n        '',\n        `Received element ${is} currently invalid:`,\n        `  ${this.utils.printReceived(element.cloneNode(false))}`,\n      ].join('\\n')\n    },\n  }\n}\n\nfunction toBeValid(element) {\n  checkHtmlElement(element, toBeValid, this);\n\n  const isValid = !isElementInvalid(element);\n\n  return {\n    pass: isValid,\n    message: () => {\n      const is = isValid ? 'is' : 'is not';\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeValid`,\n          'element',\n          '',\n        ),\n        '',\n        `Received element ${is} currently valid:`,\n        `  ${this.utils.printReceived(element.cloneNode(false))}`,\n      ].join('\\n')\n    },\n  }\n}\n\nfunction toHaveValue(htmlElement, expectedValue) {\n  checkHtmlElement(htmlElement, toHaveValue, this);\n\n  if (\n    htmlElement.tagName.toLowerCase() === 'input' &&\n    ['checkbox', 'radio'].includes(htmlElement.type)\n  ) {\n    throw new Error(\n      'input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead',\n    )\n  }\n\n  const receivedValue = getSingleElementValue(htmlElement);\n  const expectsValue = expectedValue !== undefined;\n\n  let expectedTypedValue = expectedValue;\n  let receivedTypedValue = receivedValue;\n  if (expectedValue == receivedValue && expectedValue !== receivedValue) {\n    expectedTypedValue = `${expectedValue} (${typeof expectedValue})`;\n    receivedTypedValue = `${receivedValue} (${typeof receivedValue})`;\n  }\n\n  return {\n    pass: expectsValue\n      ? isEqualWith(receivedValue, expectedValue, compareArraysAsSet)\n      : Boolean(receivedValue),\n    message: () => {\n      const to = this.isNot ? 'not to' : 'to';\n      const matcher = this.utils.matcherHint(\n        `${this.isNot ? '.not' : ''}.toHaveValue`,\n        'element',\n        expectedValue,\n      );\n      return getMessage(\n        this,\n        matcher,\n        `Expected the element ${to} have value`,\n        expectsValue ? expectedTypedValue : '(any)',\n        'Received',\n        receivedTypedValue,\n      )\n    },\n  }\n}\n\nfunction toHaveDisplayValue(htmlElement, expectedValue) {\n  checkHtmlElement(htmlElement, toHaveDisplayValue, this);\n  const tagName = htmlElement.tagName.toLowerCase();\n\n  if (!['select', 'input', 'textarea'].includes(tagName)) {\n    throw new Error(\n      '.toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead.',\n    )\n  }\n\n  if (tagName === 'input' && ['radio', 'checkbox'].includes(htmlElement.type)) {\n    throw new Error(\n      `.toHaveDisplayValue() currently does not support input[type=\"${htmlElement.type}\"], try with another matcher instead.`,\n    )\n  }\n\n  const values = getValues(tagName, htmlElement);\n  const expectedValues = getExpectedValues(expectedValue);\n  const numberOfMatchesWithValues = expectedValues.filter(expected =>\n    values.some(value =>\n      expected instanceof RegExp\n        ? expected.test(value)\n        : this.equals(value, String(expected)),\n    ),\n  ).length;\n\n  const matchedWithAllValues = numberOfMatchesWithValues === values.length;\n  const matchedWithAllExpectedValues =\n    numberOfMatchesWithValues === expectedValues.length;\n\n  return {\n    pass: matchedWithAllValues && matchedWithAllExpectedValues,\n    message: () =>\n      getMessage(\n        this,\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toHaveDisplayValue`,\n          'element',\n          '',\n        ),\n        `Expected element ${this.isNot ? 'not ' : ''}to have display value`,\n        expectedValue,\n        'Received',\n        values,\n      ),\n  }\n}\n\nfunction getValues(tagName, htmlElement) {\n  return tagName === 'select'\n    ? Array.from(htmlElement)\n        .filter(option => option.selected)\n        .map(option => option.textContent)\n    : [htmlElement.value]\n}\n\nfunction getExpectedValues(expectedValue) {\n  return expectedValue instanceof Array ? expectedValue : [expectedValue]\n}\n\nfunction toBeChecked(element) {\n  checkHtmlElement(element, toBeChecked, this);\n\n  const isValidInput = () => {\n    return (\n      element.tagName.toLowerCase() === 'input' &&\n      ['checkbox', 'radio'].includes(element.type)\n    )\n  };\n\n  const isValidAriaElement = () => {\n    return (\n      roleSupportsChecked(element.getAttribute('role')) &&\n      ['true', 'false'].includes(element.getAttribute('aria-checked'))\n    )\n  };\n\n  if (!isValidInput() && !isValidAriaElement()) {\n    return {\n      pass: false,\n      message: () =>\n        `only inputs with type=\"checkbox\" or type=\"radio\" or elements with ${supportedRolesSentence()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`,\n    }\n  }\n\n  const isChecked = () => {\n    if (isValidInput()) return element.checked\n    return element.getAttribute('aria-checked') === 'true'\n  };\n\n  return {\n    pass: isChecked(),\n    message: () => {\n      const is = isChecked() ? 'is' : 'is not';\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBeChecked`,\n          'element',\n          '',\n        ),\n        '',\n        `Received element ${is} checked:`,\n        `  ${this.utils.printReceived(element.cloneNode(false))}`,\n      ].join('\\n')\n    },\n  }\n}\n\nfunction supportedRolesSentence() {\n  return toSentence(\n    supportedRoles().map(role => `role=\"${role}\"`),\n    {lastWordConnector: ' or '},\n  )\n}\n\nfunction supportedRoles() {\n  return ariaQuery.roles.keys().filter(roleSupportsChecked)\n}\n\nfunction roleSupportsChecked(role) {\n  return ariaQuery.roles.get(role)?.props['aria-checked'] !== undefined\n}\n\nfunction toBePartiallyChecked(element) {\n  checkHtmlElement(element, toBePartiallyChecked, this);\n\n  const isValidInput = () => {\n    return (\n      element.tagName.toLowerCase() === 'input' && element.type === 'checkbox'\n    )\n  };\n\n  const isValidAriaElement = () => {\n    return element.getAttribute('role') === 'checkbox'\n  };\n\n  if (!isValidInput() && !isValidAriaElement()) {\n    return {\n      pass: false,\n      message: () =>\n        'only inputs with type=\"checkbox\" or elements with role=\"checkbox\" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead',\n    }\n  }\n\n  const isPartiallyChecked = () => {\n    const isAriaMixed = element.getAttribute('aria-checked') === 'mixed';\n\n    if (isValidInput()) {\n      return element.indeterminate || isAriaMixed\n    }\n\n    return isAriaMixed\n  };\n\n  return {\n    pass: isPartiallyChecked(),\n    message: () => {\n      const is = isPartiallyChecked() ? 'is' : 'is not';\n      return [\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toBePartiallyChecked`,\n          'element',\n          '',\n        ),\n        '',\n        `Received element ${is} partially checked:`,\n        `  ${this.utils.printReceived(element.cloneNode(false))}`,\n      ].join('\\n')\n    },\n  }\n}\n\n// See algoritm: https://www.w3.org/TR/accname-1.1/#mapping_additional_nd_description\nfunction toHaveDescription(htmlElement, checkWith) {\n  deprecate(\n    'toHaveDescription',\n    'Please use toHaveAccessibleDescription.',\n  );\n\n  checkHtmlElement(htmlElement, toHaveDescription, this);\n\n  const expectsDescription = checkWith !== undefined;\n\n  const descriptionIDRaw = htmlElement.getAttribute('aria-describedby') || '';\n  const descriptionIDs = descriptionIDRaw.split(/\\s+/).filter(Boolean);\n  let description = '';\n  if (descriptionIDs.length > 0) {\n    const document = htmlElement.ownerDocument;\n    const descriptionEls = descriptionIDs\n      .map(descriptionID => document.getElementById(descriptionID))\n      .filter(Boolean);\n    description = normalize(descriptionEls.map(el => el.textContent).join(' '));\n  }\n\n  return {\n    pass: expectsDescription\n      ? checkWith instanceof RegExp\n        ? checkWith.test(description)\n        : this.equals(description, checkWith)\n      : Boolean(description),\n    message: () => {\n      const to = this.isNot ? 'not to' : 'to';\n      return getMessage(\n        this,\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toHaveDescription`,\n          'element',\n          '',\n        ),\n        `Expected the element ${to} have description`,\n        this.utils.printExpected(checkWith),\n        'Received',\n        this.utils.printReceived(description),\n      )\n    },\n  }\n}\n\n// See aria-errormessage spec https://www.w3.org/TR/wai-aria-1.2/#aria-errormessage\nfunction toHaveErrorMessage(htmlElement, checkWith) {\n  deprecate('toHaveErrorMessage', 'Please use toHaveAccessibleErrorMessage.');\n  checkHtmlElement(htmlElement, toHaveErrorMessage, this);\n\n  if (\n    !htmlElement.hasAttribute('aria-invalid') ||\n    htmlElement.getAttribute('aria-invalid') === 'false'\n  ) {\n    const not = this.isNot ? '.not' : '';\n\n    return {\n      pass: false,\n      message: () => {\n        return getMessage(\n          this,\n          this.utils.matcherHint(`${not}.toHaveErrorMessage`, 'element', ''),\n          `Expected the element to have invalid state indicated by`,\n          'aria-invalid=\"true\"',\n          'Received',\n          htmlElement.hasAttribute('aria-invalid')\n            ? `aria-invalid=\"${htmlElement.getAttribute('aria-invalid')}\"`\n            : this.utils.printReceived(''),\n        )\n      },\n    }\n  }\n\n  const expectsErrorMessage = checkWith !== undefined;\n\n  const errormessageIDRaw = htmlElement.getAttribute('aria-errormessage') || '';\n  const errormessageIDs = errormessageIDRaw.split(/\\s+/).filter(Boolean);\n\n  let errormessage = '';\n  if (errormessageIDs.length > 0) {\n    const document = htmlElement.ownerDocument;\n\n    const errormessageEls = errormessageIDs\n      .map(errormessageID => document.getElementById(errormessageID))\n      .filter(Boolean);\n\n    errormessage = normalize(\n      errormessageEls.map(el => el.textContent).join(' '),\n    );\n  }\n\n  return {\n    pass: expectsErrorMessage\n      ? checkWith instanceof RegExp\n        ? checkWith.test(errormessage)\n        : this.equals(errormessage, checkWith)\n      : Boolean(errormessage),\n    message: () => {\n      const to = this.isNot ? 'not to' : 'to';\n      return getMessage(\n        this,\n        this.utils.matcherHint(\n          `${this.isNot ? '.not' : ''}.toHaveErrorMessage`,\n          'element',\n          '',\n        ),\n        `Expected the element ${to} have error message`,\n        this.utils.printExpected(checkWith),\n        'Received',\n        this.utils.printReceived(errormessage),\n      )\n    },\n  }\n}\n\n/**\n * Returns the selection from the element.\n * \n * @param element {HTMLElement} The element to get the selection from.\n * @returns {String} The selection.\n */\nfunction getSelection(element) {\n  const selection = element.ownerDocument.getSelection();\n\n  if (['input', 'textarea'].includes(element.tagName.toLowerCase())) {\n    if (['radio', 'checkbox'].includes(element.type)) return ''\n    return element.value\n      .toString()\n      .substring(element.selectionStart, element.selectionEnd)\n  }\n\n  if (selection.anchorNode === null || selection.focusNode === null) {\n    // No selection\n    return ''\n  }\n\n  const originalRange = selection.getRangeAt(0);\n  const temporaryRange = element.ownerDocument.createRange();\n\n  if (selection.containsNode(element, false)) {\n    // Whole element is inside selection\n    temporaryRange.selectNodeContents(element);\n    selection.removeAllRanges();\n    selection.addRange(temporaryRange);\n  } else if (\n    element.contains(selection.anchorNode) &&\n    element.contains(selection.focusNode)\n  ) ; else {\n    // Element is partially selected\n    const selectionStartsWithinElement =\n      element === originalRange.startContainer ||\n      element.contains(originalRange.startContainer);\n    const selectionEndsWithinElement =\n      element === originalRange.endContainer ||\n      element.contains(originalRange.endContainer);\n    selection.removeAllRanges();\n\n    if (selectionStartsWithinElement || selectionEndsWithinElement) {\n      temporaryRange.selectNodeContents(element);\n\n      if (selectionStartsWithinElement) {\n        temporaryRange.setStart(\n          originalRange.startContainer,\n          originalRange.startOffset,\n        );\n      }\n      if (selectionEndsWithinElement) {\n        temporaryRange.setEnd(\n          originalRange.endContainer,\n          originalRange.endOffset,\n        );\n      }\n\n      selection.addRange(temporaryRange);\n    }\n  }\n\n  const result = selection.toString();\n\n  selection.removeAllRanges();\n  selection.addRange(originalRange);\n\n  return result\n}\n\n/**\n * Checks if the element has the string selected.\n *\n * @param htmlElement {HTMLElement} The html element to check the selection for.\n * @param expectedSelection {String} The selection as a string.\n */\nfunction toHaveSelection(htmlElement, expectedSelection) {\n  checkHtmlElement(htmlElement, toHaveSelection, this);\n\n  const expectsSelection = expectedSelection !== undefined;\n\n  if (expectsSelection && typeof expectedSelection !== 'string') {\n    throw new Error(`expected selection must be a string or undefined`)\n  }\n\n  const receivedSelection = getSelection(htmlElement);\n\n  return {\n    pass: expectsSelection\n      ? isEqualWith(receivedSelection, expectedSelection, compareArraysAsSet)\n      : Boolean(receivedSelection),\n    message: () => {\n      const to = this.isNot ? 'not to' : 'to';\n      const matcher = this.utils.matcherHint(\n        `${this.isNot ? '.not' : ''}.toHaveSelection`,\n        'element',\n        expectedSelection,\n      );\n      return getMessage(\n        this,\n        matcher,\n        `Expected the element ${to} have selection`,\n        expectsSelection ? expectedSelection : '(any)',\n        'Received',\n        receivedSelection,\n      )\n    },\n  }\n}\n\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toBeChecked: toBeChecked,\n  toBeDisabled: toBeDisabled,\n  toBeEmpty: toBeEmpty,\n  toBeEmptyDOMElement: toBeEmptyDOMElement,\n  toBeEnabled: toBeEnabled,\n  toBeInTheDOM: toBeInTheDOM,\n  toBeInTheDocument: toBeInTheDocument,\n  toBeInvalid: toBeInvalid,\n  toBePartiallyChecked: toBePartiallyChecked,\n  toBeRequired: toBeRequired,\n  toBeValid: toBeValid,\n  toBeVisible: toBeVisible,\n  toContainElement: toContainElement,\n  toContainHTML: toContainHTML,\n  toHaveAccessibleDescription: toHaveAccessibleDescription,\n  toHaveAccessibleErrorMessage: toHaveAccessibleErrorMessage,\n  toHaveAccessibleName: toHaveAccessibleName,\n  toHaveAttribute: toHaveAttribute,\n  toHaveClass: toHaveClass,\n  toHaveDescription: toHaveDescription,\n  toHaveDisplayValue: toHaveDisplayValue,\n  toHaveErrorMessage: toHaveErrorMessage,\n  toHaveFocus: toHaveFocus,\n  toHaveFormValues: toHaveFormValues,\n  toHaveRole: toHaveRole,\n  toHaveSelection: toHaveSelection,\n  toHaveStyle: toHaveStyle,\n  toHaveTextContent: toHaveTextContent,\n  toHaveValue: toHaveValue\n});\n\nexports.extensions = extensions;\nexports.toBeChecked = toBeChecked;\nexports.toBeDisabled = toBeDisabled;\nexports.toBeEmpty = toBeEmpty;\nexports.toBeEmptyDOMElement = toBeEmptyDOMElement;\nexports.toBeEnabled = toBeEnabled;\nexports.toBeInTheDOM = toBeInTheDOM;\nexports.toBeInTheDocument = toBeInTheDocument;\nexports.toBeInvalid = toBeInvalid;\nexports.toBePartiallyChecked = toBePartiallyChecked;\nexports.toBeRequired = toBeRequired;\nexports.toBeValid = toBeValid;\nexports.toBeVisible = toBeVisible;\nexports.toContainElement = toContainElement;\nexports.toContainHTML = toContainHTML;\nexports.toHaveAccessibleDescription = toHaveAccessibleDescription;\nexports.toHaveAccessibleErrorMessage = toHaveAccessibleErrorMessage;\nexports.toHaveAccessibleName = toHaveAccessibleName;\nexports.toHaveAttribute = toHaveAttribute;\nexports.toHaveClass = toHaveClass;\nexports.toHaveDescription = toHaveDescription;\nexports.toHaveDisplayValue = toHaveDisplayValue;\nexports.toHaveErrorMessage = toHaveErrorMessage;\nexports.toHaveFocus = toHaveFocus;\nexports.toHaveFormValues = toHaveFormValues;\nexports.toHaveRole = toHaveRole;\nexports.toHaveSelection = toHaveSelection;\nexports.toHaveStyle = toHaveStyle;\nexports.toHaveTextContent = toHaveTextContent;\nexports.toHaveValue = toHaveValue;\n"],"names":["redent","require","cssTools","domAccessibilityApi","ariaQuery","chalk","isEqualWith","escape","GenericTypeError","Error","constructor","expectedString","received","matcherFn","context","captureStackTrace","withType","utils","printWithType","printReceived","e","message","matcherHint","isNot","name","RECEIVED_COLOR","join","HtmlElementTypeError","args","NodeTypeError","checkHasWindow","htmlElement","ErrorClass","ownerDocument","defaultView","checkNode","node","window","Node","checkHtmlElement","HTMLElement","SVGElement","InvalidCSSError","css","parseCSS","ast","parse","silent","stylesheet","parsingErrors","length","reason","line","parsedRules","rules","declarations","filter","d","type","reduce","obj","property","value","Object","assign","display","stringify","getMessage","matcher","expectedLabel","expectedValue","receivedLabel","receivedValue","EXPECTED_COLOR","matches","textToMatch","RegExp","test","includes","String","deprecate","replacementText","console","warn","normalize","text","replace","trim","getTag","element","tagName","toLowerCase","getSelectValue","multiple","options","selectedOptions","option","selected","map","opt","undefined","getInputValue","inputElement","Number","checked","rolesSupportingValues","getAccessibleValue","getAttribute","getSingleElementValue","toSentence","array","wordConnector","lastWordConnector","slice","compareArraysAsSet","arr1","arr2","Array","isArray","Set","every","v","has","toBeInTheDOM","container","pass","contains","cloneNode","toBeInTheDocument","getRootNode","composed","errorFound","errorNotFound","toBeEmpty","innerHTML","toBeEmptyDOMElement","isEmptyElement","nonCommentChildNodes","childNodes","nodeType","toContainElement","getNormalizedHtml","htmlText","div","createElement","toContainHTML","outerHTML","toHaveTextContent","checkWith","normalizeWhitespace","textContent","checkingWithEmptyString","to","toHaveAccessibleDescription","expectedAccessibleDescription","actualAccessibleDescription","computeAccessibleDescription","missingExpectedValue","arguments","equals","ariaInvalidName","validStates","toHaveAccessibleErrorMessage","expectedAccessibleErrorMessage","method","errormessageId","errormessageIdInvalid","ariaInvalidVal","fieldValid","hasAttribute","error","getElementById","Boolean","elementRoleList","buildElementRoleList","elementRoles","toHaveRole","expectedRole","actualRoles","getExplicitOrImplicitRoles","some","el","hasExplicitRole","roleValue","split","implicitRoles","getImplicitAriaRoles","currentNode","match","roles","elementRolesMap","makeElementSelector","attributes","attributeName","constraints","shouldNotExist","indexOf","getSelectorSpecificity","bySelectorSpecificity","specificity","leftSpecificity","rightSpecificity","typeTextIndex","findIndex","attribute","selector","result","entries","from","sort","toHaveAccessibleName","expectedAccessibleName","actualAccessibleName","computeAccessibleName","printAttribute","getAttributeComment","toHaveAttribute","isExpectedValuePresent","receivedAttribute","printExpected","secondArgument","comment","getExpectedClassNamesAndOptions","params","lastParam","pop","expectedClassNames","concat","exact","splitClassNames","str","s","isSubset$1","subset","superset","strOrRegexp","className","toHaveClass","expected","acc","hasRegExp","getStyleDeclaration","document","styles","copy","keys","forEach","style","isSubset","computedStyle","prop","isCustomProperty","startsWith","spellingVariants","push","getPropertyValue","printoutStyles","expectedDiff","diffFn","computedStyles","diffOutput","red","toHaveStyle","parsedCSS","getComputedStyle","diff","toHaveFocus","activeElement","getMultiElementValue","elements","types","theChosenOne","find","radio","checkbox","getFormValue","querySelectorAll","getPureName","getAllFormValues","names","toHaveFormValues","formElement","expectedValues","formValues","commonKeyValues","key","hasOwnProperty","isStyleVisible","visibility","opacity","isAttributeVisible","previousElement","detailsVisibility","nodeName","isElementVisible","parentElement","toBeVisible","isInDocument","isVisible","is","FORM_TAGS$2","isFirstLegendChildOfFieldset","parent","isSameNode","children","child","isElementDisabledByParent","isElementDisabled","isCustomElement","tag","canElementBeDisabled","isAncestorDisabled","isElementOrAncestorDisabled","toBeDisabled","isDisabled","toBeEnabled","isEnabled","FORM_TAGS$1","ARIA_FORM_TAGS","UNSUPPORTED_INPUT_TYPES","SUPPORTED_ARIA_ROLES","isRequiredOnFormTagsExceptInput","isRequiredOnSupportedInput","isElementRequiredByARIA","toBeRequired","isRequired","FORM_TAGS","isElementHavingAriaInvalid","isSupportsValidityMethod","isElementInvalid","isHaveAriaInvalid","checkValidity","toBeInvalid","isInvalid","toBeValid","isValid","toHaveValue","expectsValue","expectedTypedValue","receivedTypedValue","toHaveDisplayValue","values","getValues","getExpectedValues","numberOfMatchesWithValues","matchedWithAllValues","matchedWithAllExpectedValues","toBeChecked","isValidInput","isValidAriaElement","roleSupportsChecked","supportedRolesSentence","isChecked","supportedRoles","role","get","props","toBePartiallyChecked","isPartiallyChecked","isAriaMixed","indeterminate","toHaveDescription","expectsDescription","descriptionIDRaw","descriptionIDs","description","descriptionEls","descriptionID","toHaveErrorMessage","not","expectsErrorMessage","errormessageIDRaw","errormessageIDs","errormessage","errormessageEls","errormessageID","getSelection","selection","toString","substring","selectionStart","selectionEnd","anchorNode","focusNode","originalRange","getRangeAt","temporaryRange","createRange","containsNode","selectNodeContents","removeAllRanges","addRange","selectionStartsWithinElement","startContainer","selectionEndsWithinElement","endContainer","setStart","startOffset","setEnd","endOffset","toHaveSelection","expectedSelection","expectsSelection","receivedSelection","extensions","freeze","__proto__","exports"],"mappings":"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"}