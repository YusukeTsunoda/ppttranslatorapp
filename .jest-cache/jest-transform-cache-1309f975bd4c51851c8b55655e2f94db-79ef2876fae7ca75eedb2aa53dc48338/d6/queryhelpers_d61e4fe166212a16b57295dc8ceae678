a0360b008fe96f70ab8f12fea9d512bb
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildQueries = buildQueries;
exports.getElementError = getElementError;
exports.getMultipleElementsFoundError = getMultipleElementsFoundError;
exports.makeFindQuery = makeFindQuery;
exports.makeGetAllQuery = makeGetAllQuery;
exports.makeSingleQuery = makeSingleQuery;
exports.queryAllByAttribute = queryAllByAttribute;
exports.queryByAttribute = queryByAttribute;
exports.wrapSingleQueryWithSuggestion = exports.wrapAllByQueryWithSuggestion = void 0;
var _suggestions = require("./suggestions");
var _matches = require("./matches");
var _waitFor = require("./wait-for");
var _config = require("./config");
function getElementError(message, container) {
    return (0, _config.getConfig)().getElementError(message, container);
}
function getMultipleElementsFoundError(message, container) {
    return getElementError(`${message}\n\n(If this is intentional, then use the \`*AllBy*\` variant of the query (like \`queryAllByText\`, \`getAllByText\`, or \`findAllByText\`)).`, container);
}
function queryAllByAttribute(attribute, container, text, { exact = true, collapseWhitespace, trim, normalizer } = {}) {
    const matcher = exact ? _matches.matches : _matches.fuzzyMatches;
    const matchNormalizer = (0, _matches.makeNormalizer)({
        collapseWhitespace,
        trim,
        normalizer
    });
    return Array.from(container.querySelectorAll(`[${attribute}]`)).filter((node)=>matcher(node.getAttribute(attribute), node, text, matchNormalizer));
}
function queryByAttribute(attribute, container, text, options) {
    const els = queryAllByAttribute(attribute, container, text, options);
    if (els.length > 1) {
        throw getMultipleElementsFoundError(`Found multiple elements by [${attribute}=${text}]`, container);
    }
    return els[0] || null;
}
// this accepts a query function and returns a function which throws an error
// if more than one elements is returned, otherwise it returns the first
// element or null
function makeSingleQuery(allQuery, getMultipleError) {
    return (container, ...args)=>{
        const els = allQuery(container, ...args);
        if (els.length > 1) {
            const elementStrings = els.map((element)=>getElementError(null, element).message).join('\n\n');
            throw getMultipleElementsFoundError(`${getMultipleError(container, ...args)}

Here are the matching elements:

${elementStrings}`, container);
        }
        return els[0] || null;
    };
}
function getSuggestionError(suggestion, container) {
    return (0, _config.getConfig)().getElementError(`A better query is available, try this:
${suggestion.toString()}
`, container);
}
// this accepts a query function and returns a function which throws an error
// if an empty list of elements is returned
function makeGetAllQuery(allQuery, getMissingError) {
    return (container, ...args)=>{
        const els = allQuery(container, ...args);
        if (!els.length) {
            throw (0, _config.getConfig)().getElementError(getMissingError(container, ...args), container);
        }
        return els;
    };
}
// this accepts a getter query function and returns a function which calls
// waitFor and passing a function which invokes the getter.
function makeFindQuery(getter) {
    return (container, text, options, waitForOptions)=>{
        return (0, _waitFor.waitFor)(()=>{
            return getter(container, text, options);
        }, {
            container,
            ...waitForOptions
        });
    };
}
const wrapSingleQueryWithSuggestion = (query, queryAllByName, variant)=>(container, ...args)=>{
        const element = query(container, ...args);
        const [{ suggest = (0, _config.getConfig)().throwSuggestions } = {}] = args.slice(-1);
        if (element && suggest) {
            const suggestion = (0, _suggestions.getSuggestedQuery)(element, variant);
            if (suggestion && !queryAllByName.endsWith(suggestion.queryName)) {
                throw getSuggestionError(suggestion.toString(), container);
            }
        }
        return element;
    };
exports.wrapSingleQueryWithSuggestion = wrapSingleQueryWithSuggestion;
const wrapAllByQueryWithSuggestion = (query, queryAllByName, variant)=>(container, ...args)=>{
        const els = query(container, ...args);
        const [{ suggest = (0, _config.getConfig)().throwSuggestions } = {}] = args.slice(-1);
        if (els.length && suggest) {
            // get a unique list of all suggestion messages.  We are only going to make a suggestion if
            // all the suggestions are the same
            const uniqueSuggestionMessages = [
                ...new Set(els.map((element)=>{
                    var _getSuggestedQuery;
                    return (_getSuggestedQuery = (0, _suggestions.getSuggestedQuery)(element, variant)) == null ? void 0 : _getSuggestedQuery.toString();
                }))
            ];
            if (// only want to suggest if all the els have the same suggestion.
            uniqueSuggestionMessages.length === 1 && !queryAllByName.endsWith(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
            (0, _suggestions.getSuggestedQuery)(els[0], variant).queryName)) {
                throw getSuggestionError(uniqueSuggestionMessages[0], container);
            }
        }
        return els;
    };
// TODO: This deviates from the published declarations
// However, the implementation always required a dyadic (after `container`) not variadic `queryAllBy` considering the implementation of `makeFindQuery`
// This is at least statically true and can be verified by accepting `QueryMethod<Arguments, HTMLElement[]>`
exports.wrapAllByQueryWithSuggestion = wrapAllByQueryWithSuggestion;
function buildQueries(queryAllBy, getMultipleError, getMissingError) {
    const queryBy = wrapSingleQueryWithSuggestion(makeSingleQuery(queryAllBy, getMultipleError), queryAllBy.name, 'query');
    const getAllBy = makeGetAllQuery(queryAllBy, getMissingError);
    const getBy = makeSingleQuery(getAllBy, getMultipleError);
    const getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, 'get');
    const getAllWithSuggestions = wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name.replace('query', 'get'), 'getAll');
    const findAllBy = makeFindQuery(wrapAllByQueryWithSuggestion(getAllBy, queryAllBy.name, 'findAll'));
    const findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryAllBy.name, 'find'));
    return [
        queryBy,
        getAllWithSuggestions,
        getByWithSuggestions,
        findAllBy,
        findBy
    ];
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95dXN1a2V0c3Vub2RhL0RvY3VtZW50cy9jdXJzb3IvcHB0dHJhbnNsYXRvcmFwcC9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9yZWFjdC9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9xdWVyeS1oZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5idWlsZFF1ZXJpZXMgPSBidWlsZFF1ZXJpZXM7XG5leHBvcnRzLmdldEVsZW1lbnRFcnJvciA9IGdldEVsZW1lbnRFcnJvcjtcbmV4cG9ydHMuZ2V0TXVsdGlwbGVFbGVtZW50c0ZvdW5kRXJyb3IgPSBnZXRNdWx0aXBsZUVsZW1lbnRzRm91bmRFcnJvcjtcbmV4cG9ydHMubWFrZUZpbmRRdWVyeSA9IG1ha2VGaW5kUXVlcnk7XG5leHBvcnRzLm1ha2VHZXRBbGxRdWVyeSA9IG1ha2VHZXRBbGxRdWVyeTtcbmV4cG9ydHMubWFrZVNpbmdsZVF1ZXJ5ID0gbWFrZVNpbmdsZVF1ZXJ5O1xuZXhwb3J0cy5xdWVyeUFsbEJ5QXR0cmlidXRlID0gcXVlcnlBbGxCeUF0dHJpYnV0ZTtcbmV4cG9ydHMucXVlcnlCeUF0dHJpYnV0ZSA9IHF1ZXJ5QnlBdHRyaWJ1dGU7XG5leHBvcnRzLndyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uID0gZXhwb3J0cy53cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uID0gdm9pZCAwO1xudmFyIF9zdWdnZXN0aW9ucyA9IHJlcXVpcmUoXCIuL3N1Z2dlc3Rpb25zXCIpO1xudmFyIF9tYXRjaGVzID0gcmVxdWlyZShcIi4vbWF0Y2hlc1wiKTtcbnZhciBfd2FpdEZvciA9IHJlcXVpcmUoXCIuL3dhaXQtZm9yXCIpO1xudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5mdW5jdGlvbiBnZXRFbGVtZW50RXJyb3IobWVzc2FnZSwgY29udGFpbmVyKSB7XG4gIHJldHVybiAoMCwgX2NvbmZpZy5nZXRDb25maWcpKCkuZ2V0RWxlbWVudEVycm9yKG1lc3NhZ2UsIGNvbnRhaW5lcik7XG59XG5mdW5jdGlvbiBnZXRNdWx0aXBsZUVsZW1lbnRzRm91bmRFcnJvcihtZXNzYWdlLCBjb250YWluZXIpIHtcbiAgcmV0dXJuIGdldEVsZW1lbnRFcnJvcihgJHttZXNzYWdlfVxcblxcbihJZiB0aGlzIGlzIGludGVudGlvbmFsLCB0aGVuIHVzZSB0aGUgXFxgKkFsbEJ5KlxcYCB2YXJpYW50IG9mIHRoZSBxdWVyeSAobGlrZSBcXGBxdWVyeUFsbEJ5VGV4dFxcYCwgXFxgZ2V0QWxsQnlUZXh0XFxgLCBvciBcXGBmaW5kQWxsQnlUZXh0XFxgKSkuYCwgY29udGFpbmVyKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5QWxsQnlBdHRyaWJ1dGUoYXR0cmlidXRlLCBjb250YWluZXIsIHRleHQsIHtcbiAgZXhhY3QgPSB0cnVlLFxuICBjb2xsYXBzZVdoaXRlc3BhY2UsXG4gIHRyaW0sXG4gIG5vcm1hbGl6ZXJcbn0gPSB7fSkge1xuICBjb25zdCBtYXRjaGVyID0gZXhhY3QgPyBfbWF0Y2hlcy5tYXRjaGVzIDogX21hdGNoZXMuZnV6enlNYXRjaGVzO1xuICBjb25zdCBtYXRjaE5vcm1hbGl6ZXIgPSAoMCwgX21hdGNoZXMubWFrZU5vcm1hbGl6ZXIpKHtcbiAgICBjb2xsYXBzZVdoaXRlc3BhY2UsXG4gICAgdHJpbSxcbiAgICBub3JtYWxpemVyXG4gIH0pO1xuICByZXR1cm4gQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChgWyR7YXR0cmlidXRlfV1gKSkuZmlsdGVyKG5vZGUgPT4gbWF0Y2hlcihub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpLCBub2RlLCB0ZXh0LCBtYXRjaE5vcm1hbGl6ZXIpKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5QnlBdHRyaWJ1dGUoYXR0cmlidXRlLCBjb250YWluZXIsIHRleHQsIG9wdGlvbnMpIHtcbiAgY29uc3QgZWxzID0gcXVlcnlBbGxCeUF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRhaW5lciwgdGV4dCwgb3B0aW9ucyk7XG4gIGlmIChlbHMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IGdldE11bHRpcGxlRWxlbWVudHNGb3VuZEVycm9yKGBGb3VuZCBtdWx0aXBsZSBlbGVtZW50cyBieSBbJHthdHRyaWJ1dGV9PSR7dGV4dH1dYCwgY29udGFpbmVyKTtcbiAgfVxuICByZXR1cm4gZWxzWzBdIHx8IG51bGw7XG59XG5cbi8vIHRoaXMgYWNjZXB0cyBhIHF1ZXJ5IGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGVycm9yXG4vLyBpZiBtb3JlIHRoYW4gb25lIGVsZW1lbnRzIGlzIHJldHVybmVkLCBvdGhlcndpc2UgaXQgcmV0dXJucyB0aGUgZmlyc3Rcbi8vIGVsZW1lbnQgb3IgbnVsbFxuZnVuY3Rpb24gbWFrZVNpbmdsZVF1ZXJ5KGFsbFF1ZXJ5LCBnZXRNdWx0aXBsZUVycm9yKSB7XG4gIHJldHVybiAoY29udGFpbmVyLCAuLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgZWxzID0gYWxsUXVlcnkoY29udGFpbmVyLCAuLi5hcmdzKTtcbiAgICBpZiAoZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRTdHJpbmdzID0gZWxzLm1hcChlbGVtZW50ID0+IGdldEVsZW1lbnRFcnJvcihudWxsLCBlbGVtZW50KS5tZXNzYWdlKS5qb2luKCdcXG5cXG4nKTtcbiAgICAgIHRocm93IGdldE11bHRpcGxlRWxlbWVudHNGb3VuZEVycm9yKGAke2dldE11bHRpcGxlRXJyb3IoY29udGFpbmVyLCAuLi5hcmdzKX1cblxuSGVyZSBhcmUgdGhlIG1hdGNoaW5nIGVsZW1lbnRzOlxuXG4ke2VsZW1lbnRTdHJpbmdzfWAsIGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiBlbHNbMF0gfHwgbnVsbDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN1Z2dlc3Rpb25FcnJvcihzdWdnZXN0aW9uLCBjb250YWluZXIpIHtcbiAgcmV0dXJuICgwLCBfY29uZmlnLmdldENvbmZpZykoKS5nZXRFbGVtZW50RXJyb3IoYEEgYmV0dGVyIHF1ZXJ5IGlzIGF2YWlsYWJsZSwgdHJ5IHRoaXM6XG4ke3N1Z2dlc3Rpb24udG9TdHJpbmcoKX1cbmAsIGNvbnRhaW5lcik7XG59XG5cbi8vIHRoaXMgYWNjZXB0cyBhIHF1ZXJ5IGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGVycm9yXG4vLyBpZiBhbiBlbXB0eSBsaXN0IG9mIGVsZW1lbnRzIGlzIHJldHVybmVkXG5mdW5jdGlvbiBtYWtlR2V0QWxsUXVlcnkoYWxsUXVlcnksIGdldE1pc3NpbmdFcnJvcikge1xuICByZXR1cm4gKGNvbnRhaW5lciwgLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGVscyA9IGFsbFF1ZXJ5KGNvbnRhaW5lciwgLi4uYXJncyk7XG4gICAgaWYgKCFlbHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyAoMCwgX2NvbmZpZy5nZXRDb25maWcpKCkuZ2V0RWxlbWVudEVycm9yKGdldE1pc3NpbmdFcnJvcihjb250YWluZXIsIC4uLmFyZ3MpLCBjb250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZWxzO1xuICB9O1xufVxuXG4vLyB0aGlzIGFjY2VwdHMgYSBnZXR0ZXIgcXVlcnkgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBjYWxsc1xuLy8gd2FpdEZvciBhbmQgcGFzc2luZyBhIGZ1bmN0aW9uIHdoaWNoIGludm9rZXMgdGhlIGdldHRlci5cbmZ1bmN0aW9uIG1ha2VGaW5kUXVlcnkoZ2V0dGVyKSB7XG4gIHJldHVybiAoY29udGFpbmVyLCB0ZXh0LCBvcHRpb25zLCB3YWl0Rm9yT3B0aW9ucykgPT4ge1xuICAgIHJldHVybiAoMCwgX3dhaXRGb3Iud2FpdEZvcikoKCkgPT4ge1xuICAgICAgcmV0dXJuIGdldHRlcihjb250YWluZXIsIHRleHQsIG9wdGlvbnMpO1xuICAgIH0sIHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIC4uLndhaXRGb3JPcHRpb25zXG4gICAgfSk7XG4gIH07XG59XG5jb25zdCB3cmFwU2luZ2xlUXVlcnlXaXRoU3VnZ2VzdGlvbiA9IChxdWVyeSwgcXVlcnlBbGxCeU5hbWUsIHZhcmlhbnQpID0+IChjb250YWluZXIsIC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IHF1ZXJ5KGNvbnRhaW5lciwgLi4uYXJncyk7XG4gIGNvbnN0IFt7XG4gICAgc3VnZ2VzdCA9ICgwLCBfY29uZmlnLmdldENvbmZpZykoKS50aHJvd1N1Z2dlc3Rpb25zXG4gIH0gPSB7fV0gPSBhcmdzLnNsaWNlKC0xKTtcbiAgaWYgKGVsZW1lbnQgJiYgc3VnZ2VzdCkge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSAoMCwgX3N1Z2dlc3Rpb25zLmdldFN1Z2dlc3RlZFF1ZXJ5KShlbGVtZW50LCB2YXJpYW50KTtcbiAgICBpZiAoc3VnZ2VzdGlvbiAmJiAhcXVlcnlBbGxCeU5hbWUuZW5kc1dpdGgoc3VnZ2VzdGlvbi5xdWVyeU5hbWUpKSB7XG4gICAgICB0aHJvdyBnZXRTdWdnZXN0aW9uRXJyb3Ioc3VnZ2VzdGlvbi50b1N0cmluZygpLCBjb250YWluZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn07XG5leHBvcnRzLndyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uID0gd3JhcFNpbmdsZVF1ZXJ5V2l0aFN1Z2dlc3Rpb247XG5jb25zdCB3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uID0gKHF1ZXJ5LCBxdWVyeUFsbEJ5TmFtZSwgdmFyaWFudCkgPT4gKGNvbnRhaW5lciwgLi4uYXJncykgPT4ge1xuICBjb25zdCBlbHMgPSBxdWVyeShjb250YWluZXIsIC4uLmFyZ3MpO1xuICBjb25zdCBbe1xuICAgIHN1Z2dlc3QgPSAoMCwgX2NvbmZpZy5nZXRDb25maWcpKCkudGhyb3dTdWdnZXN0aW9uc1xuICB9ID0ge31dID0gYXJncy5zbGljZSgtMSk7XG4gIGlmIChlbHMubGVuZ3RoICYmIHN1Z2dlc3QpIHtcbiAgICAvLyBnZXQgYSB1bmlxdWUgbGlzdCBvZiBhbGwgc3VnZ2VzdGlvbiBtZXNzYWdlcy4gIFdlIGFyZSBvbmx5IGdvaW5nIHRvIG1ha2UgYSBzdWdnZXN0aW9uIGlmXG4gICAgLy8gYWxsIHRoZSBzdWdnZXN0aW9ucyBhcmUgdGhlIHNhbWVcbiAgICBjb25zdCB1bmlxdWVTdWdnZXN0aW9uTWVzc2FnZXMgPSBbLi4ubmV3IFNldChlbHMubWFwKGVsZW1lbnQgPT4ge1xuICAgICAgdmFyIF9nZXRTdWdnZXN0ZWRRdWVyeTtcbiAgICAgIHJldHVybiAoX2dldFN1Z2dlc3RlZFF1ZXJ5ID0gKDAsIF9zdWdnZXN0aW9ucy5nZXRTdWdnZXN0ZWRRdWVyeSkoZWxlbWVudCwgdmFyaWFudCkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0U3VnZ2VzdGVkUXVlcnkudG9TdHJpbmcoKTtcbiAgICB9KSldO1xuICAgIGlmIChcbiAgICAvLyBvbmx5IHdhbnQgdG8gc3VnZ2VzdCBpZiBhbGwgdGhlIGVscyBoYXZlIHRoZSBzYW1lIHN1Z2dlc3Rpb24uXG4gICAgdW5pcXVlU3VnZ2VzdGlvbk1lc3NhZ2VzLmxlbmd0aCA9PT0gMSAmJiAhcXVlcnlBbGxCeU5hbWUuZW5kc1dpdGgoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gLS0gVE9ETzogQ2FuIHRoaXMgYmUgbnVsbCBhdCBydW50aW1lP1xuICAgICgwLCBfc3VnZ2VzdGlvbnMuZ2V0U3VnZ2VzdGVkUXVlcnkpKGVsc1swXSwgdmFyaWFudCkucXVlcnlOYW1lKSkge1xuICAgICAgdGhyb3cgZ2V0U3VnZ2VzdGlvbkVycm9yKHVuaXF1ZVN1Z2dlc3Rpb25NZXNzYWdlc1swXSwgY29udGFpbmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVscztcbn07XG5cbi8vIFRPRE86IFRoaXMgZGV2aWF0ZXMgZnJvbSB0aGUgcHVibGlzaGVkIGRlY2xhcmF0aW9uc1xuLy8gSG93ZXZlciwgdGhlIGltcGxlbWVudGF0aW9uIGFsd2F5cyByZXF1aXJlZCBhIGR5YWRpYyAoYWZ0ZXIgYGNvbnRhaW5lcmApIG5vdCB2YXJpYWRpYyBgcXVlcnlBbGxCeWAgY29uc2lkZXJpbmcgdGhlIGltcGxlbWVudGF0aW9uIG9mIGBtYWtlRmluZFF1ZXJ5YFxuLy8gVGhpcyBpcyBhdCBsZWFzdCBzdGF0aWNhbGx5IHRydWUgYW5kIGNhbiBiZSB2ZXJpZmllZCBieSBhY2NlcHRpbmcgYFF1ZXJ5TWV0aG9kPEFyZ3VtZW50cywgSFRNTEVsZW1lbnRbXT5gXG5leHBvcnRzLndyYXBBbGxCeVF1ZXJ5V2l0aFN1Z2dlc3Rpb24gPSB3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uO1xuZnVuY3Rpb24gYnVpbGRRdWVyaWVzKHF1ZXJ5QWxsQnksIGdldE11bHRpcGxlRXJyb3IsIGdldE1pc3NpbmdFcnJvcikge1xuICBjb25zdCBxdWVyeUJ5ID0gd3JhcFNpbmdsZVF1ZXJ5V2l0aFN1Z2dlc3Rpb24obWFrZVNpbmdsZVF1ZXJ5KHF1ZXJ5QWxsQnksIGdldE11bHRpcGxlRXJyb3IpLCBxdWVyeUFsbEJ5Lm5hbWUsICdxdWVyeScpO1xuICBjb25zdCBnZXRBbGxCeSA9IG1ha2VHZXRBbGxRdWVyeShxdWVyeUFsbEJ5LCBnZXRNaXNzaW5nRXJyb3IpO1xuICBjb25zdCBnZXRCeSA9IG1ha2VTaW5nbGVRdWVyeShnZXRBbGxCeSwgZ2V0TXVsdGlwbGVFcnJvcik7XG4gIGNvbnN0IGdldEJ5V2l0aFN1Z2dlc3Rpb25zID0gd3JhcFNpbmdsZVF1ZXJ5V2l0aFN1Z2dlc3Rpb24oZ2V0QnksIHF1ZXJ5QWxsQnkubmFtZSwgJ2dldCcpO1xuICBjb25zdCBnZXRBbGxXaXRoU3VnZ2VzdGlvbnMgPSB3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uKGdldEFsbEJ5LCBxdWVyeUFsbEJ5Lm5hbWUucmVwbGFjZSgncXVlcnknLCAnZ2V0JyksICdnZXRBbGwnKTtcbiAgY29uc3QgZmluZEFsbEJ5ID0gbWFrZUZpbmRRdWVyeSh3cmFwQWxsQnlRdWVyeVdpdGhTdWdnZXN0aW9uKGdldEFsbEJ5LCBxdWVyeUFsbEJ5Lm5hbWUsICdmaW5kQWxsJykpO1xuICBjb25zdCBmaW5kQnkgPSBtYWtlRmluZFF1ZXJ5KHdyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uKGdldEJ5LCBxdWVyeUFsbEJ5Lm5hbWUsICdmaW5kJykpO1xuICByZXR1cm4gW3F1ZXJ5QnksIGdldEFsbFdpdGhTdWdnZXN0aW9ucywgZ2V0QnlXaXRoU3VnZ2VzdGlvbnMsIGZpbmRBbGxCeSwgZmluZEJ5XTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJidWlsZFF1ZXJpZXMiLCJnZXRFbGVtZW50RXJyb3IiLCJnZXRNdWx0aXBsZUVsZW1lbnRzRm91bmRFcnJvciIsIm1ha2VGaW5kUXVlcnkiLCJtYWtlR2V0QWxsUXVlcnkiLCJtYWtlU2luZ2xlUXVlcnkiLCJxdWVyeUFsbEJ5QXR0cmlidXRlIiwicXVlcnlCeUF0dHJpYnV0ZSIsIndyYXBTaW5nbGVRdWVyeVdpdGhTdWdnZXN0aW9uIiwid3JhcEFsbEJ5UXVlcnlXaXRoU3VnZ2VzdGlvbiIsIl9zdWdnZXN0aW9ucyIsInJlcXVpcmUiLCJfbWF0Y2hlcyIsIl93YWl0Rm9yIiwiX2NvbmZpZyIsIm1lc3NhZ2UiLCJjb250YWluZXIiLCJnZXRDb25maWciLCJhdHRyaWJ1dGUiLCJ0ZXh0IiwiZXhhY3QiLCJjb2xsYXBzZVdoaXRlc3BhY2UiLCJ0cmltIiwibm9ybWFsaXplciIsIm1hdGNoZXIiLCJtYXRjaGVzIiwiZnV6enlNYXRjaGVzIiwibWF0Y2hOb3JtYWxpemVyIiwibWFrZU5vcm1hbGl6ZXIiLCJBcnJheSIsImZyb20iLCJxdWVyeVNlbGVjdG9yQWxsIiwiZmlsdGVyIiwibm9kZSIsImdldEF0dHJpYnV0ZSIsIm9wdGlvbnMiLCJlbHMiLCJsZW5ndGgiLCJhbGxRdWVyeSIsImdldE11bHRpcGxlRXJyb3IiLCJhcmdzIiwiZWxlbWVudFN0cmluZ3MiLCJtYXAiLCJlbGVtZW50Iiwiam9pbiIsImdldFN1Z2dlc3Rpb25FcnJvciIsInN1Z2dlc3Rpb24iLCJ0b1N0cmluZyIsImdldE1pc3NpbmdFcnJvciIsImdldHRlciIsIndhaXRGb3JPcHRpb25zIiwid2FpdEZvciIsInF1ZXJ5IiwicXVlcnlBbGxCeU5hbWUiLCJ2YXJpYW50Iiwic3VnZ2VzdCIsInRocm93U3VnZ2VzdGlvbnMiLCJzbGljZSIsImdldFN1Z2dlc3RlZFF1ZXJ5IiwiZW5kc1dpdGgiLCJxdWVyeU5hbWUiLCJ1bmlxdWVTdWdnZXN0aW9uTWVzc2FnZXMiLCJTZXQiLCJfZ2V0U3VnZ2VzdGVkUXVlcnkiLCJxdWVyeUFsbEJ5IiwicXVlcnlCeSIsIm5hbWUiLCJnZXRBbGxCeSIsImdldEJ5IiwiZ2V0QnlXaXRoU3VnZ2VzdGlvbnMiLCJnZXRBbGxXaXRoU3VnZ2VzdGlvbnMiLCJyZXBsYWNlIiwiZmluZEFsbEJ5IiwiZmluZEJ5Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxjQUFjLENBQUNDLFNBQVMsY0FBYztJQUMzQ0MsT0FBTztBQUNUO0FBQ0FELFFBQVFFLFlBQVksR0FBR0E7QUFDdkJGLFFBQVFHLGVBQWUsR0FBR0E7QUFDMUJILFFBQVFJLDZCQUE2QixHQUFHQTtBQUN4Q0osUUFBUUssYUFBYSxHQUFHQTtBQUN4QkwsUUFBUU0sZUFBZSxHQUFHQTtBQUMxQk4sUUFBUU8sZUFBZSxHQUFHQTtBQUMxQlAsUUFBUVEsbUJBQW1CLEdBQUdBO0FBQzlCUixRQUFRUyxnQkFBZ0IsR0FBR0E7QUFDM0JULFFBQVFVLDZCQUE2QixHQUFHVixRQUFRVyw0QkFBNEIsR0FBRyxLQUFLO0FBQ3BGLElBQUlDLGVBQWVDLFFBQVE7QUFDM0IsSUFBSUMsV0FBV0QsUUFBUTtBQUN2QixJQUFJRSxX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