1527b9485d415c5b4a240ce1a164769a
/**
 * @license React
 * react-dom-test-utils.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
if (process.env.NODE_ENV !== "production") {
    (function() {
        'use strict';
        var React = require('react');
        var ReactDOM = require('react-dom');
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        // by calls to these methods by a Babel plugin.
        //
        // In PROD (or in packages without access to React internals),
        // they are left as they are instead.
        function warn(format) {
            {
                {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
        }
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            // When changing this logic, you might want to also
            // update consoleWithStackDev.www.js as well.
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                } // eslint-disable-next-line react-internal/safe-string-coercion
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                }); // Careful: RN currently depends on this prefix
                argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
                // breaks IE9: https://github.com/facebook/react/issues/13610
                // eslint-disable-next-line react-internal/no-production-logging
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        /**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */ function get(key) {
            return key._reactInternals;
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
        var HostComponent = 5;
        var HostText = 6;
        // Don't change these two values. They're used by React Dev Tools.
        var NoFlags = /*                      */ 0;
        var Placement = /*                    */ 2;
        var Hydrating = /*                    */ 4096;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
                // If there is no alternate, this might be a new tree that isn't inserted
                // yet. If it is, then it will have a pending insertion effect on it.
                var nextNode = node;
                do {
                    node = nextNode;
                    if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                        // This is an insertion or in-progress hydration. The nearest possible
                        // mounted fiber is the parent but we need to continue to figure out
                        // if that one is still mounted.
                        nearestMounted = node.return;
                    }
                    nextNode = node.return;
                }while (nextNode)
            } else {
                while(node.return){
                    node = node.return;
                }
            }
            if (node.tag === HostRoot) {
                // TODO: Check if this was a nested HostRoot when used with
                // renderContainerIntoSubtree.
                return nearestMounted;
            } // If we didn't hit the root, that means that we're in an disconnected tree
            // that has been unmounted.
            return null;
        }
        function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
                throw new Error('Unable to find node on an unmounted component.');
            }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
                // If there is no alternate, then we only need to check if it is mounted.
                var nearestMounted = getNearestMountedFiber(fiber);
                if (nearestMounted === null) {
                    throw new Error('Unable to find node on an unmounted component.');
                }
                if (nearestMounted !== fiber) {
                    return null;
                }
                return fiber;
            } // If we have two possible branches, we'll walk backwards up to the root
            // to see what path the root points to. On the way we may hit one of the
            // special cases and we'll deal with them.
            var a = fiber;
            var b = alternate;
            while(true){
                var parentA = a.return;
                if (parentA === null) {
                    break;
                }
                var parentB = parentA.alternate;
                if (parentB === null) {
                    // There is no alternate. This is an unusual case. Currently, it only
                    // happens when a Suspense component is hidden. An extra fragment fiber
                    // is inserted in between the Suspense fiber and its children. Skip
                    // over this extra fragment fiber and proceed to the next parent.
                    var nextParent = parentA.return;
                    if (nextParent !== null) {
                        a = b = nextParent;
                        continue;
                    } // If there's no parent, we're at the root.
                    break;
                } // If both copies of the parent fiber point to the same child, we can
                // assume that the child is current. This happens when we bailout on low
                // priority: the bailed out fiber's child reuses the current child.
                if (parentA.child === parentB.child) {
                    var child = parentA.child;
                    while(child){
                        if (child === a) {
                            // We've determined that A is the current branch.
                            assertIsMounted(parentA);
                            return fiber;
                        }
                        if (child === b) {
                            // We've determined that B is the current branch.
                            assertIsMounted(parentA);
                            return alternate;
                        }
                        child = child.sibling;
                    } // We should never have an alternate for any mounting node. So the only
                    // way this could possibly happen is if this was unmounted, if at all.
                    throw new Error('Unable to find node on an unmounted component.');
                }
                if (a.return !== b.return) {
                    // The return pointer of A and the return pointer of B point to different
                    // fibers. We assume that return pointers never criss-cross, so A must
                    // belong to the child set of A.return, and B must belong to the child
                    // set of B.return.
                    a = parentA;
                    b = parentB;
                } else {
                    // The return pointers point to the same fiber. We'll have to use the
                    // default, slow path: scan the child sets of each parent alternate to see
                    // which child belongs to which set.
                    //
                    // Search parent A's child set
                    var didFindChild = false;
                    var _child = parentA.child;
                    while(_child){
                        if (_child === a) {
                            didFindChild = true;
                            a = parentA;
                            b = parentB;
                            break;
                        }
                        if (_child === b) {
                            didFindChild = true;
                            b = parentA;
                            a = parentB;
                            break;
                        }
                        _child = _child.sibling;
                    }
                    if (!didFindChild) {
                        // Search parent B's child set
                        _child = parentB.child;
                        while(_child){
                            if (_child === a) {
                                didFindChild = true;
                                a = parentB;
                                b = parentA;
                                break;
                            }
                            if (_child === b) {
                                didFindChild = true;
                                b = parentB;
                                a = parentA;
                                break;
                            }
                            _child = _child.sibling;
                        }
                        if (!didFindChild) {
                            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
                        }
                    }
                }
                if (a.alternate !== b) {
                    throw new Error("Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
                }
            } // If the root is not a host container, we're in a disconnected tree. I.e.
            // unmounted.
            if (a.tag !== HostRoot) {
                throw new Error('Unable to find node on an unmounted component.');
            }
            if (a.stateNode.current === a) {
                // We've determined that A is the current branch.
                return fiber;
            } // Otherwise B has to be current branch.
            return alternate;
        }
        var assign = Object.assign;
        /**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */ function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ('charCode' in nativeEvent) {
                charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.
                if (charCode === 0 && keyCode === 13) {
                    charCode = 13;
                }
            } else {
                // IE8 does not implement `charCode`, but `keyCode` has the correct value.
                charCode = keyCode;
            } // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
            // report Enter as charCode 10 when ctrl is pressed.
            if (charCode === 10) {
                charCode = 13;
            } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
            // Must not discard the (non-)printable Enter-key.
            if (charCode >= 32 || charCode === 13) {
                return charCode;
            }
            return 0;
        }
        function functionThatReturnsTrue() {
            return true;
        }
        function functionThatReturnsFalse() {
            return false;
        } // This is intentionally a factory so that we have different returned constructors.
        // If we had a single constructor, it would be megamorphic and engines would deopt.
        function createSyntheticEvent(Interface) {
            /**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */ function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
                this._reactName = reactName;
                this._targetInst = targetInst;
                this.type = reactEventType;
                this.nativeEvent = nativeEvent;
                this.target = nativeEventTarget;
                this.currentTarget = null;
                for(var _propName in Interface){
                    if (!Interface.hasOwnProperty(_propName)) {
                        continue;
                    }
                    var normalize = Interface[_propName];
                    if (normalize) {
                        this[_propName] = normalize(nativeEvent);
                    } else {
                        this[_propName] = nativeEvent[_propName];
                    }
                }
                var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
                if (defaultPrevented) {
                    this.isDefaultPrevented = functionThatReturnsTrue;
                } else {
                    this.isDefaultPrevented = functionThatReturnsFalse;
                }
                this.isPropagationStopped = functionThatReturnsFalse;
                return this;
            }
            assign(SyntheticBaseEvent.prototype, {
                preventDefault: function() {
                    this.defaultPrevented = true;
                    var event = this.nativeEvent;
                    if (!event) {
                        return;
                    }
                    if (event.preventDefault) {
                        event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
                    } else if (typeof event.returnValue !== 'unknown') {
                        event.returnValue = false;
                    }
                    this.isDefaultPrevented = functionThatReturnsTrue;
                },
                stopPropagation: function() {
                    var event = this.nativeEvent;
                    if (!event) {
                        return;
                    }
                    if (event.stopPropagation) {
                        event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
                    } else if (typeof event.cancelBubble !== 'unknown') {
                        // The ChangeEventPlugin registers a "propertychange" event for
                        // IE. This event does not support bubbling or cancelling, and
                        // any references to cancelBubble throw "Member not found".  A
                        // typeof check of "unknown" circumvents this issue (and is also
                        // IE specific).
                        event.cancelBubble = true;
                    }
                    this.isPropagationStopped = functionThatReturnsTrue;
                },
                /**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */ persist: function() {},
                /**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */ isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
        }
        /**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
                return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = assign({}, EventInterface, {
            view: 0,
            detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
                if (lastMouseEvent && event.type === 'mousemove') {
                    lastMovementX = event.screenX - lastMouseEvent.screenX;
                    lastMovementY = event.screenY - lastMouseEvent.screenY;
                } else {
                    lastMovementX = 0;
                    lastMovementY = 0;
                }
                lastMouseEvent = event;
            }
        }
        /**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
                if (event.relatedTarget === undefined) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
                return event.relatedTarget;
            },
            movementX: function(event) {
                if ('movementX' in event) {
                    return event.movementX;
                }
                updateMouseMovementPolyfillState(event);
                return lastMovementX;
            },
            movementY: function(event) {
                if ('movementY' in event) {
                    return event.movementY;
                } // Don't need to call updateMouseMovementPolyfillState() here
                // because it's guaranteed to have already run when movementX
                // was copied.
                return lastMovementY;
            }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        /**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var DragEventInterface = assign({}, MouseEventInterface, {
            dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        /**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var FocusEventInterface = assign({}, UIEventInterface, {
            relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        /**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */ var AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        /**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */ var ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function(event) {
                return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
            }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        /**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */ var CompositionEventInterface = assign({}, EventInterface, {
            data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        /**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */ var normalizeKey = {
            Esc: 'Escape',
            Spacebar: ' ',
            Left: 'ArrowLeft',
            Up: 'ArrowUp',
            Right: 'ArrowRight',
            Down: 'ArrowDown',
            Del: 'Delete',
            Win: 'OS',
            Menu: 'ContextMenu',
            Apps: 'ContextMenu',
            Scroll: 'ScrollLock',
            MozPrintableKey: 'Unidentified'
        };
        /**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */ var translateToKey = {
            '8': 'Backspace',
            '9': 'Tab',
            '12': 'Clear',
            '13': 'Enter',
            '16': 'Shift',
            '17': 'Control',
            '18': 'Alt',
            '19': 'Pause',
            '20': 'CapsLock',
            '27': 'Escape',
            '32': ' ',
            '33': 'PageUp',
            '34': 'PageDown',
            '35': 'End',
            '36': 'Home',
            '37': 'ArrowLeft',
            '38': 'ArrowUp',
            '39': 'ArrowRight',
            '40': 'ArrowDown',
            '45': 'Insert',
            '46': 'Delete',
            '112': 'F1',
            '113': 'F2',
            '114': 'F3',
            '115': 'F4',
            '116': 'F5',
            '117': 'F6',
            '118': 'F7',
            '119': 'F8',
            '120': 'F9',
            '121': 'F10',
            '122': 'F11',
            '123': 'F12',
            '144': 'NumLock',
            '145': 'ScrollLock',
            '224': 'Meta'
        };
        /**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */ function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
                // Normalize inconsistent values reported by browsers due to
                // implementations of a working draft specification.
                // FireFox implements `key` but returns `MozPrintableKey` for all
                // printable characters (normalized to `Unidentified`), ignore it.
                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                if (key !== 'Unidentified') {
                    return key;
                }
            } // Browser does not implement `key`, polyfill as much of it as we can.
            if (nativeEvent.type === 'keypress') {
                var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can
                // thus be captured by `keypress`, no other non-printable key should.
                return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
                // While user keyboard layout determines the actual meaning of each
                // `keyCode` value, almost all function keys have a universal value.
                return translateToKey[nativeEvent.keyCode] || 'Unidentified';
            }
            return '';
        }
        /**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */ var modifierKeyToProp = {
            Alt: 'altKey',
            Control: 'ctrlKey',
            Meta: 'metaKey',
            Shift: 'shiftKey'
        }; // Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
        // getModifierState. If getModifierState is not supported, we map it to a set of
        // modifier keys exposed by the event. In this case, Lock-keys are not supported.
        function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
                return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
        }
        /**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var KeyboardEventInterface = assign({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            // Legacy Interface
            charCode: function(event) {
                // `charCode` is the result of a KeyPress event and represents the value of
                // the actual printable character.
                // KeyPress is deprecated, but its replacement is not yet final and not
                // implemented in any major browser. Only KeyPress has charCode.
                if (event.type === 'keypress') {
                    return getEventCharCode(event);
                }
                return 0;
            },
            keyCode: function(event) {
                // `keyCode` is the result of a KeyDown/Up event and represents the value of
                // physical keyboard key.
                // The actual meaning of the value depends on the users' keyboard layout
                // which cannot be detected. Assuming that it is a US keyboard layout
                // provides a surprisingly accurate mapping for US and European users.
                // Due to this, it is left to the user to implement at this time.
                if (event.type === 'keydown' || event.type === 'keyup') {
                    return event.keyCode;
                }
                return 0;
            },
            which: function(event) {
                // `which` is an alias for either `keyCode` or `charCode` depending on the
                // type of the event.
                if (event.type === 'keypress') {
                    return getEventCharCode(event);
                }
                if (event.type === 'keydown' || event.type === 'keyup') {
                    return event.keyCode;
                }
                return 0;
            }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        /**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */ var PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        /**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */ var TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        /**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */ var TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        /**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function(event) {
                return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function(event) {
                return 'deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0;
            },
            deltaZ: 0,
            // Browsers without "deltaMode" is reporting in raw wheel delta where one
            // notch on the scroll is always +/- 120, roughly equivalent to pixels.
            // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
            // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
            deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        /**
 * HTML nodeType values that represent the type of the node
 */ var ELEMENT_NODE = 1;
        function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
                func.apply(context, funcArgs);
            } catch (error) {
                this.onError(error);
            }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
            // In DEV mode, we swap out invokeGuardedCallback for a special version
            // that plays more nicely with the browser's DevTools. The idea is to preserve
            // "Pause on exceptions" behavior. Because React wraps all user-provided
            // functions in invokeGuardedCallback, and the production version of
            // invokeGuardedCallback uses a try-catch, all user exceptions are treated
            // like caught exceptions, and the DevTools won't pause unless the developer
            // takes the extra step of enabling pause on caught exceptions. This is
            // unintuitive, though, because even though React has caught the error, from
            // the developer's perspective, the error is uncaught.
            //
            // To preserve the expected "Pause on exceptions" behavior, we don't use a
            // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
            // DOM node, and call the user-provided callback from inside an event handler
            // for that fake event. If the callback throws, the error is "captured" using
            // a global event handler. But because the error happens in a different
            // event loop context, it does not interrupt the normal program flow.
            // Effectively, this gives us try-catch behavior without actually using
            // try-catch. Neat!
            // Check that the browser supports the APIs we need to implement our special
            // DEV version of invokeGuardedCallback
            if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
                var fakeNode = document.createElement('react');
                invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
                    // If document doesn't exist we know for sure we will crash in this method
                    // when we call document.createEvent(). However this can cause confusing
                    // errors: https://github.com/facebook/create-react-app/issues/3482
                    // So we preemptively throw with a better message instead.
                    if (typeof document === 'undefined' || document === null) {
                        throw new Error('The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');
                    }
                    var evt = document.createEvent('Event');
                    var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
                    // set this to true at the beginning, then set it to false right after
                    // calling the function. If the function errors, `didError` will never be
                    // set to false. This strategy works even if the browser is flaky and
                    // fails to call our global error handler, because it doesn't rely on
                    // the error event at all.
                    var didError = true; // Keeps track of the value of window.event so that we can reset it
                    // during the callback to let user code access window.event in the
                    // browsers that support it.
                    var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
                    // dispatching: https://github.com/facebook/react/issues/13688
                    var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');
                    function restoreAfterDispatch() {
                        // We immediately remove the callback from event listeners so that
                        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
                        // nested call would trigger the fake event handlers of any call higher
                        // in the stack.
                        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
                        // window.event assignment in both IE <= 10 as they throw an error
                        // "Member not found" in strict mode, and in Firefox which does not
                        // support window.event.
                        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
                            window.event = windowEvent;
                        }
                    } // Create an event handler for our fake event. We will synchronously
                    // dispatch our fake event using `dispatchEvent`. Inside the handler, we
                    // call the user-provided callback.
                    var funcArgs = Array.prototype.slice.call(arguments, 3);
                    function callCallback() {
                        didCall = true;
                        restoreAfterDispatch();
                        func.apply(context, funcArgs);
                        didError = false;
                    } // Create a global error event handler. We use this to capture the value
                    // that was thrown. It's possible that this error handler will fire more
                    // than once; for example, if non-React code also calls `dispatchEvent`
                    // and a handler for that event throws. We should be resilient to most of
                    // those cases. Even if our error event handler fires more than once, the
                    // last error event is always used. If the callback actually does error,
                    // we know that the last error event is the correct one, because it's not
                    // possible for anything else to have happened in between our callback
                    // erroring and the code that follows the `dispatchEvent` call below. If
                    // the callback doesn't error, but the error event was fired, we know to
                    // ignore it because `didError` will be false, as described above.
                    var error; // Use this to track whether the error event is ever called.
                    var didSetError = false;
                    var isCrossOriginError = false;
                    function handleWindowError(event) {
                        error = event.error;
                        didSetError = true;
                        if (error === null && event.colno === 0 && event.lineno === 0) {
                            isCrossOriginError = true;
                        }
                        if (event.defaultPrevented) {
                            // Some other error handler has prevented default.
                            // Browsers silence the error report if this happens.
                            // We'll remember this to later decide whether to log it or not.
                            if (error != null && typeof error === 'object') {
                                try {
                                    error._suppressLogging = true;
                                } catch (inner) {}
                            }
                        }
                    } // Create a fake event type.
                    var evtType = "react-" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers
                    window.addEventListener('error', handleWindowError);
                    fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
                    // errors, it will trigger our global error handler.
                    evt.initEvent(evtType, false, false);
                    fakeNode.dispatchEvent(evt);
                    if (windowEventDescriptor) {
                        Object.defineProperty(window, 'event', windowEventDescriptor);
                    }
                    if (didCall && didError) {
                        if (!didSetError) {
                            // The callback errored, but the error event never fired.
                            // eslint-disable-next-line react-internal/prod-error-codes
                            error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
                        } else if (isCrossOriginError) {
                            // eslint-disable-next-line react-internal/prod-error-codes
                            error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');
                        }
                        this.onError(error);
                    } // Remove our event listeners
                    window.removeEventListener('error', handleWindowError);
                    if (!didCall) {
                        // Something went really wrong, and our event was not dispatched.
                        // https://github.com/facebook/react/issues/16734
                        // https://github.com/facebook/react/issues/16585
                        // Fall back to the production implementation.
                        restoreAfterDispatch();
                        return invokeGuardedCallbackProd.apply(this, arguments);
                    }
                };
            }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null; // Used by event system to capture/rethrow the first error.
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
            onError: function(error) {
                hasError = true;
                caughtError = error;
            }
        };
        /**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */ function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        /**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */ function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
                var error = clearCaughtError();
                if (!hasRethrowError) {
                    hasRethrowError = true;
                    rethrowError = error;
                }
            }
        }
        /**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */ function rethrowCaughtError() {
            if (hasRethrowError) {
                var error = rethrowError;
                hasRethrowError = false;
                rethrowError = null;
                throw error;
            }
        }
        function clearCaughtError() {
            if (hasError) {
                var error = caughtError;
                hasError = false;
                caughtError = null;
                return error;
            } else {
                throw new Error('clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');
            }
        }
        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
        function isArray(a) {
            return isArrayImpl(a);
        }
        var SecretInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var EventInternals = SecretInternals.Events;
        var getInstanceFromNode = EventInternals[0];
        var getNodeFromInstance = EventInternals[1];
        var getFiberCurrentPropsFromNode = EventInternals[2];
        var enqueueStateRestore = EventInternals[3];
        var restoreStateIfNeeded = EventInternals[4];
        var reactAct = React.unstable_act;
        function Event(suffix) {}
        var hasWarnedAboutDeprecatedMockComponent = false;
        /**
 * @class ReactTestUtils
 */ function findAllInRenderedFiberTreeInternal(fiber, test) {
            if (!fiber) {
                return [];
            }
            var currentParent = findCurrentFiberUsingSlowPath(fiber);
            if (!currentParent) {
                return [];
            }
            var node = currentParent;
            var ret = [];
            while(true){
                if (node.tag === HostComponent || node.tag === HostText || node.tag === ClassComponent || node.tag === FunctionComponent) {
                    var publicInst = node.stateNode;
                    if (test(publicInst)) {
                        ret.push(publicInst);
                    }
                }
                if (node.child) {
                    node.child.return = node;
                    node = node.child;
                    continue;
                }
                if (node === currentParent) {
                    return ret;
                }
                while(!node.sibling){
                    if (!node.return || node.return === currentParent) {
                        return ret;
                    }
                    node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
            }
        }
        function validateClassInstance(inst, methodName) {
            if (!inst) {
                // This is probably too relaxed but it's existing behavior.
                return;
            }
            if (get(inst)) {
                // This is a public instance indeed.
                return;
            }
            var received;
            var stringified = String(inst);
            if (isArray(inst)) {
                received = 'an array';
            } else if (inst && inst.nodeType === ELEMENT_NODE && inst.tagName) {
                received = 'a DOM node';
            } else if (stringified === '[object Object]') {
                received = 'object with keys {' + Object.keys(inst).join(', ') + '}';
            } else {
                received = stringified;
            }
            throw new Error(methodName + "(...): the first argument must be a React class instance. " + ("Instead received: " + received + "."));
        }
        /**
 * Utilities for making it easy to test React components.
 *
 * See https://reactjs.org/docs/test-utils.html
 *
 * Todo: Support the entire DOM.scry query syntax. For now, these simple
 * utilities will suffice for testing purposes.
 * @lends ReactTestUtils
 */ var didWarnAboutReactTestUtilsDeprecation = false;
        function renderIntoDocument(element) {
            {
                if (!didWarnAboutReactTestUtilsDeprecation) {
                    didWarnAboutReactTestUtilsDeprecation = true;
                    error('ReactDOMTestUtils is deprecated and will be removed in a future ' + 'major release, because it exposes internal implementation details ' + 'that are highly likely to change between releases. Upgrade to a ' + 'modern testing library, such as @testing-library/react. See ' + 'https://react.dev/warnings/react-dom-test-utils for more info.');
                }
            }
            var div = document.createElement('div'); // None of our tests actually require attaching the container to the
            // DOM, and doing so creates a mess that we rely on test isolation to
            // clean up, so we're going to stop honoring the name of this method
            // (and probably rename it eventually) if no problems arise.
            // document.documentElement.appendChild(div);
            return ReactDOM.render(element, div);
        }
        function isElement(element) {
            return React.isValidElement(element);
        }
        function isElementOfType(inst, convenienceConstructor) {
            return React.isValidElement(inst) && inst.type === convenienceConstructor;
        }
        function isDOMComponent(inst) {
            return !!(inst && inst.nodeType === ELEMENT_NODE && inst.tagName);
        }
        function isDOMComponentElement(inst) {
            return !!(inst && React.isValidElement(inst) && !!inst.tagName);
        }
        function isCompositeComponent(inst) {
            if (isDOMComponent(inst)) {
                // Accessing inst.setState warns; just return false as that'll be what
                // this returns when we have DOM nodes as refs directly
                return false;
            }
            return inst != null && typeof inst.render === 'function' && typeof inst.setState === 'function';
        }
        function isCompositeComponentWithType(inst, type) {
            if (!isCompositeComponent(inst)) {
                return false;
            }
            var internalInstance = get(inst);
            var constructor = internalInstance.type;
            return constructor === type;
        }
        function findAllInRenderedTree(inst, test) {
            validateClassInstance(inst, 'findAllInRenderedTree');
            if (!inst) {
                return [];
            }
            var internalInstance = get(inst);
            return findAllInRenderedFiberTreeInternal(internalInstance, test);
        }
        /**
 * Finds all instances of components in the rendered tree that are DOM
 * components with the class name matching `className`.
 * @return {array} an array of all the matches.
 */ function scryRenderedDOMComponentsWithClass(root, classNames) {
            validateClassInstance(root, 'scryRenderedDOMComponentsWithClass');
            return findAllInRenderedTree(root, function(inst) {
                if (isDOMComponent(inst)) {
                    var className = inst.className;
                    if (typeof className !== 'string') {
                        // SVG, probably.
                        className = inst.getAttribute('class') || '';
                    }
                    var classList = className.split(/\s+/);
                    if (!isArray(classNames)) {
                        if (classNames === undefined) {
                            throw new Error('TestUtils.scryRenderedDOMComponentsWithClass expects a ' + 'className as a second argument.');
                        }
                        classNames = classNames.split(/\s+/);
                    }
                    return classNames.every(function(name) {
                        return classList.indexOf(name) !== -1;
                    });
                }
                return false;
            });
        }
        /**
 * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
 * and returns that one result, or throws exception if there is any other
 * number of matches besides one.
 * @return {!ReactDOMComponent} The one match.
 */ function findRenderedDOMComponentWithClass(root, className) {
            validateClassInstance(root, 'findRenderedDOMComponentWithClass');
            var all = scryRenderedDOMComponentsWithClass(root, className);
            if (all.length !== 1) {
                throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for class:' + className);
            }
            return all[0];
        }
        /**
 * Finds all instances of components in the rendered tree that are DOM
 * components with the tag name matching `tagName`.
 * @return {array} an array of all the matches.
 */ function scryRenderedDOMComponentsWithTag(root, tagName) {
            validateClassInstance(root, 'scryRenderedDOMComponentsWithTag');
            return findAllInRenderedTree(root, function(inst) {
                return isDOMComponent(inst) && inst.tagName.toUpperCase() === tagName.toUpperCase();
            });
        }
        /**
 * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
 * and returns that one result, or throws exception if there is any other
 * number of matches besides one.
 * @return {!ReactDOMComponent} The one match.
 */ function findRenderedDOMComponentWithTag(root, tagName) {
            validateClassInstance(root, 'findRenderedDOMComponentWithTag');
            var all = scryRenderedDOMComponentsWithTag(root, tagName);
            if (all.length !== 1) {
                throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for tag:' + tagName);
            }
            return all[0];
        }
        /**
 * Finds all instances of components with type equal to `componentType`.
 * @return {array} an array of all the matches.
 */ function scryRenderedComponentsWithType(root, componentType) {
            validateClassInstance(root, 'scryRenderedComponentsWithType');
            return findAllInRenderedTree(root, function(inst) {
                return isCompositeComponentWithType(inst, componentType);
            });
        }
        /**
 * Same as `scryRenderedComponentsWithType` but expects there to be one result
 * and returns that one result, or throws exception if there is any other
 * number of matches besides one.
 * @return {!ReactComponent} The one match.
 */ function findRenderedComponentWithType(root, componentType) {
            validateClassInstance(root, 'findRenderedComponentWithType');
            var all = scryRenderedComponentsWithType(root, componentType);
            if (all.length !== 1) {
                throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for componentType:' + componentType);
            }
            return all[0];
        }
        /**
 * Pass a mocked component module to this method to augment it with
 * useful methods that allow it to be used as a dummy React component.
 * Instead of rendering as usual, the component will become a simple
 * <div> containing any provided children.
 *
 * @param {object} module the mock function object exported from a
 *                        module that defines the component to be mocked
 * @param {?string} mockTagName optional dummy root tag name to return
 *                              from render method (overrides
 *                              module.mockTagName if provided)
 * @return {object} the ReactTestUtils object (for chaining)
 */ function mockComponent(module, mockTagName) {
            {
                if (!hasWarnedAboutDeprecatedMockComponent) {
                    hasWarnedAboutDeprecatedMockComponent = true;
                    warn('ReactTestUtils.mockComponent() is deprecated. ' + 'Use shallow rendering or jest.mock() instead.\n\n' + 'See https://reactjs.org/link/test-utils-mock-component for more information.');
                }
            }
            mockTagName = mockTagName || module.mockTagName || 'div';
            module.prototype.render.mockImplementation(function() {
                return React.createElement(mockTagName, null, this.props.children);
            });
            return this;
        }
        function nativeTouchData(x, y) {
            return {
                touches: [
                    {
                        pageX: x,
                        pageY: y
                    }
                ]
            };
        } // Start of inline: the below functions were inlined from
        // EventPropagator.js, as they deviated from ReactDOM's newer
        // implementations.
        /**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */ function executeDispatch(event, listener, inst) {
            var type = event.type || 'unknown-event';
            event.currentTarget = getNodeFromInstance(inst);
            invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
            event.currentTarget = null;
        }
        /**
 * Standard/simple iteration through an event's collected dispatches.
 */ function executeDispatchesInOrder(event) {
            var dispatchListeners = event._dispatchListeners;
            var dispatchInstances = event._dispatchInstances;
            if (isArray(dispatchListeners)) {
                for(var i = 0; i < dispatchListeners.length; i++){
                    if (event.isPropagationStopped()) {
                        break;
                    } // Listeners and Instances are two parallel arrays that are always in sync.
                    executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
                }
            } else if (dispatchListeners) {
                executeDispatch(event, dispatchListeners, dispatchInstances);
            }
            event._dispatchListeners = null;
            event._dispatchInstances = null;
        }
        /**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @private
 */ var executeDispatchesAndRelease = function(event) {
            if (event) {
                executeDispatchesInOrder(event);
                if (!event.isPersistent()) {
                    event.constructor.release(event);
                }
            }
        };
        function isInteractive(tag) {
            return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
        }
        function getParent(inst) {
            do {
                inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
            // That is depending on if we want nested subtrees (layers) to bubble
            // events to their parent. We could also go through parentNode on the
            // host node but that wouldn't work for React Native and doesn't let us
            // do the portal feature.
            }while (inst && inst.tag !== HostComponent)
            if (inst) {
                return inst;
            }
            return null;
        }
        /**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */ function traverseTwoPhase(inst, fn, arg) {
            var path = [];
            while(inst){
                path.push(inst);
                inst = getParent(inst);
            }
            var i;
            for(i = path.length; i-- > 0;){
                fn(path[i], 'captured', arg);
            }
            for(i = 0; i < path.length; i++){
                fn(path[i], 'bubbled', arg);
            }
        }
        function shouldPreventMouseEvent(name, type, props) {
            switch(name){
                case 'onClick':
                case 'onClickCapture':
                case 'onDoubleClick':
                case 'onDoubleClickCapture':
                case 'onMouseDown':
                case 'onMouseDownCapture':
                case 'onMouseMove':
                case 'onMouseMoveCapture':
                case 'onMouseUp':
                case 'onMouseUpCapture':
                case 'onMouseEnter':
                    return !!(props.disabled && isInteractive(type));
                default:
                    return false;
            }
        }
        /**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */ function getListener(inst, registrationName) {
            // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
            // live here; needs to be moved to a better place soon
            var stateNode = inst.stateNode;
            if (!stateNode) {
                // Work in progress (ex: onload events in incremental mode).
                return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (!props) {
                // Work in progress.
                return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
                return null;
            }
            if (listener && typeof listener !== 'function') {
                throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
        }
        function listenerAtPhase(inst, event, propagationPhase) {
            var registrationName = event._reactName;
            if (propagationPhase === 'captured') {
                registrationName += 'Capture';
            }
            return getListener(inst, registrationName);
        }
        function accumulateDispatches(inst, ignoredDirection, event) {
            if (inst && event && event._reactName) {
                var registrationName = event._reactName;
                var listener = getListener(inst, registrationName);
                if (listener) {
                    if (event._dispatchListeners == null) {
                        event._dispatchListeners = [];
                    }
                    if (event._dispatchInstances == null) {
                        event._dispatchInstances = [];
                    }
                    event._dispatchListeners.push(listener);
                    event._dispatchInstances.push(inst);
                }
            }
        }
        function accumulateDirectionalDispatches(inst, phase, event) {
            {
                if (!inst) {
                    error('Dispatching inst must not be null');
                }
            }
            var listener = listenerAtPhase(inst, event, phase);
            if (listener) {
                if (event._dispatchListeners == null) {
                    event._dispatchListeners = [];
                }
                if (event._dispatchInstances == null) {
                    event._dispatchInstances = [];
                }
                event._dispatchListeners.push(listener);
                event._dispatchInstances.push(inst);
            }
        }
        function accumulateDirectDispatchesSingle(event) {
            if (event && event._reactName) {
                accumulateDispatches(event._targetInst, null, event);
            }
        }
        function accumulateTwoPhaseDispatchesSingle(event) {
            if (event && event._reactName) {
                traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
            }
        } // End of inline
        var Simulate = {};
        var directDispatchEventTypes = new Set([
            'mouseEnter',
            'mouseLeave',
            'pointerEnter',
            'pointerLeave'
        ]);
        /**
 * Exports:
 *
 * - `Simulate.click(Element)`
 * - `Simulate.mouseMove(Element)`
 * - `Simulate.change(Element)`
 * - ... (All keys from event plugin `eventTypes` objects)
 */ function makeSimulator(eventType) {
            return function(domNode, eventData) {
                if (React.isValidElement(domNode)) {
                    throw new Error('TestUtils.Simulate expected a DOM node as the first argument but received ' + 'a React element. Pass the DOM node you wish to simulate the event on instead. ' + 'Note that TestUtils.Simulate will not work if you are using shallow rendering.');
                }
                if (isCompositeComponent(domNode)) {
                    throw new Error('TestUtils.Simulate expected a DOM node as the first argument but received ' + 'a component instance. Pass the DOM node you wish to simulate the event on instead.');
                }
                var reactName = 'on' + eventType[0].toUpperCase() + eventType.slice(1);
                var fakeNativeEvent = new Event();
                fakeNativeEvent.target = domNode;
                fakeNativeEvent.type = eventType.toLowerCase();
                var targetInst = getInstanceFromNode(domNode);
                var event = new SyntheticEvent(reactName, fakeNativeEvent.type, targetInst, fakeNativeEvent, domNode); // Since we aren't using pooling, always persist the event. This will make
                // sure it's marked and won't warn when setting additional properties.
                event.persist();
                assign(event, eventData);
                if (directDispatchEventTypes.has(eventType)) {
                    accumulateDirectDispatchesSingle(event);
                } else {
                    accumulateTwoPhaseDispatchesSingle(event);
                }
                ReactDOM.unstable_batchedUpdates(function() {
                    // Normally extractEvent enqueues a state restore, but we'll just always
                    // do that since we're by-passing it here.
                    enqueueStateRestore(domNode);
                    executeDispatchesAndRelease(event);
                    rethrowCaughtError();
                });
                restoreStateIfNeeded();
            };
        } // A one-time snapshot with no plans to update. We'll probably want to deprecate Simulate API.
        var simulatedEventTypes = [
            'blur',
            'cancel',
            'click',
            'close',
            'contextMenu',
            'copy',
            'cut',
            'auxClick',
            'doubleClick',
            'dragEnd',
            'dragStart',
            'drop',
            'focus',
            'input',
            'invalid',
            'keyDown',
            'keyPress',
            'keyUp',
            'mouseDown',
            'mouseUp',
            'paste',
            'pause',
            'play',
            'pointerCancel',
            'pointerDown',
            'pointerUp',
            'rateChange',
            'reset',
            'resize',
            'seeked',
            'submit',
            'touchCancel',
            'touchEnd',
            'touchStart',
            'volumeChange',
            'drag',
            'dragEnter',
            'dragExit',
            'dragLeave',
            'dragOver',
            'mouseMove',
            'mouseOut',
            'mouseOver',
            'pointerMove',
            'pointerOut',
            'pointerOver',
            'scroll',
            'toggle',
            'touchMove',
            'wheel',
            'abort',
            'animationEnd',
            'animationIteration',
            'animationStart',
            'canPlay',
            'canPlayThrough',
            'durationChange',
            'emptied',
            'encrypted',
            'ended',
            'error',
            'gotPointerCapture',
            'load',
            'loadedData',
            'loadedMetadata',
            'loadStart',
            'lostPointerCapture',
            'playing',
            'progress',
            'seeking',
            'stalled',
            'suspend',
            'timeUpdate',
            'transitionEnd',
            'waiting',
            'mouseEnter',
            'mouseLeave',
            'pointerEnter',
            'pointerLeave',
            'change',
            'select',
            'beforeInput',
            'compositionEnd',
            'compositionStart',
            'compositionUpdate'
        ];
        function buildSimulators() {
            simulatedEventTypes.forEach(function(eventType) {
                Simulate[eventType] = makeSimulator(eventType);
            });
        }
        buildSimulators();
        var didWarnAboutUsingAct = false;
        var act = function actWithWarning(callback) {
            {
                if (!didWarnAboutUsingAct) {
                    didWarnAboutUsingAct = true;
                    error('`ReactDOMTestUtils.act` is deprecated in favor of `React.act`. ' + 'Import `act` from `react` instead of `react-dom/test-utils`. ' + 'See https://react.dev/warnings/react-dom-test-utils for more info.');
                }
            }
            return reactAct(callback);
        };
        exports.Simulate = Simulate;
        exports.act = act;
        exports.findAllInRenderedTree = findAllInRenderedTree;
        exports.findRenderedComponentWithType = findRenderedComponentWithType;
        exports.findRenderedDOMComponentWithClass = findRenderedDOMComponentWithClass;
        exports.findRenderedDOMComponentWithTag = findRenderedDOMComponentWithTag;
        exports.isCompositeComponent = isCompositeComponent;
        exports.isCompositeComponentWithType = isCompositeComponentWithType;
        exports.isDOMComponent = isDOMComponent;
        exports.isDOMComponentElement = isDOMComponentElement;
        exports.isElement = isElement;
        exports.isElementOfType = isElementOfType;
        exports.mockComponent = mockComponent;
        exports.nativeTouchData = nativeTouchData;
        exports.renderIntoDocument = renderIntoDocument;
        exports.scryRenderedComponentsWithType = scryRenderedComponentsWithType;
        exports.scryRenderedDOMComponentsWithClass = scryRenderedDOMComponentsWithClass;
        exports.scryRenderedDOMComponentsWithTag = scryRenderedDOMComponentsWithTag;
        exports.traverseTwoPhase = traverseTwoPhase;
    })();
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95dXN1a2V0c3Vub2RhL0RvY3VtZW50cy9jdXJzb3IvcHB0dHJhbnNsYXRvcmFwcC9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tdGVzdC11dGlscy5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20tdGVzdC11dGlscy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cblxudmFyIEZ1bmN0aW9uQ29tcG9uZW50ID0gMDtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDE7XG5cbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxuXG52YXIgSG9zdENvbXBvbmVudCA9IDU7XG52YXIgSG9zdFRleHQgPSA2O1xuXG4vLyBEb24ndCBjaGFuZ2UgdGhlc2UgdHdvIHZhbHVlcy4gVGhleSdyZSB1c2VkIGJ5IFJlYWN0IERldiBUb29scy5cbnZhciBOb0ZsYWdzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xuXG52YXIgUGxhY2VtZW50ID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBIeWRyYXRpbmcgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG40MDk2O1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbmZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgdmFyIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG5cbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgdmFyIG5leHROb2RlID0gbm9kZTtcblxuICAgIGRvIHtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcblxuICAgICAgaWYgKChub2RlLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcbiAgICAgICAgLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbiAgICAgICAgLy8gaWYgdGhhdCBvbmUgaXMgc3RpbGwgbW91bnRlZC5cbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmV4dE5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChuZXh0Tm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIG5lYXJlc3RNb3VudGVkO1xuICB9IC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gZmliZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmaWJlcjtcbiAgfSAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuXG5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuXG4gICAgaWYgKHBhcmVudEEgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcblxuICAgIGlmIChwYXJlbnRCID09PSBudWxsKSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBhbHRlcm5hdGUuIFRoaXMgaXMgYW4gdW51c3VhbCBjYXNlLiBDdXJyZW50bHksIGl0IG9ubHlcbiAgICAgIC8vIGhhcHBlbnMgd2hlbiBhIFN1c3BlbnNlIGNvbXBvbmVudCBpcyBoaWRkZW4uIEFuIGV4dHJhIGZyYWdtZW50IGZpYmVyXG4gICAgICAvLyBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIHRoZSBTdXNwZW5zZSBmaWJlciBhbmQgaXRzIGNoaWxkcmVuLiBTa2lwXG4gICAgICAvLyBvdmVyIHRoaXMgZXh0cmEgZnJhZ21lbnQgZmliZXIgYW5kIHByb2NlZWQgdG8gdGhlIG5leHQgcGFyZW50LlxuICAgICAgdmFyIG5leHRQYXJlbnQgPSBwYXJlbnRBLnJldHVybjtcblxuICAgICAgaWYgKG5leHRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYSA9IGIgPSBuZXh0UGFyZW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuXG5cbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuXG5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfSAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnICcgKyAnaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGEuYWx0ZXJuYXRlICE9PSBiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFwiICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9IC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cblxuXG4gIGlmIChhLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgfVxuXG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfSAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG5cblxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7IC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cblxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH0gLy8gSUUgYW5kIEVkZ2UgKG9uIFdpbmRvd3MpIGFuZCBDaHJvbWUgLyBTYWZhcmkgKG9uIFdpbmRvd3MgYW5kIExpbnV4KVxuICAvLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG5cblxuICBpZiAoY2hhckNvZGUgPT09IDEwKSB7XG4gICAgY2hhckNvZGUgPSAxMztcbiAgfSAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cblxuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGEgZmFjdG9yeSBzbyB0aGF0IHdlIGhhdmUgZGlmZmVyZW50IHJldHVybmVkIGNvbnN0cnVjdG9ycy5cbi8vIElmIHdlIGhhZCBhIHNpbmdsZSBjb25zdHJ1Y3RvciwgaXQgd291bGQgYmUgbWVnYW1vcnBoaWMgYW5kIGVuZ2luZXMgd291bGQgZGVvcHQuXG5cblxuZnVuY3Rpb24gY3JlYXRlU3ludGhldGljRXZlbnQoSW50ZXJmYWNlKSB7XG4gIC8qKlxuICAgKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gICAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gICAqXG4gICAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gICAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICAgKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gICAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gICAqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAgICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAgICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICAgKi9cbiAgZnVuY3Rpb24gU3ludGhldGljQmFzZUV2ZW50KHJlYWN0TmFtZSwgcmVhY3RFdmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHRoaXMuX3JlYWN0TmFtZSA9IHJlYWN0TmFtZTtcbiAgICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICB0aGlzLnR5cGUgPSByZWFjdEV2ZW50VHlwZTtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtfcHJvcE5hbWVdO1xuXG4gICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW19wcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtfcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcblxuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYXNzaWduKFN5bnRoZXRpY0Jhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gJEZsb3dGaXhNZSAtIGZsb3cgaXMgbm90IGF3YXJlIG9mIGB1bmtub3duYCBpbiBJRVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gJEZsb3dGaXhNZSAtIGZsb3cgaXMgbm90IGF3YXJlIG9mIGB1bmtub3duYCBpbiBJRVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICovXG4gICAgcGVyc2lzdDogZnVuY3Rpb24gKCkgey8vIE1vZGVybiBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNQZXJzaXN0ZW50OiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZVxuICB9KTtcbiAgcmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDtcbn1cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGV2ZW50UGhhc2U6IDAsXG4gIGJ1YmJsZXM6IDAsXG4gIGNhbmNlbGFibGU6IDAsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiAwLFxuICBpc1RydXN0ZWQ6IDBcbn07XG52YXIgU3ludGhldGljRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChFdmVudEludGVyZmFjZSk7XG5cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICB2aWV3OiAwLFxuICBkZXRhaWw6IDBcbn0pO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFVJRXZlbnRJbnRlcmZhY2UpO1xudmFyIGxhc3RNb3ZlbWVudFg7XG52YXIgbGFzdE1vdmVtZW50WTtcbnZhciBsYXN0TW91c2VFdmVudDtcblxuZnVuY3Rpb24gdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICE9PSBsYXN0TW91c2VFdmVudCkge1xuICAgIGlmIChsYXN0TW91c2VFdmVudCAmJiBldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgbGFzdE1vdmVtZW50WCA9IGV2ZW50LnNjcmVlblggLSBsYXN0TW91c2VFdmVudC5zY3JlZW5YO1xuICAgICAgbGFzdE1vdmVtZW50WSA9IGV2ZW50LnNjcmVlblkgLSBsYXN0TW91c2VFdmVudC5zY3JlZW5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0TW92ZW1lbnRYID0gMDtcbiAgICAgIGxhc3RNb3ZlbWVudFkgPSAwO1xuICAgIH1cblxuICAgIGxhc3RNb3VzZUV2ZW50ID0gZXZlbnQ7XG4gIH1cbn1cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHNjcmVlblg6IDAsXG4gIHNjcmVlblk6IDAsXG4gIGNsaWVudFg6IDAsXG4gIGNsaWVudFk6IDAsXG4gIHBhZ2VYOiAwLFxuICBwYWdlWTogMCxcbiAgY3RybEtleTogMCxcbiAgc2hpZnRLZXk6IDAsXG4gIGFsdEtleTogMCxcbiAgbWV0YUtleTogMCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IDAsXG4gIGJ1dHRvbnM6IDAsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ID09PSB1bmRlZmluZWQpIHJldHVybiBldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50O1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICB9LFxuICBtb3ZlbWVudFg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICgnbW92ZW1lbnRYJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50Lm1vdmVtZW50WDtcbiAgICB9XG5cbiAgICB1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZShldmVudCk7XG4gICAgcmV0dXJuIGxhc3RNb3ZlbWVudFg7XG4gIH0sXG4gIG1vdmVtZW50WTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFknIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRZO1xuICAgIH0gLy8gRG9uJ3QgbmVlZCB0byBjYWxsIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKCkgaGVyZVxuICAgIC8vIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIHRvIGhhdmUgYWxyZWFkeSBydW4gd2hlbiBtb3ZlbWVudFhcbiAgICAvLyB3YXMgY29waWVkLlxuXG5cbiAgICByZXR1cm4gbGFzdE1vdmVtZW50WTtcbiAgfVxufSk7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoTW91c2VFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIGRhdGFUcmFuc2ZlcjogMFxufSk7XG5cbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChEcmFnRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHJlbGF0ZWRUYXJnZXQ6IDBcbn0pO1xuXG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG5cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgYW5pbWF0aW9uTmFtZTogMCxcbiAgZWxhcHNlZFRpbWU6IDAsXG4gIHBzZXVkb0VsZW1lbnQ6IDBcbn0pO1xuXG52YXIgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cblxudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cblxudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGRhdGE6IDBcbn0pO1xuXG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuXG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9IC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cblxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7IC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTsgLy8gT2xkZXIgYnJvd3NlcnMgKFNhZmFyaSA8PSAxMCwgaU9TIFNhZmFyaSA8PSAxMC4yKSBkbyBub3Qgc3VwcG9ydFxuLy8gZ2V0TW9kaWZpZXJTdGF0ZS4gSWYgZ2V0TW9kaWZpZXJTdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLCB3ZSBtYXAgaXQgdG8gYSBzZXQgb2Zcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQuIEluIHRoaXMgY2FzZSwgTG9jay1rZXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcblxuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cblxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBjb2RlOiAwLFxuICBsb2NhdGlvbjogMCxcbiAgY3RybEtleTogMCxcbiAgc2hpZnRLZXk6IDAsXG4gIGFsdEtleTogMCxcbiAgbWV0YUtleTogMCxcbiAgcmVwZWF0OiAwLFxuICBsb2NhbGU6IDAsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBQb2ludGVyRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAqL1xuXG52YXIgUG9pbnRlckV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIHBvaW50ZXJJZDogMCxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgcHJlc3N1cmU6IDAsXG4gIHRhbmdlbnRpYWxQcmVzc3VyZTogMCxcbiAgdGlsdFg6IDAsXG4gIHRpbHRZOiAwLFxuICB0d2lzdDogMCxcbiAgcG9pbnRlclR5cGU6IDAsXG4gIGlzUHJpbWFyeTogMFxufSk7XG5cbnZhciBTeW50aGV0aWNQb2ludGVyRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChQb2ludGVyRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG5cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHRvdWNoZXM6IDAsXG4gIHRhcmdldFRvdWNoZXM6IDAsXG4gIGNoYW5nZWRUb3VjaGVzOiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn0pO1xuXG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xuXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBwcm9wZXJ0eU5hbWU6IDAsXG4gIGVsYXBzZWRUaW1lOiAwLFxuICBwc2V1ZG9FbGVtZW50OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiAwLFxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogMFxufSk7XG5cbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2Q7XG5cbntcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW5pbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4gIC8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuICAgIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBmdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgLy8gSWYgZG9jdW1lbnQgZG9lc24ndCBleGlzdCB3ZSBrbm93IGZvciBzdXJlIHdlIHdpbGwgY3Jhc2ggaW4gdGhpcyBtZXRob2RcbiAgICAgIC8vIHdoZW4gd2UgY2FsbCBkb2N1bWVudC5jcmVhdGVFdmVudCgpLiBIb3dldmVyIHRoaXMgY2FuIGNhdXNlIGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvMzQ4MlxuICAgICAgLy8gU28gd2UgcHJlZW1wdGl2ZWx5IHRocm93IHdpdGggYSBiZXR0ZXIgbWVzc2FnZSBpbnN0ZWFkLlxuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgZG9jdW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGRvY3VtZW50YCBnbG9iYWwgd2FzIGRlZmluZWQgd2hlbiBSZWFjdCB3YXMgaW5pdGlhbGl6ZWQsIGJ1dCBpcyBub3QgJyArICdkZWZpbmVkIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIHRlc3QgZW52aXJvbm1lbnQgaWYgYSBjb21wb25lbnQgJyArICdzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgJyArICdmaW5pc2hlZCBydW5uaW5nLiBUbyBzb2x2ZSB0aGlzLCB5b3UgY2FuIGVpdGhlciB1bm1vdW50IHRoZSBjb21wb25lbnQgYXQgJyArICd0aGUgZW5kIG9mIHlvdXIgdGVzdCAoYW5kIGVuc3VyZSB0aGF0IGFueSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBnZXQgJyArICdjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmICcgKyAndG8gYmUgYXN5bmNocm9ub3VzLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICB2YXIgZGlkQ2FsbCA9IGZhbHNlOyAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB2YWx1ZSBvZiB3aW5kb3cuZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVzZXQgaXRcbiAgICAgIC8vIGR1cmluZyB0aGUgY2FsbGJhY2sgdG8gbGV0IHVzZXIgY29kZSBhY2Nlc3Mgd2luZG93LmV2ZW50IGluIHRoZVxuICAgICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LlxuXG4gICAgICB2YXIgd2luZG93RXZlbnQgPSB3aW5kb3cuZXZlbnQ7IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBkZXNjcmlwdG9yIG9mIHdpbmRvdy5ldmVudCB0byByZXN0b3JlIGl0IGFmdGVyIGV2ZW50XG4gICAgICAvLyBkaXNwYXRjaGluZzogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzY4OFxuXG4gICAgICB2YXIgd2luZG93RXZlbnREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3csICdldmVudCcpO1xuXG4gICAgICBmdW5jdGlvbiByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7IC8vIFdlIGNoZWNrIGZvciB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykgdG8gcHJldmVudCB0aGVcbiAgICAgICAgLy8gd2luZG93LmV2ZW50IGFzc2lnbm1lbnQgaW4gYm90aCBJRSA8PSAxMCBhcyB0aGV5IHRocm93IGFuIGVycm9yXG4gICAgICAgIC8vIFwiTWVtYmVyIG5vdCBmb3VuZFwiIGluIHN0cmljdCBtb2RlLCBhbmQgaW4gRmlyZWZveCB3aGljaCBkb2VzIG5vdFxuICAgICAgICAvLyBzdXBwb3J0IHdpbmRvdy5ldmVudC5cblxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5ldmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpKSB7XG4gICAgICAgICAgd2luZG93LmV2ZW50ID0gd2luZG93RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cblxuXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gICAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soKSB7XG4gICAgICAgIGRpZENhbGwgPSB0cnVlO1xuICAgICAgICByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH0gLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cblxuXG4gICAgICB2YXIgZXJyb3I7IC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlV2luZG93RXJyb3IoZXZlbnQpIHtcbiAgICAgICAgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgZGlkU2V0RXJyb3IgPSB0cnVlO1xuXG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBTb21lIG90aGVyIGVycm9yIGhhbmRsZXIgaGFzIHByZXZlbnRlZCBkZWZhdWx0LlxuICAgICAgICAgIC8vIEJyb3dzZXJzIHNpbGVuY2UgdGhlIGVycm9yIHJlcG9ydCBpZiB0aGlzIGhhcHBlbnMuXG4gICAgICAgICAgLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHsvLyBJZ25vcmUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cblxuXG4gICAgICB2YXIgZXZ0VHlwZSA9IFwicmVhY3QtXCIgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7IC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlV2luZG93RXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cblxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAod2luZG93RXZlbnREZXNjcmlwdG9yKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdldmVudCcsIHdpbmRvd0V2ZW50RGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWRDYWxsICYmIGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgfSAvLyBSZW1vdmUgb3VyIGV2ZW50IGxpc3RlbmVyc1xuXG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVdpbmRvd0Vycm9yKTtcblxuICAgICAgaWYgKCFkaWRDYWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHJlYWxseSB3cm9uZywgYW5kIG91ciBldmVudCB3YXMgbm90IGRpc3BhdGNoZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY3MzRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjU4NVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIHByb2R1Y3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIHJldHVybiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxID0gaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbDtcblxudmFyIGhhc0Vycm9yID0gZmFsc2U7XG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsOyAvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxuXG52YXIgaGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG52YXIgcmV0aHJvd0Vycm9yID0gbnVsbDtcbnZhciByZXBvcnRlciA9IHtcbiAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gIH1cbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICogUmV0dXJucyBhbiBlcnJvciBpZiBpdCB0aHJvd3MsIG90aGVyd2lzZSBudWxsLlxuICpcbiAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAqIHVzZSBhIHRyeS1jYXRjaCBkaXJlY3RseSBpcyBzbyB0aGF0IHdlIGNhbiBzd2FwIG91dCBhIGRpZmZlcmVudFxuICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGhhc0Vycm9yID0gZmFsc2U7XG4gIGNhdWdodEVycm9yID0gbnVsbDtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxLmFwcGx5KHJlcG9ydGVyLCBhcmd1bWVudHMpO1xufVxuLyoqXG4gKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAqIFRPRE86IFNlZSBpZiBjYXVnaHRFcnJvciBhbmQgcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICBpZiAoIWhhc1JldGhyb3dFcnJvcikge1xuICAgICAgaGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgIHJldGhyb3dFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAqL1xuXG5mdW5jdGlvbiByZXRocm93Q2F1Z2h0RXJyb3IoKSB7XG4gIGlmIChoYXNSZXRocm93RXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSByZXRocm93RXJyb3I7XG4gICAgaGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbnZhciBTZWNyZXRJbnRlcm5hbHMgPSBSZWFjdERPTS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbnZhciBFdmVudEludGVybmFscyA9IFNlY3JldEludGVybmFscy5FdmVudHM7XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IEV2ZW50SW50ZXJuYWxzWzBdO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBFdmVudEludGVybmFsc1sxXTtcbnZhciBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlID0gRXZlbnRJbnRlcm5hbHNbMl07XG52YXIgZW5xdWV1ZVN0YXRlUmVzdG9yZSA9IEV2ZW50SW50ZXJuYWxzWzNdO1xudmFyIHJlc3RvcmVTdGF0ZUlmTmVlZGVkID0gRXZlbnRJbnRlcm5hbHNbNF07XG52YXIgcmVhY3RBY3QgPSBSZWFjdC51bnN0YWJsZV9hY3Q7XG5cbmZ1bmN0aW9uIEV2ZW50KHN1ZmZpeCkge31cblxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZE1vY2tDb21wb25lbnQgPSBmYWxzZTtcbi8qKlxuICogQGNsYXNzIFJlYWN0VGVzdFV0aWxzXG4gKi9cblxuZnVuY3Rpb24gZmluZEFsbEluUmVuZGVyZWRGaWJlclRyZWVJbnRlcm5hbChmaWJlciwgdGVzdCkge1xuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcik7XG5cbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB2YXIgcmV0ID0gW107XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0IHx8IG5vZGUudGFnID09PSBDbGFzc0NvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gRnVuY3Rpb25Db21wb25lbnQpIHtcbiAgICAgIHZhciBwdWJsaWNJbnN0ID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICh0ZXN0KHB1YmxpY0luc3QpKSB7XG4gICAgICAgIHJldC5wdXNoKHB1YmxpY0luc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNsYXNzSW5zdGFuY2UoaW5zdCwgbWV0aG9kTmFtZSkge1xuICBpZiAoIWluc3QpIHtcbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IHRvbyByZWxheGVkIGJ1dCBpdCdzIGV4aXN0aW5nIGJlaGF2aW9yLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnZXQoaW5zdCkpIHtcbiAgICAvLyBUaGlzIGlzIGEgcHVibGljIGluc3RhbmNlIGluZGVlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVjZWl2ZWQ7XG4gIHZhciBzdHJpbmdpZmllZCA9IFN0cmluZyhpbnN0KTtcblxuICBpZiAoaXNBcnJheShpbnN0KSkge1xuICAgIHJlY2VpdmVkID0gJ2FuIGFycmF5JztcbiAgfSBlbHNlIGlmIChpbnN0ICYmIGluc3Qubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBpbnN0LnRhZ05hbWUpIHtcbiAgICByZWNlaXZlZCA9ICdhIERPTSBub2RlJztcbiAgfSBlbHNlIGlmIChzdHJpbmdpZmllZCA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZWNlaXZlZCA9ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoaW5zdCkuam9pbignLCAnKSArICd9JztcbiAgfSBlbHNlIHtcbiAgICByZWNlaXZlZCA9IHN0cmluZ2lmaWVkO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZE5hbWUgKyBcIiguLi4pOiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGNsYXNzIGluc3RhbmNlLiBcIiArIChcIkluc3RlYWQgcmVjZWl2ZWQ6IFwiICsgcmVjZWl2ZWQgKyBcIi5cIikpO1xufVxuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIG1ha2luZyBpdCBlYXN5IHRvIHRlc3QgUmVhY3QgY29tcG9uZW50cy5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3Rlc3QtdXRpbHMuaHRtbFxuICpcbiAqIFRvZG86IFN1cHBvcnQgdGhlIGVudGlyZSBET00uc2NyeSBxdWVyeSBzeW50YXguIEZvciBub3csIHRoZXNlIHNpbXBsZVxuICogdXRpbGl0aWVzIHdpbGwgc3VmZmljZSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAqIEBsZW5kcyBSZWFjdFRlc3RVdGlsc1xuICovXG5cblxudmFyIGRpZFdhcm5BYm91dFJlYWN0VGVzdFV0aWxzRGVwcmVjYXRpb24gPSBmYWxzZTtcblxuZnVuY3Rpb24gcmVuZGVySW50b0RvY3VtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0UmVhY3RUZXN0VXRpbHNEZXByZWNhdGlvbikge1xuICAgICAgZGlkV2FybkFib3V0UmVhY3RUZXN0VXRpbHNEZXByZWNhdGlvbiA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdSZWFjdERPTVRlc3RVdGlscyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgJyArICdtYWpvciByZWxlYXNlLCBiZWNhdXNlIGl0IGV4cG9zZXMgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gZGV0YWlscyAnICsgJ3RoYXQgYXJlIGhpZ2hseSBsaWtlbHkgdG8gY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuIFVwZ3JhZGUgdG8gYSAnICsgJ21vZGVybiB0ZXN0aW5nIGxpYnJhcnksIHN1Y2ggYXMgQHRlc3RpbmctbGlicmFyeS9yZWFjdC4gU2VlICcgKyAnaHR0cHM6Ly9yZWFjdC5kZXYvd2FybmluZ3MvcmVhY3QtZG9tLXRlc3QtdXRpbHMgZm9yIG1vcmUgaW5mby4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vIE5vbmUgb2Ygb3VyIHRlc3RzIGFjdHVhbGx5IHJlcXVpcmUgYXR0YWNoaW5nIHRoZSBjb250YWluZXIgdG8gdGhlXG4gIC8vIERPTSwgYW5kIGRvaW5nIHNvIGNyZWF0ZXMgYSBtZXNzIHRoYXQgd2UgcmVseSBvbiB0ZXN0IGlzb2xhdGlvbiB0b1xuICAvLyBjbGVhbiB1cCwgc28gd2UncmUgZ29pbmcgdG8gc3RvcCBob25vcmluZyB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZFxuICAvLyAoYW5kIHByb2JhYmx5IHJlbmFtZSBpdCBldmVudHVhbGx5KSBpZiBubyBwcm9ibGVtcyBhcmlzZS5cbiAgLy8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGRpdik7XG5cbiAgcmV0dXJuIFJlYWN0RE9NLnJlbmRlcihlbGVtZW50LCBkaXYpO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudE9mVHlwZShpbnN0LCBjb252ZW5pZW5jZUNvbnN0cnVjdG9yKSB7XG4gIHJldHVybiBSZWFjdC5pc1ZhbGlkRWxlbWVudChpbnN0KSAmJiBpbnN0LnR5cGUgPT09IGNvbnZlbmllbmNlQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIGlzRE9NQ29tcG9uZW50KGluc3QpIHtcbiAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIGluc3QudGFnTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGlzRE9NQ29tcG9uZW50RWxlbWVudChpbnN0KSB7XG4gIHJldHVybiAhIShpbnN0ICYmIFJlYWN0LmlzVmFsaWRFbGVtZW50KGluc3QpICYmICEhaW5zdC50YWdOYW1lKTtcbn1cblxuZnVuY3Rpb24gaXNDb21wb3NpdGVDb21wb25lbnQoaW5zdCkge1xuICBpZiAoaXNET01Db21wb25lbnQoaW5zdCkpIHtcbiAgICAvLyBBY2Nlc3NpbmcgaW5zdC5zZXRTdGF0ZSB3YXJuczsganVzdCByZXR1cm4gZmFsc2UgYXMgdGhhdCdsbCBiZSB3aGF0XG4gICAgLy8gdGhpcyByZXR1cm5zIHdoZW4gd2UgaGF2ZSBET00gbm9kZXMgYXMgcmVmcyBkaXJlY3RseVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpbnN0ICE9IG51bGwgJiYgdHlwZW9mIGluc3QucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0LnNldFN0YXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBvc2l0ZUNvbXBvbmVudFdpdGhUeXBlKGluc3QsIHR5cGUpIHtcbiAgaWYgKCFpc0NvbXBvc2l0ZUNvbXBvbmVudChpbnN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0KGluc3QpO1xuICB2YXIgY29uc3RydWN0b3IgPSBpbnRlcm5hbEluc3RhbmNlLnR5cGU7XG4gIHJldHVybiBjb25zdHJ1Y3RvciA9PT0gdHlwZTtcbn1cblxuZnVuY3Rpb24gZmluZEFsbEluUmVuZGVyZWRUcmVlKGluc3QsIHRlc3QpIHtcbiAgdmFsaWRhdGVDbGFzc0luc3RhbmNlKGluc3QsICdmaW5kQWxsSW5SZW5kZXJlZFRyZWUnKTtcblxuICBpZiAoIWluc3QpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldChpbnN0KTtcbiAgcmV0dXJuIGZpbmRBbGxJblJlbmRlcmVkRmliZXJUcmVlSW50ZXJuYWwoaW50ZXJuYWxJbnN0YW5jZSwgdGVzdCk7XG59XG4vKipcbiAqIEZpbmRzIGFsbCBpbnN0YW5jZXMgb2YgY29tcG9uZW50cyBpbiB0aGUgcmVuZGVyZWQgdHJlZSB0aGF0IGFyZSBET01cbiAqIGNvbXBvbmVudHMgd2l0aCB0aGUgY2xhc3MgbmFtZSBtYXRjaGluZyBgY2xhc3NOYW1lYC5cbiAqIEByZXR1cm4ge2FycmF5fSBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzKHJvb3QsIGNsYXNzTmFtZXMpIHtcbiAgdmFsaWRhdGVDbGFzc0luc3RhbmNlKHJvb3QsICdzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzJyk7XG4gIHJldHVybiBmaW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24gKGluc3QpIHtcbiAgICBpZiAoaXNET01Db21wb25lbnQoaW5zdCkpIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSBpbnN0LmNsYXNzTmFtZTtcblxuICAgICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFNWRywgcHJvYmFibHkuXG4gICAgICAgIGNsYXNzTmFtZSA9IGluc3QuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xhc3NMaXN0ID0gY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgIGlmICghaXNBcnJheShjbGFzc05hbWVzKSkge1xuICAgICAgICBpZiAoY2xhc3NOYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0VXRpbHMuc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhDbGFzcyBleHBlY3RzIGEgJyArICdjbGFzc05hbWUgYXMgYSBzZWNvbmQgYXJndW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xhc3NOYW1lcy5ldmVyeShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gY2xhc3NMaXN0LmluZGV4T2YobmFtZSkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cbi8qKlxuICogTGlrZSBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHQsXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9uZSByZXN1bHQsIG9yIHRocm93cyBleGNlcHRpb24gaWYgdGhlcmUgaXMgYW55IG90aGVyXG4gKiBudW1iZXIgb2YgbWF0Y2hlcyBiZXNpZGVzIG9uZS5cbiAqIEByZXR1cm4geyFSZWFjdERPTUNvbXBvbmVudH0gVGhlIG9uZSBtYXRjaC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhDbGFzcyhyb290LCBjbGFzc05hbWUpIHtcbiAgdmFsaWRhdGVDbGFzc0luc3RhbmNlKHJvb3QsICdmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoQ2xhc3MnKTtcbiAgdmFyIGFsbCA9IHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3Mocm9vdCwgY2xhc3NOYW1lKTtcblxuICBpZiAoYWxsLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBmaW5kIGV4YWN0bHkgb25lIG1hdGNoIChmb3VuZDogJyArIGFsbC5sZW5ndGggKyAnKSAnICsgJ2ZvciBjbGFzczonICsgY2xhc3NOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBhbGxbMF07XG59XG4vKipcbiAqIEZpbmRzIGFsbCBpbnN0YW5jZXMgb2YgY29tcG9uZW50cyBpbiB0aGUgcmVuZGVyZWQgdHJlZSB0aGF0IGFyZSBET01cbiAqIGNvbXBvbmVudHMgd2l0aCB0aGUgdGFnIG5hbWUgbWF0Y2hpbmcgYHRhZ05hbWVgLlxuICogQHJldHVybiB7YXJyYXl9IGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnKHJvb3QsIHRhZ05hbWUpIHtcbiAgdmFsaWRhdGVDbGFzc0luc3RhbmNlKHJvb3QsICdzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aFRhZycpO1xuICByZXR1cm4gZmluZEFsbEluUmVuZGVyZWRUcmVlKHJvb3QsIGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIGlzRE9NQ29tcG9uZW50KGluc3QpICYmIGluc3QudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSB0YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuLyoqXG4gKiBMaWtlIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHQsXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9uZSByZXN1bHQsIG9yIHRocm93cyBleGNlcHRpb24gaWYgdGhlcmUgaXMgYW55IG90aGVyXG4gKiBudW1iZXIgb2YgbWF0Y2hlcyBiZXNpZGVzIG9uZS5cbiAqIEByZXR1cm4geyFSZWFjdERPTUNvbXBvbmVudH0gVGhlIG9uZSBtYXRjaC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhUYWcocm9vdCwgdGFnTmFtZSkge1xuICB2YWxpZGF0ZUNsYXNzSW5zdGFuY2Uocm9vdCwgJ2ZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhUYWcnKTtcbiAgdmFyIGFsbCA9IHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnKHJvb3QsIHRhZ05hbWUpO1xuXG4gIGlmIChhbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGZpbmQgZXhhY3RseSBvbmUgbWF0Y2ggKGZvdW5kOiAnICsgYWxsLmxlbmd0aCArICcpICcgKyAnZm9yIHRhZzonICsgdGFnTmFtZSk7XG4gIH1cblxuICByZXR1cm4gYWxsWzBdO1xufVxuLyoqXG4gKiBGaW5kcyBhbGwgaW5zdGFuY2VzIG9mIGNvbXBvbmVudHMgd2l0aCB0eXBlIGVxdWFsIHRvIGBjb21wb25lbnRUeXBlYC5cbiAqIEByZXR1cm4ge2FycmF5fSBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGUocm9vdCwgY29tcG9uZW50VHlwZSkge1xuICB2YWxpZGF0ZUNsYXNzSW5zdGFuY2Uocm9vdCwgJ3NjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZScpO1xuICByZXR1cm4gZmluZEFsbEluUmVuZGVyZWRUcmVlKHJvb3QsIGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIGlzQ29tcG9zaXRlQ29tcG9uZW50V2l0aFR5cGUoaW5zdCwgY29tcG9uZW50VHlwZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBTYW1lIGFzIGBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGVgIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHRcbiAqIGFuZCByZXR1cm5zIHRoYXQgb25lIHJlc3VsdCwgb3IgdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbnkgb3RoZXJcbiAqIG51bWJlciBvZiBtYXRjaGVzIGJlc2lkZXMgb25lLlxuICogQHJldHVybiB7IVJlYWN0Q29tcG9uZW50fSBUaGUgb25lIG1hdGNoLlxuICovXG5cblxuZnVuY3Rpb24gZmluZFJlbmRlcmVkQ29tcG9uZW50V2l0aFR5cGUocm9vdCwgY29tcG9uZW50VHlwZSkge1xuICB2YWxpZGF0ZUNsYXNzSW5zdGFuY2Uocm9vdCwgJ2ZpbmRSZW5kZXJlZENvbXBvbmVudFdpdGhUeXBlJyk7XG4gIHZhciBhbGwgPSBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGUocm9vdCwgY29tcG9uZW50VHlwZSk7XG5cbiAgaWYgKGFsbC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBleGFjdGx5IG9uZSBtYXRjaCAoZm91bmQ6ICcgKyBhbGwubGVuZ3RoICsgJykgJyArICdmb3IgY29tcG9uZW50VHlwZTonICsgY29tcG9uZW50VHlwZSk7XG4gIH1cblxuICByZXR1cm4gYWxsWzBdO1xufVxuLyoqXG4gKiBQYXNzIGEgbW9ja2VkIGNvbXBvbmVudCBtb2R1bGUgdG8gdGhpcyBtZXRob2QgdG8gYXVnbWVudCBpdCB3aXRoXG4gKiB1c2VmdWwgbWV0aG9kcyB0aGF0IGFsbG93IGl0IHRvIGJlIHVzZWQgYXMgYSBkdW1teSBSZWFjdCBjb21wb25lbnQuXG4gKiBJbnN0ZWFkIG9mIHJlbmRlcmluZyBhcyB1c3VhbCwgdGhlIGNvbXBvbmVudCB3aWxsIGJlY29tZSBhIHNpbXBsZVxuICogPGRpdj4gY29udGFpbmluZyBhbnkgcHJvdmlkZWQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1vZHVsZSB0aGUgbW9jayBmdW5jdGlvbiBvYmplY3QgZXhwb3J0ZWQgZnJvbSBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSB0aGF0IGRlZmluZXMgdGhlIGNvbXBvbmVudCB0byBiZSBtb2NrZWRcbiAqIEBwYXJhbSB7P3N0cmluZ30gbW9ja1RhZ05hbWUgb3B0aW9uYWwgZHVtbXkgcm9vdCB0YWcgbmFtZSB0byByZXR1cm5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSByZW5kZXIgbWV0aG9kIChvdmVycmlkZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLm1vY2tUYWdOYW1lIGlmIHByb3ZpZGVkKVxuICogQHJldHVybiB7b2JqZWN0fSB0aGUgUmVhY3RUZXN0VXRpbHMgb2JqZWN0IChmb3IgY2hhaW5pbmcpXG4gKi9cblxuXG5mdW5jdGlvbiBtb2NrQ29tcG9uZW50KG1vZHVsZSwgbW9ja1RhZ05hbWUpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkTW9ja0NvbXBvbmVudCkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkTW9ja0NvbXBvbmVudCA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0VGVzdFV0aWxzLm1vY2tDb21wb25lbnQoKSBpcyBkZXByZWNhdGVkLiAnICsgJ1VzZSBzaGFsbG93IHJlbmRlcmluZyBvciBqZXN0Lm1vY2soKSBpbnN0ZWFkLlxcblxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay90ZXN0LXV0aWxzLW1vY2stY29tcG9uZW50IGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgIH1cbiAgfVxuXG4gIG1vY2tUYWdOYW1lID0gbW9ja1RhZ05hbWUgfHwgbW9kdWxlLm1vY2tUYWdOYW1lIHx8ICdkaXYnO1xuICBtb2R1bGUucHJvdG90eXBlLnJlbmRlci5tb2NrSW1wbGVtZW50YXRpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KG1vY2tUYWdOYW1lLCBudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBuYXRpdmVUb3VjaERhdGEoeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHRvdWNoZXM6IFt7XG4gICAgICBwYWdlWDogeCxcbiAgICAgIHBhZ2VZOiB5XG4gICAgfV1cbiAgfTtcbn0gLy8gU3RhcnQgb2YgaW5saW5lOiB0aGUgYmVsb3cgZnVuY3Rpb25zIHdlcmUgaW5saW5lZCBmcm9tXG4vLyBFdmVudFByb3BhZ2F0b3IuanMsIGFzIHRoZXkgZGV2aWF0ZWQgZnJvbSBSZWFjdERPTSdzIG5ld2VyXG4vLyBpbXBsZW1lbnRhdGlvbnMuXG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICBpZiAoaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG5cblxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuXG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG59XG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmIChldmVudCkge1xuICAgIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0LnJldHVybjsgLy8gVE9ETzogSWYgdGhpcyBpcyBhIEhvc3RSb290IHdlIG1pZ2h0IHdhbnQgdG8gYmFpbCBvdXQuXG4gICAgLy8gVGhhdCBpcyBkZXBlbmRpbmcgb24gaWYgd2Ugd2FudCBuZXN0ZWQgc3VidHJlZXMgKGxheWVycykgdG8gYnViYmxlXG4gICAgLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4gICAgLy8gaG9zdCBub2RlIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBhbmQgZG9lc24ndCBsZXQgdXNcbiAgICAvLyBkbyB0aGUgcG9ydGFsIGZlYXR1cmUuXG4gIH0gd2hpbGUgKGluc3QgJiYgaW5zdC50YWcgIT09IEhvc3RDb21wb25lbnQpO1xuXG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5cblxuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG5cbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuXG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhbaV0sICdjYXB0dXJlZCcsIGFyZyk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZUVudGVyJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcbiAgLy8gbGl2ZSBoZXJlOyBuZWVkcyB0byBiZSBtb3ZlZCB0byBhIGJldHRlciBwbGFjZSBzb29uXG4gIHZhciBzdGF0ZU5vZGUgPSBpbnN0LnN0YXRlTm9kZTtcblxuICBpZiAoIXN0YXRlTm9kZSkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuXG4gIGlmICghcHJvcHMpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobGlzdGVuZXIgJiYgdHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYFwiICsgcmVnaXN0cmF0aW9uTmFtZSArIFwiYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGBcIiArIHR5cGVvZiBsaXN0ZW5lciArIFwiYCB0eXBlLlwiKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuX3JlYWN0TmFtZTtcblxuICBpZiAocHJvcGFnYXRpb25QaGFzZSA9PT0gJ2NhcHR1cmVkJykge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWUgKz0gJ0NhcHR1cmUnO1xuICB9XG5cbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5fcmVhY3ROYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5fcmVhY3ROYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBpZiAoZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID09IG51bGwpIHtcbiAgICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPT0gbnVsbCkge1xuICAgICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMucHVzaChpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAge1xuICAgIGlmICghaW5zdCkge1xuICAgICAgZXJyb3IoJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuXG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGlmIChldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPT0gbnVsbCkge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gW107XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9PSBudWxsKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBbXTtcbiAgICB9XG5cbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMucHVzaChpbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuX3JlYWN0TmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuX3JlYWN0TmFtZSkge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufSAvLyBFbmQgb2YgaW5saW5lXG5cblxudmFyIFNpbXVsYXRlID0ge307XG52YXIgZGlyZWN0RGlzcGF0Y2hFdmVudFR5cGVzID0gbmV3IFNldChbJ21vdXNlRW50ZXInLCAnbW91c2VMZWF2ZScsICdwb2ludGVyRW50ZXInLCAncG9pbnRlckxlYXZlJ10pO1xuLyoqXG4gKiBFeHBvcnRzOlxuICpcbiAqIC0gYFNpbXVsYXRlLmNsaWNrKEVsZW1lbnQpYFxuICogLSBgU2ltdWxhdGUubW91c2VNb3ZlKEVsZW1lbnQpYFxuICogLSBgU2ltdWxhdGUuY2hhbmdlKEVsZW1lbnQpYFxuICogLSAuLi4gKEFsbCBrZXlzIGZyb20gZXZlbnQgcGx1Z2luIGBldmVudFR5cGVzYCBvYmplY3RzKVxuICovXG5cbmZ1bmN0aW9uIG1ha2VTaW11bGF0b3IoZXZlbnRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9tTm9kZSwgZXZlbnREYXRhKSB7XG4gICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3RVdGlscy5TaW11bGF0ZSBleHBlY3RlZCBhIERPTSBub2RlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBidXQgcmVjZWl2ZWQgJyArICdhIFJlYWN0IGVsZW1lbnQuIFBhc3MgdGhlIERPTSBub2RlIHlvdSB3aXNoIHRvIHNpbXVsYXRlIHRoZSBldmVudCBvbiBpbnN0ZWFkLiAnICsgJ05vdGUgdGhhdCBUZXN0VXRpbHMuU2ltdWxhdGUgd2lsbCBub3Qgd29yayBpZiB5b3UgYXJlIHVzaW5nIHNoYWxsb3cgcmVuZGVyaW5nLicpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBvc2l0ZUNvbXBvbmVudChkb21Ob2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0VXRpbHMuU2ltdWxhdGUgZXhwZWN0ZWQgYSBET00gbm9kZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYnV0IHJlY2VpdmVkICcgKyAnYSBjb21wb25lbnQgaW5zdGFuY2UuIFBhc3MgdGhlIERPTSBub2RlIHlvdSB3aXNoIHRvIHNpbXVsYXRlIHRoZSBldmVudCBvbiBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIHZhciByZWFjdE5hbWUgPSAnb24nICsgZXZlbnRUeXBlWzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudFR5cGUuc2xpY2UoMSk7XG4gICAgdmFyIGZha2VOYXRpdmVFdmVudCA9IG5ldyBFdmVudCgpO1xuICAgIGZha2VOYXRpdmVFdmVudC50YXJnZXQgPSBkb21Ob2RlO1xuICAgIGZha2VOYXRpdmVFdmVudC50eXBlID0gZXZlbnRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHRhcmdldEluc3QgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGRvbU5vZGUpO1xuICAgIHZhciBldmVudCA9IG5ldyBTeW50aGV0aWNFdmVudChyZWFjdE5hbWUsIGZha2VOYXRpdmVFdmVudC50eXBlLCB0YXJnZXRJbnN0LCBmYWtlTmF0aXZlRXZlbnQsIGRvbU5vZGUpOyAvLyBTaW5jZSB3ZSBhcmVuJ3QgdXNpbmcgcG9vbGluZywgYWx3YXlzIHBlcnNpc3QgdGhlIGV2ZW50LiBUaGlzIHdpbGwgbWFrZVxuICAgIC8vIHN1cmUgaXQncyBtYXJrZWQgYW5kIHdvbid0IHdhcm4gd2hlbiBzZXR0aW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcy5cblxuICAgIGV2ZW50LnBlcnNpc3QoKTtcbiAgICBhc3NpZ24oZXZlbnQsIGV2ZW50RGF0YSk7XG5cbiAgICBpZiAoZGlyZWN0RGlzcGF0Y2hFdmVudFR5cGVzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpO1xuICAgIH1cblxuICAgIFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIE5vcm1hbGx5IGV4dHJhY3RFdmVudCBlbnF1ZXVlcyBhIHN0YXRlIHJlc3RvcmUsIGJ1dCB3ZSdsbCBqdXN0IGFsd2F5c1xuICAgICAgLy8gZG8gdGhhdCBzaW5jZSB3ZSdyZSBieS1wYXNzaW5nIGl0IGhlcmUuXG4gICAgICBlbnF1ZXVlU3RhdGVSZXN0b3JlKGRvbU5vZGUpO1xuICAgICAgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGV2ZW50KTtcbiAgICAgIHJldGhyb3dDYXVnaHRFcnJvcigpO1xuICAgIH0pO1xuICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gIH07XG59IC8vIEEgb25lLXRpbWUgc25hcHNob3Qgd2l0aCBubyBwbGFucyB0byB1cGRhdGUuIFdlJ2xsIHByb2JhYmx5IHdhbnQgdG8gZGVwcmVjYXRlIFNpbXVsYXRlIEFQSS5cblxuXG52YXIgc2ltdWxhdGVkRXZlbnRUeXBlcyA9IFsnYmx1cicsICdjYW5jZWwnLCAnY2xpY2snLCAnY2xvc2UnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnYXV4Q2xpY2snLCAnZG91YmxlQ2xpY2snLCAnZHJhZ0VuZCcsICdkcmFnU3RhcnQnLCAnZHJvcCcsICdmb2N1cycsICdpbnB1dCcsICdpbnZhbGlkJywgJ2tleURvd24nLCAna2V5UHJlc3MnLCAna2V5VXAnLCAnbW91c2VEb3duJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwb2ludGVyQ2FuY2VsJywgJ3BvaW50ZXJEb3duJywgJ3BvaW50ZXJVcCcsICdyYXRlQ2hhbmdlJywgJ3Jlc2V0JywgJ3Jlc2l6ZScsICdzZWVrZWQnLCAnc3VibWl0JywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoRW5kJywgJ3RvdWNoU3RhcnQnLCAndm9sdW1lQ2hhbmdlJywgJ2RyYWcnLCAnZHJhZ0VudGVyJywgJ2RyYWdFeGl0JywgJ2RyYWdMZWF2ZScsICdkcmFnT3ZlcicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ3BvaW50ZXJNb3ZlJywgJ3BvaW50ZXJPdXQnLCAncG9pbnRlck92ZXInLCAnc2Nyb2xsJywgJ3RvZ2dsZScsICd0b3VjaE1vdmUnLCAnd2hlZWwnLCAnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2dvdFBvaW50ZXJDYXB0dXJlJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbG9zdFBvaW50ZXJDYXB0dXJlJywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAnc2Vla2luZycsICdzdGFsbGVkJywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0cmFuc2l0aW9uRW5kJywgJ3dhaXRpbmcnLCAnbW91c2VFbnRlcicsICdtb3VzZUxlYXZlJywgJ3BvaW50ZXJFbnRlcicsICdwb2ludGVyTGVhdmUnLCAnY2hhbmdlJywgJ3NlbGVjdCcsICdiZWZvcmVJbnB1dCcsICdjb21wb3NpdGlvbkVuZCcsICdjb21wb3NpdGlvblN0YXJ0JywgJ2NvbXBvc2l0aW9uVXBkYXRlJ107XG5cbmZ1bmN0aW9uIGJ1aWxkU2ltdWxhdG9ycygpIHtcbiAgc2ltdWxhdGVkRXZlbnRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICBTaW11bGF0ZVtldmVudFR5cGVdID0gbWFrZVNpbXVsYXRvcihldmVudFR5cGUpO1xuICB9KTtcbn1cblxuYnVpbGRTaW11bGF0b3JzKCk7XG52YXIgZGlkV2FybkFib3V0VXNpbmdBY3QgPSBmYWxzZTtcbnZhciBhY3QgPSAgZnVuY3Rpb24gYWN0V2l0aFdhcm5pbmcoY2FsbGJhY2spIHtcbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0VXNpbmdBY3QpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVzaW5nQWN0ID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ2BSZWFjdERPTVRlc3RVdGlscy5hY3RgIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgYFJlYWN0LmFjdGAuICcgKyAnSW1wb3J0IGBhY3RgIGZyb20gYHJlYWN0YCBpbnN0ZWFkIG9mIGByZWFjdC1kb20vdGVzdC11dGlsc2AuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L3dhcm5pbmdzL3JlYWN0LWRvbS10ZXN0LXV0aWxzIGZvciBtb3JlIGluZm8uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWN0QWN0KGNhbGxiYWNrKTtcbn0gO1xuXG5leHBvcnRzLlNpbXVsYXRlID0gU2ltdWxhdGU7XG5leHBvcnRzLmFjdCA9IGFjdDtcbmV4cG9ydHMuZmluZEFsbEluUmVuZGVyZWRUcmVlID0gZmluZEFsbEluUmVuZGVyZWRUcmVlO1xuZXhwb3J0cy5maW5kUmVuZGVyZWRDb21wb25lbnRXaXRoVHlwZSA9IGZpbmRSZW5kZXJlZENvbXBvbmVudFdpdGhUeXBlO1xuZXhwb3J0cy5maW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoQ2xhc3MgPSBmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoQ2xhc3M7XG5leHBvcnRzLmZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhUYWcgPSBmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoVGFnO1xuZXhwb3J0cy5pc0NvbXBvc2l0ZUNvbXBvbmVudCA9IGlzQ29tcG9zaXRlQ29tcG9uZW50O1xuZXhwb3J0cy5pc0NvbXBvc2l0ZUNvbXBvbmVudFdpdGhUeXBlID0gaXNDb21wb3NpdGVDb21wb25lbnRXaXRoVHlwZTtcbmV4cG9ydHMuaXNET01Db21wb25lbnQgPSBpc0RPTUNvbXBvbmVudDtcbmV4cG9ydHMuaXNET01Db21wb25lbnRFbGVtZW50ID0gaXNET01Db21wb25lbnRFbGVtZW50O1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRWxlbWVudE9mVHlwZSA9IGlzRWxlbWVudE9mVHlwZTtcbmV4cG9ydHMubW9ja0NvbXBvbmVudCA9IG1vY2tDb21wb25lbnQ7XG5leHBvcnRzLm5hdGl2ZVRvdWNoRGF0YSA9IG5hdGl2ZVRvdWNoRGF0YTtcbmV4cG9ydHMucmVuZGVySW50b0RvY3VtZW50ID0gcmVuZGVySW50b0RvY3VtZW50O1xuZXhwb3J0cy5zY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGUgPSBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGU7XG5leHBvcnRzLnNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3MgPSBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzO1xuZXhwb3J0cy5zY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aFRhZyA9IHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnO1xuZXhwb3J0cy50cmF2ZXJzZVR3b1BoYXNlID0gdHJhdmVyc2VUd29QaGFzZTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJSZWFjdCIsInJlcXVpcmUiLCJSZWFjdERPTSIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJwcmludFdhcm5pbmciLCJlcnJvciIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiZ2V0Iiwia2V5IiwiX3JlYWN0SW50ZXJuYWxzIiwiRnVuY3Rpb25Db21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiTm9GbGFncyIsIlBsYWNlbWVudCIsIkh5ZHJhdGluZyIsIlJlYWN0Q3VycmVudE93bmVyIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsImZpYmVyIiwibm9kZSIsIm5lYXJlc3RNb3VudGVkIiwiYWx0ZXJuYXRlIiwibmV4dE5vZGUiLCJmbGFncyIsInJldHVybiIsInRhZyIsImFzc2VydElzTW91bnRlZCIsIkVycm9yIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJhIiwiYiIsInBhcmVudEEiLCJwYXJlbnRCIiwibmV4dFBhcmVudCIsImNoaWxkIiwic2libGluZyIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsInN0YXRlTm9kZSIsImN1cnJlbnQiLCJhc3NpZ24iLCJPYmplY3QiLCJnZXRFdmVudENoYXJDb2RlIiwibmF0aXZlRXZlbnQiLCJjaGFyQ29kZSIsImtleUNvZGUiLCJmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSIsImZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSIsImNyZWF0ZVN5bnRoZXRpY0V2ZW50IiwiSW50ZXJmYWNlIiwiU3ludGhldGljQmFzZUV2ZW50IiwicmVhY3ROYW1lIiwicmVhY3RFdmVudFR5cGUiLCJ0YXJnZXRJbnN0IiwibmF0aXZlRXZlbnRUYXJnZXQiLCJfcmVhY3ROYW1lIiwiX3RhcmdldEluc3QiLCJ0eXBlIiwidGFyZ2V0IiwiY3VycmVudFRhcmdldCIsIl9wcm9wTmFtZSIsImhhc093blByb3BlcnR5Iiwibm9ybWFsaXplIiwiZGVmYXVsdFByZXZlbnRlZCIsInJldHVyblZhbHVlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50RGVmYXVsdCIsImV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsImlzUGVyc2lzdGVudCIsIkV2ZW50SW50ZXJmYWNlIiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiRGF0ZSIsIm5vdyIsImlzVHJ1c3RlZCIsIlN5bnRoZXRpY0V2ZW50IiwiVUlFdmVudEludGVyZmFjZSIsInZpZXciLCJkZXRhaWwiLCJTeW50aGV0aWNVSUV2ZW50IiwibGFzdE1vdmVtZW50WCIsImxhc3RNb3ZlbWVudFkiLCJsYXN0TW91c2VFdmVudCIsInVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlIiwic2NyZWVuWCIsInNjcmVlblkiLCJNb3VzZUV2ZW50SW50ZXJmYWNlIiwiY2xpZW50WCIsImNsaWVudFkiLCJwYWdlWCIsInBhZ2VZIiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwibWV0YUtleSIsImdldE1vZGlmaWVyU3RhdGUiLCJnZXRFdmVudE1vZGlmaWVyU3RhdGUiLCJidXR0b24iLCJidXR0b25zIiwicmVsYXRlZFRhcmdldCIsInVuZGVmaW5lZCIsImZyb21FbGVtZW50Iiwic3JjRWxlbWVudCIsInRvRWxlbWVudCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRm9jdXNFdmVudCIsIkFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlIiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIlN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwid2luZG93IiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiZGF0YSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJub3JtYWxpemVLZXkiLCJFc2MiLCJTcGFjZWJhciIsIkxlZnQiLCJVcCIsIlJpZ2h0IiwiRG93biIsIkRlbCIsIldpbiIsIk1lbnUiLCJBcHBzIiwiU2Nyb2xsIiwiTW96UHJpbnRhYmxlS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJnZXRFdmVudEtleSIsImZyb21DaGFyQ29kZSIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwiQWx0IiwiQ29udHJvbCIsIk1ldGEiLCJTaGlmdCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJLZXlib2FyZEV2ZW50SW50ZXJmYWNlIiwiY29kZSIsImxvY2F0aW9uIiwicmVwZWF0IiwibG9jYWxlIiwid2hpY2giLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiUG9pbnRlckV2ZW50SW50ZXJmYWNlIiwicG9pbnRlcklkIiwid2lkdGgiLCJoZWlnaHQiLCJwcmVzc3VyZSIsInRhbmdlbnRpYWxQcmVzc3VyZSIsInRpbHRYIiwidGlsdFkiLCJ0d2lzdCIsInBvaW50ZXJUeXBlIiwiaXNQcmltYXJ5IiwiU3ludGhldGljUG9pbnRlckV2ZW50IiwiVG91Y2hFdmVudEludGVyZmFjZSIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwiVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlIiwicHJvcGVydHlOYW1lIiwiU3ludGhldGljVHJhbnNpdGlvbkV2ZW50IiwiV2hlZWxFdmVudEludGVyZmFjZSIsImRlbHRhWCIsIndoZWVsRGVsdGFYIiwiZGVsdGFZIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhIiwiZGVsdGFaIiwiZGVsdGFNb2RlIiwiU3ludGhldGljV2hlZWxFdmVudCIsIkVMRU1FTlRfTk9ERSIsImludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QiLCJuYW1lIiwiZnVuYyIsImNvbnRleHQiLCJjIiwiZCIsImUiLCJmIiwiZnVuY0FyZ3MiLCJzbGljZSIsIm9uRXJyb3IiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsIiwiZGlzcGF0Y2hFdmVudCIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJmYWtlTm9kZSIsImNyZWF0ZUVsZW1lbnQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYiLCJldnQiLCJkaWRDYWxsIiwiZGlkRXJyb3IiLCJ3aW5kb3dFdmVudCIsIndpbmRvd0V2ZW50RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInJlc3RvcmVBZnRlckRpc3BhdGNoIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2dFR5cGUiLCJjYWxsQ2FsbGJhY2siLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsImhhbmRsZVdpbmRvd0Vycm9yIiwiY29sbm8iLCJsaW5lbm8iLCJfc3VwcHJlc3NMb2dnaW5nIiwiaW5uZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdEV2ZW50IiwiZGVmaW5lUHJvcGVydHkiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEiLCJoYXNFcnJvciIsImNhdWdodEVycm9yIiwiaGFzUmV0aHJvd0Vycm9yIiwicmV0aHJvd0Vycm9yIiwicmVwb3J0ZXIiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IiLCJjbGVhckNhdWdodEVycm9yIiwicmV0aHJvd0NhdWdodEVycm9yIiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiU2VjcmV0SW50ZXJuYWxzIiwiRXZlbnRJbnRlcm5hbHMiLCJFdmVudHMiLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSIsImdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUiLCJlbnF1ZXVlU3RhdGVSZXN0b3JlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJyZWFjdEFjdCIsInVuc3RhYmxlX2FjdCIsIkV2ZW50Iiwic3VmZml4IiwiaGFzV2FybmVkQWJvdXREZXByZWNhdGVkTW9ja0NvbXBvbmVudCIsImZpbmRBbGxJblJlbmRlcmVkRmliZXJUcmVlSW50ZXJuYWwiLCJ0ZXN0IiwiY3VycmVudFBhcmVudCIsInJldCIsInB1YmxpY0luc3QiLCJwdXNoIiwidmFsaWRhdGVDbGFzc0luc3RhbmNlIiwiaW5zdCIsIm1ldGhvZE5hbWUiLCJyZWNlaXZlZCIsInN0cmluZ2lmaWVkIiwibm9kZVR5cGUiLCJ0YWdOYW1lIiwia2V5cyIsImpvaW4iLCJkaWRXYXJuQWJvdXRSZWFjdFRlc3RVdGlsc0RlcHJlY2F0aW9uIiwicmVuZGVySW50b0RvY3VtZW50IiwiZWxlbWVudCIsImRpdiIsInJlbmRlciIsImlzRWxlbWVudCIsImlzVmFsaWRFbGVtZW50IiwiaXNFbGVtZW50T2ZUeXBlIiwiY29udmVuaWVuY2VDb25zdHJ1Y3RvciIsImlzRE9NQ29tcG9uZW50IiwiaXNET01Db21wb25lbnRFbGVtZW50IiwiaXNDb21wb3NpdGVDb21wb25lbnQiLCJzZXRTdGF0ZSIsImlzQ29tcG9zaXRlQ29tcG9uZW50V2l0aFR5cGUiLCJpbnRlcm5hbEluc3RhbmNlIiwiY29uc3RydWN0b3IiLCJmaW5kQWxsSW5SZW5kZXJlZFRyZWUiLCJzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzIiwicm9vdCIsImNsYXNzTmFtZXMiLCJjbGFzc05hbWUiLCJnZXRBdHRyaWJ1dGUiLCJjbGFzc0xpc3QiLCJzcGxpdCIsImV2ZXJ5IiwiaW5kZXhPZiIsImZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhDbGFzcyIsImFsbCIsInNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnIiwidG9VcHBlckNhc2UiLCJmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoVGFnIiwic2NyeVJlbmRlcmVkQ29tcG9uZW50c1dpdGhUeXBlIiwiY29tcG9uZW50VHlwZSIsImZpbmRSZW5kZXJlZENvbXBvbmVudFdpdGhUeXBlIiwibW9ja0NvbXBvbmVudCIsIm1vZHVsZSIsIm1vY2tUYWdOYW1lIiwibW9ja0ltcGxlbWVudGF0aW9uIiwicHJvcHMiLCJjaGlsZHJlbiIsIm5hdGl2ZVRvdWNoRGF0YSIsIngiLCJ5IiwiZXhlY3V0ZURpc3BhdGNoIiwibGlzdGVuZXIiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIiLCJkaXNwYXRjaExpc3RlbmVycyIsIl9kaXNwYXRjaExpc3RlbmVycyIsImRpc3BhdGNoSW5zdGFuY2VzIiwiX2Rpc3BhdGNoSW5zdGFuY2VzIiwiaSIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSIsInJlbGVhc2UiLCJpc0ludGVyYWN0aXZlIiwiZ2V0UGFyZW50IiwidHJhdmVyc2VUd29QaGFzZSIsImZuIiwiYXJnIiwicGF0aCIsInNob3VsZFByZXZlbnRNb3VzZUV2ZW50IiwiZGlzYWJsZWQiLCJnZXRMaXN0ZW5lciIsInJlZ2lzdHJhdGlvbk5hbWUiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwiYWNjdW11bGF0ZURpc3BhdGNoZXMiLCJpZ25vcmVkRGlyZWN0aW9uIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInBoYXNlIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlIiwiU2ltdWxhdGUiLCJkaXJlY3REaXNwYXRjaEV2ZW50VHlwZXMiLCJTZXQiLCJtYWtlU2ltdWxhdG9yIiwiZXZlbnRUeXBlIiwiZG9tTm9kZSIsImV2ZW50RGF0YSIsImZha2VOYXRpdmVFdmVudCIsInRvTG93ZXJDYXNlIiwiaGFzIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJzaW11bGF0ZWRFdmVudFR5cGVzIiwiYnVpbGRTaW11bGF0b3JzIiwiZm9yRWFjaCIsImRpZFdhcm5BYm91dFVzaW5nQWN0IiwiYWN0IiwiYWN0V2l0aFdhcm5pbmciLCJjYWxsYmFjayIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxjQUFjO0lBQ3hDLENBQUE7UUFDSDtRQUVBLElBQUlDLFFBQVFDLFFBQVE7UUFDcEIsSUFBSUMsV0FBV0QsUUFBUTtR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