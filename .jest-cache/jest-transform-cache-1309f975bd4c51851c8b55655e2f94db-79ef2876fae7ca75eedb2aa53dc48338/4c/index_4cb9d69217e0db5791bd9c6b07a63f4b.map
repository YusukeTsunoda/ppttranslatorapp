{"version":3,"sources":["/Users/yusuketsunoda/Documents/cursor/ppttranslatorapp/node_modules/side-channel-list/index.js"],"sourcesContent":["'use strict';\n\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\n\n/*\n* This function traverses the list returning the node corresponding to the given key.\n*\n* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.\n* By doing so, all the recently used nodes can be accessed relatively quickly.\n*/\n/** @type {import('./list.d.ts').listGetNode} */\n// eslint-disable-next-line consistent-return\nvar listGetNode = function (list, key, isDelete) {\n\t/** @type {typeof list | NonNullable<(typeof list)['next']>} */\n\tvar prev = list;\n\t/** @type {(typeof list)['next']} */\n\tvar curr;\n\t// eslint-disable-next-line eqeqeq\n\tfor (; (curr = prev.next) != null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tif (!isDelete) {\n\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\tcurr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);\n\t\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\t}\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\n/** @type {import('./list.d.ts').listGet} */\nvar listGet = function (objects, key) {\n\tif (!objects) {\n\t\treturn void undefined;\n\t}\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\n/** @type {import('./list.d.ts').listSet} */\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t});\n\t}\n};\n/** @type {import('./list.d.ts').listHas} */\nvar listHas = function (objects, key) {\n\tif (!objects) {\n\t\treturn false;\n\t}\n\treturn !!listGetNode(objects, key);\n};\n/** @type {import('./list.d.ts').listDelete} */\n// eslint-disable-next-line consistent-return\nvar listDelete = function (objects, key) {\n\tif (objects) {\n\t\treturn listGetNode(objects, key, true);\n\t}\n};\n\n/** @type {import('.')} */\nmodule.exports = function getSideChannelList() {\n\t/** @typedef {ReturnType<typeof getSideChannelList>} Channel */\n\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\tvar root = $o && $o.next;\n\t\t\tvar deletedNode = listDelete($o, key);\n\t\t\tif (deletedNode && root && root === deletedNode) {\n\t\t\t\t$o = void undefined;\n\t\t\t}\n\t\t\treturn !!deletedNode;\n\t\t},\n\t\tget: function (key) {\n\t\t\treturn listGet($o, key);\n\t\t},\n\t\thas: function (key) {\n\t\t\treturn listHas($o, key);\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$o) {\n\t\t\t\t// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head\n\t\t\t\t$o = {\n\t\t\t\t\tnext: void undefined\n\t\t\t\t};\n\t\t\t}\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\tlistSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);\n\t\t}\n\t};\n\t// @ts-expect-error TODO: figure out why this is erroring\n\treturn channel;\n};\n"],"names":["inspect","require","$TypeError","listGetNode","list","key","isDelete","prev","curr","next","listGet","objects","undefined","node","value","listSet","listHas","listDelete","module","exports","getSideChannelList","$o","channel","assert","has","root","deletedNode","get","set"],"mappings":"AAAA;AAEA,IAAIA,UAAUC,QAAQ;AAEtB,IAAIC,aAAaD,QAAQ;AAEzB;;;;;AAKA,GACA,8CAA8C,GAC9C,6CAA6C;AAC7C,IAAIE,cAAc,SAAUC,IAAI,EAAEC,GAAG,EAAEC,QAAQ;IAC9C,6DAA6D,GAC7D,IAAIC,OAAOH;IACX,kCAAkC,GAClC,IAAII;IACJ,kCAAkC;IAClC,MAAO,AAACA,CAAAA,OAAOD,KAAKE,IAAI,AAAD,KAAM,MAAMF,OAAOC,KAAM;QAC/C,IAAIA,KAAKH,GAAG,KAAKA,KAAK;YACrBE,KAAKE,IAAI,GAAGD,KAAKC,IAAI;YACrB,IAAI,CAACH,UAAU;gBACd,2CAA2C;gBAC3CE,KAAKC,IAAI,GAAG,0CAA0C,GAAIL,KAAKK,IAAI;gBACnEL,KAAKK,IAAI,GAAGD,MAAM,wCAAwC;YAC3D;YACA,OAAOA;QACR;IACD;AACD;AAEA,0CAA0C,GAC1C,IAAIE,UAAU,SAAUC,OAAO,EAAEN,GAAG;IACnC,IAAI,CAACM,SAAS;QACb,OAAO,KAAKC;IACb;IACA,IAAIC,OAAOV,YAAYQ,SAASN;IAChC,OAAOQ,QAAQA,KAAKC,KAAK;AAC1B;AACA,0CAA0C,GAC1C,IAAIC,UAAU,SAAUJ,OAAO,EAAEN,GAAG,EAAES,KAAK;IAC1C,IAAID,OAAOV,YAAYQ,SAASN;IAChC,IAAIQ,MAAM;QACTA,KAAKC,KAAK,GAAGA;IACd,OAAO;QACN,oDAAoD;QACpDH,QAAQF,IAAI,GAAG,qEAAqE,GAAI;YACvFJ,KAAKA;YACLI,MAAME,QAAQF,IAAI;YAClBK,OAAOA;QACR;IACD;AACD;AACA,0CAA0C,GAC1C,IAAIE,UAAU,SAAUL,OAAO,EAAEN,GAAG;IACnC,IAAI,CAACM,SAAS;QACb,OAAO;IACR;IACA,OAAO,CAAC,CAACR,YAAYQ,SAASN;AAC/B;AACA,6CAA6C,GAC7C,6CAA6C;AAC7C,IAAIY,aAAa,SAAUN,OAAO,EAAEN,GAAG;IACtC,IAAIM,SAAS;QACZ,OAAOR,YAAYQ,SAASN,KAAK;IAClC;AACD;AAEA,wBAAwB,GACxBa,OAAOC,OAAO,GAAG,SAASC;IACzB,6DAA6D,GAC7D,+CAA+C,GAC/C,+CAA+C,GAE/C,6DAA6D,GAAG,IAAIC;IAEpE,oBAAoB,GACpB,IAAIC,UAAU;QACbC,QAAQ,SAAUlB,GAAG;YACpB,IAAI,CAACiB,QAAQE,GAAG,CAACnB,MAAM;gBACtB,MAAM,IAAIH,WAAW,mCAAmCF,QAAQK;YACjE;QACD;QACA,UAAU,SAAUA,GAAG;YACtB,IAAIoB,OAAOJ,MAAMA,GAAGZ,IAAI;YACxB,IAAIiB,cAAcT,WAAWI,IAAIhB;YACjC,IAAIqB,eAAeD,QAAQA,SAASC,aAAa;gBAChDL,KAAK,KAAKT;YACX;YACA,OAAO,CAAC,CAACc;QACV;QACAC,KAAK,SAAUtB,GAAG;YACjB,OAAOK,QAAQW,IAAIhB;QACpB;QACAmB,KAAK,SAAUnB,GAAG;YACjB,OAAOW,QAAQK,IAAIhB;QACpB;QACAuB,KAAK,SAAUvB,GAAG,EAAES,KAAK;YACxB,IAAI,CAACO,IAAI;gBACR,0MAA0M;gBAC1MA,KAAK;oBACJZ,MAAM,KAAKG;gBACZ;YACD;YACA,2CAA2C;YAC3CG,QAAQ,mCAAmC,GAAIM,IAAKhB,KAAKS;QAC1D;IACD;IACA,yDAAyD;IACzD,OAAOQ;AACR"}