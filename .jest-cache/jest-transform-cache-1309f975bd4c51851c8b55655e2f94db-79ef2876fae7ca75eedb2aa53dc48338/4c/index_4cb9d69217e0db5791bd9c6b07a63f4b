254d01d8b9a25ff6bffd5618f920dcd4
'use strict';
var inspect = require('object-inspect');
var $TypeError = require('es-errors/type');
/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/ /** @type {import('./list.d.ts').listGetNode} */ // eslint-disable-next-line consistent-return
var listGetNode = function(list, key, isDelete) {
    /** @type {typeof list | NonNullable<(typeof list)['next']>} */ var prev = list;
    /** @type {(typeof list)['next']} */ var curr;
    // eslint-disable-next-line eqeqeq
    for(; (curr = prev.next) != null; prev = curr){
        if (curr.key === key) {
            prev.next = curr.next;
            if (!isDelete) {
                // eslint-disable-next-line no-extra-parens
                curr.next = /** @type {NonNullable<typeof list.next>} */ list.next;
                list.next = curr; // eslint-disable-line no-param-reassign
            }
            return curr;
        }
    }
};
/** @type {import('./list.d.ts').listGet} */ var listGet = function(objects, key) {
    if (!objects) {
        return void undefined;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */ var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
        node.value = value;
    } else {
        // Prepend the new node to the beginning of the list
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ {
            key: key,
            next: objects.next,
            value: value
        };
    }
};
/** @type {import('./list.d.ts').listHas} */ var listHas = function(objects, key) {
    if (!objects) {
        return false;
    }
    return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */ // eslint-disable-next-line consistent-return
var listDelete = function(objects, key) {
    if (objects) {
        return listGetNode(objects, key, true);
    }
};
/** @type {import('.')} */ module.exports = function getSideChannelList() {
    /** @typedef {ReturnType<typeof getSideChannelList>} Channel */ /** @typedef {Parameters<Channel['get']>[0]} K */ /** @typedef {Parameters<Channel['set']>[1]} V */ /** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            var root = $o && $o.next;
            var deletedNode = listDelete($o, key);
            if (deletedNode && root && root === deletedNode) {
                $o = void undefined;
            }
            return !!deletedNode;
        },
        get: function(key) {
            return listGet($o, key);
        },
        has: function(key) {
            return listHas($o, key);
        },
        set: function(key, value) {
            if (!$o) {
                // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
                $o = {
                    next: void undefined
                };
            }
            // eslint-disable-next-line no-extra-parens
            listSet(/** @type {NonNullable<typeof $o>} */ $o, key, value);
        }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95dXN1a2V0c3Vub2RhL0RvY3VtZW50cy9jdXJzb3IvcHB0dHJhbnNsYXRvcmFwcC9ub2RlX21vZHVsZXMvc2lkZS1jaGFubmVsLWxpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG5cbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcblxuLypcbiogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgdGhlIGxpc3QgcmV0dXJuaW5nIHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGtleS5cbipcbiogVGhhdCBub2RlIGlzIGFsc28gbW92ZWQgdG8gdGhlIGhlYWQgb2YgdGhlIGxpc3QsIHNvIHRoYXQgaWYgaXQncyBhY2Nlc3NlZCBhZ2FpbiB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSB3aG9sZSBsaXN0LlxuKiBCeSBkb2luZyBzbywgYWxsIHRoZSByZWNlbnRseSB1c2VkIG5vZGVzIGNhbiBiZSBhY2Nlc3NlZCByZWxhdGl2ZWx5IHF1aWNrbHkuXG4qL1xuLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGlzdC5kLnRzJykubGlzdEdldE5vZGV9ICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBsaXN0R2V0Tm9kZSA9IGZ1bmN0aW9uIChsaXN0LCBrZXksIGlzRGVsZXRlKSB7XG5cdC8qKiBAdHlwZSB7dHlwZW9mIGxpc3QgfCBOb25OdWxsYWJsZTwodHlwZW9mIGxpc3QpWyduZXh0J10+fSAqL1xuXHR2YXIgcHJldiA9IGxpc3Q7XG5cdC8qKiBAdHlwZSB7KHR5cGVvZiBsaXN0KVsnbmV4dCddfSAqL1xuXHR2YXIgY3Vycjtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRmb3IgKDsgKGN1cnIgPSBwcmV2Lm5leHQpICE9IG51bGw7IHByZXYgPSBjdXJyKSB7XG5cdFx0aWYgKGN1cnIua2V5ID09PSBrZXkpIHtcblx0XHRcdHByZXYubmV4dCA9IGN1cnIubmV4dDtcblx0XHRcdGlmICghaXNEZWxldGUpIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuXHRcdFx0XHRjdXJyLm5leHQgPSAvKiogQHR5cGUge05vbk51bGxhYmxlPHR5cGVvZiBsaXN0Lm5leHQ+fSAqLyAobGlzdC5uZXh0KTtcblx0XHRcdFx0bGlzdC5uZXh0ID0gY3VycjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGN1cnI7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9saXN0LmQudHMnKS5saXN0R2V0fSAqL1xudmFyIGxpc3RHZXQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5KSB7XG5cdGlmICghb2JqZWN0cykge1xuXHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0fVxuXHR2YXIgbm9kZSA9IGxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG5cdHJldHVybiBub2RlICYmIG5vZGUudmFsdWU7XG59O1xuLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGlzdC5kLnRzJykubGlzdFNldH0gKi9cbnZhciBsaXN0U2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSwgdmFsdWUpIHtcblx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRpZiAobm9kZSkge1xuXHRcdG5vZGUudmFsdWUgPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHQvLyBQcmVwZW5kIHRoZSBuZXcgbm9kZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cdFx0b2JqZWN0cy5uZXh0ID0gLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGlzdC5kLnRzJykuTGlzdE5vZGU8dHlwZW9mIHZhbHVlLCB0eXBlb2Yga2V5Pn0gKi8gKHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgbm8tZXh0cmEtcGFyZW5zXG5cdFx0XHRrZXk6IGtleSxcblx0XHRcdG5leHQ6IG9iamVjdHMubmV4dCxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH0pO1xuXHR9XG59O1xuLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGlzdC5kLnRzJykubGlzdEhhc30gKi9cbnZhciBsaXN0SGFzID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHRpZiAoIW9iamVjdHMpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICEhbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcbn07XG4vKiogQHR5cGUge2ltcG9ydCgnLi9saXN0LmQudHMnKS5saXN0RGVsZXRlfSAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgbGlzdERlbGV0ZSA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0aWYgKG9iamVjdHMpIHtcblx0XHRyZXR1cm4gbGlzdEdldE5vZGUob2JqZWN0cywga2V5LCB0cnVlKTtcblx0fVxufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U2lkZUNoYW5uZWxMaXN0KCkge1xuXHQvKiogQHR5cGVkZWYge1JldHVyblR5cGU8dHlwZW9mIGdldFNpZGVDaGFubmVsTGlzdD59IENoYW5uZWwgKi9cblx0LyoqIEB0eXBlZGVmIHtQYXJhbWV0ZXJzPENoYW5uZWxbJ2dldCddPlswXX0gSyAqL1xuXHQvKiogQHR5cGVkZWYge1BhcmFtZXRlcnM8Q2hhbm5lbFsnc2V0J10+WzFdfSBWICovXG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vbGlzdC5kLnRzJykuUm9vdE5vZGU8ViwgSz4gfCB1bmRlZmluZWR9ICovIHZhciAkbztcblxuXHQvKiogQHR5cGUge0NoYW5uZWx9ICovXG5cdHZhciBjaGFubmVsID0ge1xuXHRcdGFzc2VydDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCFjaGFubmVsLmhhcyhrZXkpKSB7XG5cdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdTaWRlIGNoYW5uZWwgZG9lcyBub3QgY29udGFpbiAnICsgaW5zcGVjdChrZXkpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdCdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHR2YXIgcm9vdCA9ICRvICYmICRvLm5leHQ7XG5cdFx0XHR2YXIgZGVsZXRlZE5vZGUgPSBsaXN0RGVsZXRlKCRvLCBrZXkpO1xuXHRcdFx0aWYgKGRlbGV0ZWROb2RlICYmIHJvb3QgJiYgcm9vdCA9PT0gZGVsZXRlZE5vZGUpIHtcblx0XHRcdFx0JG8gPSB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhIWRlbGV0ZWROb2RlO1xuXHRcdH0sXG5cdFx0Z2V0OiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRyZXR1cm4gbGlzdEdldCgkbywga2V5KTtcblx0XHR9LFxuXHRcdGhhczogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0cmV0dXJuIGxpc3RIYXMoJG8sIGtleSk7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAoISRvKSB7XG5cdFx0XHRcdC8vIEluaXRpYWxpemUgdGhlIGxpbmtlZCBsaXN0IGFzIGFuIGVtcHR5IG5vZGUsIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2YgdGhlIGZpcnN0IG5vZGU6IHdlIGNhbiBhbHdheXMgcmVmZXIgdG8gaXQgYXMgKHByZXZpb3VzIG5vZGUpLm5leHQsIGluc3RlYWQgb2Ygc29tZXRoaW5nIGxpa2UgKGxpc3QpLmhlYWRcblx0XHRcdFx0JG8gPSB7XG5cdFx0XHRcdFx0bmV4dDogdm9pZCB1bmRlZmluZWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcblx0XHRcdGxpc3RTZXQoLyoqIEB0eXBlIHtOb25OdWxsYWJsZTx0eXBlb2YgJG8+fSAqLyAoJG8pLCBrZXksIHZhbHVlKTtcblx0XHR9XG5cdH07XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZmlndXJlIG91dCB3aHkgdGhpcyBpcyBlcnJvcmluZ1xuXHRyZXR1cm4gY2hhbm5lbDtcbn07XG4iXSwibmFtZXMiOlsiaW5zcGVjdCIsInJlcXVpcmUiLCIkVHlwZUVycm9yIiwibGlzdEdldE5vZGUiLCJsaXN0Iiwia2V5IiwiaXNEZWxldGUiLCJwcmV2IiwiY3VyciIsIm5leHQiLCJsaXN0R2V0Iiwib2JqZWN0cyIsInVuZGVmaW5lZCIsIm5vZGUiLCJ2YWx1ZSIsImxpc3RTZXQiLCJsaXN0SGFzIiwibGlzdERlbGV0ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJnZXRTaWRlQ2hhbm5lbExpc3QiLCIkbyIsImNoYW5uZWwiLCJhc3NlcnQiLCJoYXMiLCJyb290IiwiZGVsZXRlZE5vZGUiLCJnZXQiLCJzZXQiXSwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsVUFBVUMsUUFBUTtBQUV0QixJQUFJQyxhQUFhRCxRQUFRO0FBRXpCOzs7OztBQUtBLEdBQ0EsOENBQThDLEdBQzlDLDZDQUE2QztBQUM3QyxJQUFJRSxjQUFjLFNBQVVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxRQUFRO0lBQzlDLDZEQUE2RCxHQUM3RCxJQUFJQyxPQUFPSDtJQUNYLGtDQUFrQyxHQUNsQyxJQUFJSTtJQUNKLGtDQUFrQztJQUNsQyxNQUFPLEFBQUNBLENBQUFBLE9BQU9ELEtBQUtFLElBQUksQUFBRCxLQUFNLE1BQU1GLE9BQU9DLEtBQU07UUFDL0MsSUFBSUEsS0FBS0gsR0FBRyxLQUFLQSxLQUFLO1lBQ3JCRSxLQUFLRSxJQUFJLEdBQUdELEtBQUtDLElBQUk7WUFDckIsSUFBSSxDQUFDSCxVQUFVO2dCQUNkLDJDQUEyQztnQkFDM0NFLEtBQUtDLElBQUksR0FBRywwQ0FBMEMsR0FBSUwsS0FBS0ssSUFBSTtnQkFDbkVMLEtBQUtLLElBQUksR0FBR0QsTUFBTSx3Q0FBd0M7WUFDM0Q7WUFDQSxPQUFPQTtRQUNSO0lBQ0Q7QUFDRDtBQUVBLDBDQUEwQyxHQUMxQyxJQUFJRSxVQUFVLFNBQVVDLE9BQU8sRUFBRU4sR0FBRztJQUNuQyxJQUFJLENBQUNNLFNBQVM7UUFDYixPQUFPLEtBQUtDO0lBQ2I7SUFDQSxJQUFJQyxPQUFPVixZQUFZUSxTQUFTTjtJQUNoQyxPQUFPUSxRQUFRQSxLQUFLQyxLQUFLO0FBQzFCO0FBQ0EsMENBQTBDLEdBQzFDLElBQUlDLFVBQVUsU0FBVUosT0FBTyxFQUFFTixHQUFHLEVBQUVTLEtBQUs7SUFDMUMsSUFBSUQsT0FBT1YsWUFBWVEsU0FBU047SUFDaEMsSUFBSVEsTUFBTTtRQUNUQSxLQUFLQyxLQUFLLEdBQUdBO0lBQ2QsT0FBTztRQUNOLG9EQUFvRDtRQUNwREgsUUFBUUYsSUFBSSxHQUFHLHFFQUFxRSxHQUFJO1lBQ3ZGSixLQUFLQTtZQUNMSSxNQUFNRSxRQUFRRixJQUFJO1lBQ2xCSyxPQUFPQTtRQUNSO0lBQ0Q7QUFDRDtBQUNBLDBDQUEwQyxHQUMxQyxJQUFJRSxVQUFVLFNBQVVMLE9BQU8sRUFBRU4sR0FBRztJQUNuQyxJQUFJLENBQUNNLFNBQVM7UUFDYixPQUFPO0lBQ1I7SUFDQSxPQUFPLENBQUMsQ0FBQ1IsWUFBWVEsU0FBU047QUFDL0I7QUFDQSw2Q0FBNkMsR0FDN0MsNkNBQTZDO0FBQzdDLElBQUlZLGFBQWEsU0FBVU4sT0FBTyxFQUFFTixHQUFHO0lBQ3RDLElBQUlNLFNBQVM7UUFDWixPQUFPUixZQUFZUSxTQUFTTixLQUFLO0lBQ2xDO0FBQ0Q7QUFFQSx3QkFBd0IsR0FDeEJhLE9BQU9DLE9BQU8sR0FBRyxTQUFTQztJQUN6Qiw2REFBNkQsR0FDN0QsK0NBQStDLEdBQy9DLCtDQUErQyxHQUUvQyw2REFBNkQsR0FBRyxJQUFJQztJQUVwRSxvQkFBb0IsR0FDcEIsSUFBSUMsVUFBVTtRQUNiQyxRQUFRLFNBQVVsQixHQUFHO1lBQ3BCLElBQUksQ0FBQ2lCLFFBQVFFLEdBQUcsQ0FBQ25CLE1BQU07Z0JBQ3RCLE1BQU0sSUFBSUgsV0FBVyxtQ0FBbUNGLFFBQVFLO1lBQ2pFO1FBQ0Q7UUFDQSxVQUFVLFNBQVVBLEdBQUc7WUFDdEIsSUFBSW9CLE9BQU9KLE1BQU1BLEdBQUdaLElBQUk7WUFDeEIsSUFBSWlCLGNBQWNULFdBQVdJLElBQUloQjtZQUNqQyxJQUFJcUIsZUFBZUQsUUFBUUEsU0FBU0MsYUFBYTtnQkFDaERMLEtBQUssS0FBS1Q7WUFDWDtZQUNBLE9BQU8sQ0FBQyxDQUFDYztRQUNWO1FBQ0FDLEtBQUssU0FBVXRCLEdBQUc7WUFDakIsT0FBT0ssUUFBUVcsSUFBSWhCO1FBQ3BCO1FBQ0FtQixLQUFLLFNBQVVuQixHQUFHO1lBQ2pCLE9BQU9XLFFBQVFLLElBQUloQjtRQUNwQjtRQUNBdUIsS0FBSyxTQUFVdkIsR0FBRyxFQUFFUyxLQUFLO1lBQ3hCLElBQUksQ0FBQ08sSUFBSTtnQkFDUiwwTUFBME07Z0JBQzFNQSxLQUFLO29CQUNKWixNQUFNLEtBQUtHO2dCQUNaO1lBQ0Q7WUFDQSwyQ0FBMkM7WUFDM0NHLFFBQVEsbUNBQW1DLEdBQUlNLElBQUtoQixLQUFLUztRQUMxRDtJQUNEO0lBQ0EseURBQXlEO0lBQ3pELE9BQU9RO0FBQ1IifQ==