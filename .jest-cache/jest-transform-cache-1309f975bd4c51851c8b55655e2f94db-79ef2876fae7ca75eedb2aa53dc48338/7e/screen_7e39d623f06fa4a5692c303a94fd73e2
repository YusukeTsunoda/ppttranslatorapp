a66c993bf0e8bd0b5ab757b107df1326
"use strict";
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.screen = void 0;
var _lzString = _interopRequireDefault(require("lz-string"));
var _getQueriesForElement = require("./get-queries-for-element");
var _helpers = require("./helpers");
var _prettyDom = require("./pretty-dom");
var queries = _interopRequireWildcard(require("./queries"));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
// WARNING: `lz-string` only has a default export but statically we assume named exports are allowd
// TODO: Statically verify we don't rely on NodeJS implicit named imports.
function unindent(string) {
    // remove white spaces first, to save a few bytes.
    // testing-playground will reformat on load any ways.
    return string.replace(/[ \t]*[\n][ \t]*/g, '\n');
}
function encode(value) {
    return _lzString.default.compressToEncodedURIComponent(unindent(value));
}
function getPlaygroundUrl(markup) {
    return `https://testing-playground.com/#markup=${encode(markup)}`;
}
const debug = (element, maxLength, options)=>Array.isArray(element) ? element.forEach((el)=>(0, _prettyDom.logDOM)(el, maxLength, options)) : (0, _prettyDom.logDOM)(element, maxLength, options);
const logTestingPlaygroundURL = (element = (0, _helpers.getDocument)().body)=>{
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (!element || !('innerHTML' in element)) {
        console.log(`The element you're providing isn't a valid DOM element.`);
        return;
    }
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (!element.innerHTML) {
        console.log(`The provided element doesn't have any children.`);
        return;
    }
    const playgroundUrl = getPlaygroundUrl(element.innerHTML);
    console.log(`Open this URL in your browser\n\n${playgroundUrl}`);
    return playgroundUrl;
};
const initialValue = {
    debug,
    logTestingPlaygroundURL
};
const screen = exports.screen = typeof document !== 'undefined' && document.body // eslint-disable-line @typescript-eslint/no-unnecessary-condition
 ? (0, _getQueriesForElement.getQueriesForElement)(document.body, queries, initialValue) : Object.keys(queries).reduce((helpers, key)=>{
    // `key` is for all intents and purposes the type of keyof `helpers`, which itself is the type of `initialValue` plus incoming properties from `queries`
    // if `Object.keys(something)` returned Array<keyof typeof something> this explicit type assertion would not be necessary
    // see https://stackoverflow.com/questions/55012174/why-doesnt-object-keys-return-a-keyof-type-in-typescript
    helpers[key] = ()=>{
        throw new TypeError('For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error');
    };
    return helpers;
}, initialValue);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95dXN1a2V0c3Vub2RhL0RvY3VtZW50cy9jdXJzb3IvcHB0dHJhbnNsYXRvcmFwcC9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9yZWFjdC9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9kb20vZGlzdC9zY3JlZW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2NyZWVuID0gdm9pZCAwO1xudmFyIF9selN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImx6LXN0cmluZ1wiKSk7XG52YXIgX2dldFF1ZXJpZXNGb3JFbGVtZW50ID0gcmVxdWlyZShcIi4vZ2V0LXF1ZXJpZXMtZm9yLWVsZW1lbnRcIik7XG52YXIgX2hlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xudmFyIF9wcmV0dHlEb20gPSByZXF1aXJlKFwiLi9wcmV0dHktZG9tXCIpO1xudmFyIHF1ZXJpZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9xdWVyaWVzXCIpKTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBkZWZhdWx0OiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbi5kZWZhdWx0ID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuLy8gV0FSTklORzogYGx6LXN0cmluZ2Agb25seSBoYXMgYSBkZWZhdWx0IGV4cG9ydCBidXQgc3RhdGljYWxseSB3ZSBhc3N1bWUgbmFtZWQgZXhwb3J0cyBhcmUgYWxsb3dkXG4vLyBUT0RPOiBTdGF0aWNhbGx5IHZlcmlmeSB3ZSBkb24ndCByZWx5IG9uIE5vZGVKUyBpbXBsaWNpdCBuYW1lZCBpbXBvcnRzLlxuXG5mdW5jdGlvbiB1bmluZGVudChzdHJpbmcpIHtcbiAgLy8gcmVtb3ZlIHdoaXRlIHNwYWNlcyBmaXJzdCwgdG8gc2F2ZSBhIGZldyBieXRlcy5cbiAgLy8gdGVzdGluZy1wbGF5Z3JvdW5kIHdpbGwgcmVmb3JtYXQgb24gbG9hZCBhbnkgd2F5cy5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bIFxcdF0qW1xcbl1bIFxcdF0qL2csICdcXG4nKTtcbn1cbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICByZXR1cm4gX2x6U3RyaW5nLmRlZmF1bHQuY29tcHJlc3NUb0VuY29kZWRVUklDb21wb25lbnQodW5pbmRlbnQodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldFBsYXlncm91bmRVcmwobWFya3VwKSB7XG4gIHJldHVybiBgaHR0cHM6Ly90ZXN0aW5nLXBsYXlncm91bmQuY29tLyNtYXJrdXA9JHtlbmNvZGUobWFya3VwKX1gO1xufVxuY29uc3QgZGVidWcgPSAoZWxlbWVudCwgbWF4TGVuZ3RoLCBvcHRpb25zKSA9PiBBcnJheS5pc0FycmF5KGVsZW1lbnQpID8gZWxlbWVudC5mb3JFYWNoKGVsID0+ICgwLCBfcHJldHR5RG9tLmxvZ0RPTSkoZWwsIG1heExlbmd0aCwgb3B0aW9ucykpIDogKDAsIF9wcmV0dHlEb20ubG9nRE9NKShlbGVtZW50LCBtYXhMZW5ndGgsIG9wdGlvbnMpO1xuY29uc3QgbG9nVGVzdGluZ1BsYXlncm91bmRVUkwgPSAoZWxlbWVudCA9ICgwLCBfaGVscGVycy5nZXREb2N1bWVudCkoKS5ib2R5KSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gIGlmICghZWxlbWVudCB8fCAhKCdpbm5lckhUTUwnIGluIGVsZW1lbnQpKSB7XG4gICAgY29uc29sZS5sb2coYFRoZSBlbGVtZW50IHlvdSdyZSBwcm92aWRpbmcgaXNuJ3QgYSB2YWxpZCBET00gZWxlbWVudC5gKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgaWYgKCFlbGVtZW50LmlubmVySFRNTCkge1xuICAgIGNvbnNvbGUubG9nKGBUaGUgcHJvdmlkZWQgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW55IGNoaWxkcmVuLmApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwbGF5Z3JvdW5kVXJsID0gZ2V0UGxheWdyb3VuZFVybChlbGVtZW50LmlubmVySFRNTCk7XG4gIGNvbnNvbGUubG9nKGBPcGVuIHRoaXMgVVJMIGluIHlvdXIgYnJvd3NlclxcblxcbiR7cGxheWdyb3VuZFVybH1gKTtcbiAgcmV0dXJuIHBsYXlncm91bmRVcmw7XG59O1xuY29uc3QgaW5pdGlhbFZhbHVlID0ge1xuICBkZWJ1ZyxcbiAgbG9nVGVzdGluZ1BsYXlncm91bmRVUkxcbn07XG5jb25zdCBzY3JlZW4gPSBleHBvcnRzLnNjcmVlbiA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuYm9keSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbj8gKDAsIF9nZXRRdWVyaWVzRm9yRWxlbWVudC5nZXRRdWVyaWVzRm9yRWxlbWVudCkoZG9jdW1lbnQuYm9keSwgcXVlcmllcywgaW5pdGlhbFZhbHVlKSA6IE9iamVjdC5rZXlzKHF1ZXJpZXMpLnJlZHVjZSgoaGVscGVycywga2V5KSA9PiB7XG4gIC8vIGBrZXlgIGlzIGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXMgdGhlIHR5cGUgb2Yga2V5b2YgYGhlbHBlcnNgLCB3aGljaCBpdHNlbGYgaXMgdGhlIHR5cGUgb2YgYGluaXRpYWxWYWx1ZWAgcGx1cyBpbmNvbWluZyBwcm9wZXJ0aWVzIGZyb20gYHF1ZXJpZXNgXG4gIC8vIGlmIGBPYmplY3Qua2V5cyhzb21ldGhpbmcpYCByZXR1cm5lZCBBcnJheTxrZXlvZiB0eXBlb2Ygc29tZXRoaW5nPiB0aGlzIGV4cGxpY2l0IHR5cGUgYXNzZXJ0aW9uIHdvdWxkIG5vdCBiZSBuZWNlc3NhcnlcbiAgLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU1MDEyMTc0L3doeS1kb2VzbnQtb2JqZWN0LWtleXMtcmV0dXJuLWEta2V5b2YtdHlwZS1pbi10eXBlc2NyaXB0XG4gIGhlbHBlcnNba2V5XSA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGb3IgcXVlcmllcyBib3VuZCB0byBkb2N1bWVudC5ib2R5IGEgZ2xvYmFsIGRvY3VtZW50IGhhcyB0byBiZSBhdmFpbGFibGUuLi4gTGVhcm4gbW9yZTogaHR0cHM6Ly90ZXN0aW5nLWxpYnJhcnkuY29tL3Mvc2NyZWVuLWdsb2JhbC1lcnJvcicpO1xuICB9O1xuICByZXR1cm4gaGVscGVycztcbn0sIGluaXRpYWxWYWx1ZSk7Il0sIm5hbWVzIjpbIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzY3JlZW4iLCJfbHpTdHJpbmciLCJfZ2V0UXVlcmllc0ZvckVsZW1lbnQiLCJfaGVscGVycyIsIl9wcmV0dHlEb20iLCJxdWVyaWVzIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJlIiwiV2Vha01hcCIsInIiLCJ0IiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJoYXMiLCJnZXQiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpIiwic2V0IiwidW5pbmRlbnQiLCJzdHJpbmciLCJyZXBsYWNlIiwiZW5jb2RlIiwiY29tcHJlc3NUb0VuY29kZWRVUklDb21wb25lbnQiLCJnZXRQbGF5Z3JvdW5kVXJsIiwibWFya3VwIiwiZGVidWciLCJlbGVtZW50IiwibWF4TGVuZ3RoIiwib3B0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJlbCIsImxvZ0RPTSIsImxvZ1Rlc3RpbmdQbGF5Z3JvdW5kVVJMIiwiZ2V0RG9jdW1lbnQiLCJib2R5IiwiY29uc29sZSIsImxvZyIsImlubmVySFRNTCIsInBsYXlncm91bmRVcmwiLCJpbml0aWFsVmFsdWUiLCJkb2N1bWVudCIsImdldFF1ZXJpZXNGb3JFbGVtZW50Iiwia2V5cyIsInJlZHVjZSIsImhlbHBlcnMiLCJrZXkiLCJUeXBlRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEseUJBQXlCQyxRQUFRO0FBQ3JDQyxPQUFPQyxjQUFjLENBQUNDLFNBQVMsY0FBYztJQUMzQ0MsT0FBTztBQUNUO0FBQ0FELFFBQVFFLE1BQU0sR0FBRyxLQUFLO0FBQ3RCLElBQUlDLFlBQVlQLHVCQUF1QkMsUUFBUTtBQUMvQyxJQUFJTyx3QkFBd0JQLFFBQVE7QUFDcEMsSUFBSVEsV0FBV1IsUUFBUTtBQUN2QixJQUFJUyxhQUFhVCxRQUFRO0FBQ3pCLElBQUlVLFVBQVVDLHdCQUF3QlgsUUFBUTtBQUM5QyxTQUFTWSx5QkFBeUJDLENBQUM7SUFBSSxJQUFJLGNBQWMsT0FBT0MsU0FBUyxPQUFPO0lBQU0sSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxBQUFDRixDQUFBQSwyQkFBMkIsU0FBVUMsQ0FBQztRQUFJLE9BQU9BLElBQUlHLElBQUlEO0lBQUcsQ0FBQSxFQUFHRjtBQUFJO0FBQzNNLFNBQVNGLHdCQUF3QkUsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxDQUFDQSxLQUFLRixLQUFLQSxFQUFFSSxVQUFVLEVBQUUsT0FBT0o7SUFBRyxJQUFJLFNBQVNBLEtBQUssWUFBWSxPQUFPQSxLQUFLLGNBQWMsT0FBT0EsR0FBRyxPQUFPO1FBQUVLLFNBQVNMO0lBQUU7SUFBRyxJQUFJRyxJQUFJSix5QkFBeUJHO0lBQUksSUFBSUMsS0FBS0EsRUFBRUcsR0FBRyxDQUFDTixJQUFJLE9BQU9HLEVBQUVJLEdBQUcsQ0FBQ1A7SUFBSSxJQUFJUSxJQUFJO1FBQUVDLFdBQVc7SUFBSyxHQUFHQyxJQUFJdEIsT0FBT0MsY0FBYyxJQUFJRCxPQUFPdUIs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