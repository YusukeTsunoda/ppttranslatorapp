{"version":3,"sources":["/Users/yusuketsunoda/Documents/cursor/ppttranslatorapp/node_modules/is-regex/index.js"],"sourcesContent":["'use strict';\n\nvar callBound = require('call-bound');\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar hasOwn = require('hasown');\nvar gOPD = require('gopd');\n\n/** @type {import('.')} */\nvar fn;\n\nif (hasToStringTag) {\n\t/** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */\n\tvar $exec = callBound('RegExp.prototype.exec');\n\t/** @type {object} */\n\tvar isRegexMarker = {};\n\n\tvar throwRegexMarker = function () {\n\t\tthrow isRegexMarker;\n\t};\n\t/** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */\n\tvar badStringifier = {\n\t\ttoString: throwRegexMarker,\n\t\tvalueOf: throwRegexMarker\n\t};\n\n\tif (typeof Symbol.toPrimitive === 'symbol') {\n\t\tbadStringifier[Symbol.toPrimitive] = throwRegexMarker;\n\t}\n\n\t/** @type {import('.')} */\n\t// @ts-expect-error TS can't figure out that the $exec call always throws\n\t// eslint-disable-next-line consistent-return\n\tfn = function isRegex(value) {\n\t\tif (!value || typeof value !== 'object') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tvar descriptor = /** @type {NonNullable<typeof gOPD>} */ (gOPD)(/** @type {{ lastIndex?: unknown }} */ (value), 'lastIndex');\n\t\tvar hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');\n\t\tif (!hasLastIndexDataProperty) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t$exec(value, /** @type {string} */ (/** @type {unknown} */ (badStringifier)));\n\t\t} catch (e) {\n\t\t\treturn e === isRegexMarker;\n\t\t}\n\t};\n} else {\n\t/** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */\n\tvar $toString = callBound('Object.prototype.toString');\n\t/** @const @type {'[object RegExp]'} */\n\tvar regexClass = '[object RegExp]';\n\n\t/** @type {import('.')} */\n\tfn = function isRegex(value) {\n\t\t// In older browsers, typeof regex incorrectly returns 'function'\n\t\tif (!value || (typeof value !== 'object' && typeof value !== 'function')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $toString(value) === regexClass;\n\t};\n}\n\nmodule.exports = fn;\n"],"names":["callBound","require","hasToStringTag","hasOwn","gOPD","fn","$exec","isRegexMarker","throwRegexMarker","badStringifier","toString","valueOf","Symbol","toPrimitive","isRegex","value","descriptor","hasLastIndexDataProperty","e","$toString","regexClass","module","exports"],"mappings":"AAAA;AAEA,IAAIA,YAAYC,QAAQ;AACxB,IAAIC,iBAAiBD,QAAQ;AAC7B,IAAIE,SAASF,QAAQ;AACrB,IAAIG,OAAOH,QAAQ;AAEnB,wBAAwB,GACxB,IAAII;AAEJ,IAAIH,gBAAgB;IACnB,uKAAuK,GACvK,IAAII,QAAQN,UAAU;IACtB,mBAAmB,GACnB,IAAIO,gBAAgB,CAAC;IAErB,IAAIC,mBAAmB;QACtB,MAAMD;IACP;IACA,oFAAoF,GACpF,IAAIE,iBAAiB;QACpBC,UAAUF;QACVG,SAASH;IACV;IAEA,IAAI,OAAOI,OAAOC,WAAW,KAAK,UAAU;QAC3CJ,cAAc,CAACG,OAAOC,WAAW,CAAC,GAAGL;IACtC;IAEA,wBAAwB,GACxB,yEAAyE;IACzE,6CAA6C;IAC7CH,KAAK,SAASS,QAAQC,KAAK;QAC1B,IAAI,CAACA,SAAS,OAAOA,UAAU,UAAU;YACxC,OAAO;QACR;QAEA,2CAA2C;QAC3C,IAAIC,aAAqD,AAAxC,qCAAqC,GAAIZ,KAAM,oCAAoC,GAAIW,OAAQ;QAChH,IAAIE,2BAA2BD,cAAcb,OAAOa,YAAY;QAChE,IAAI,CAACC,0BAA0B;YAC9B,OAAO;QACR;QAEA,IAAI;YACH,2CAA2C;YAC3CX,MAAMS,OAA8B,oBAAoB,GAAIN;QAC7D,EAAE,OAAOS,GAAG;YACX,OAAOA,MAAMX;QACd;IACD;AACD,OAAO;IACN,mLAAmL,GACnL,IAAIY,YAAYnB,UAAU;IAC1B,qCAAqC,GACrC,IAAIoB,aAAa;IAEjB,wBAAwB,GACxBf,KAAK,SAASS,QAAQC,KAAK;QAC1B,iEAAiE;QACjE,IAAI,CAACA,SAAU,OAAOA,UAAU,YAAY,OAAOA,UAAU,YAAa;YACzE,OAAO;QACR;QAEA,OAAOI,UAAUJ,WAAWK;IAC7B;AACD;AAEAC,OAAOC,OAAO,GAAGjB"}