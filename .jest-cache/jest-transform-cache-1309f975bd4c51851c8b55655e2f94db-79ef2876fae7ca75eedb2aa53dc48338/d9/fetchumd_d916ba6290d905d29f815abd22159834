eb377447f29ac7c33c88a6b2e68135c5
"use strict";
(function(global1, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define([
        'exports'
    ], factory) : factory(global1.WHATWGFetch = {});
})(void 0, function(exports1) {
    'use strict';
    /* eslint-disable no-prototype-builtins */ var g = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || // eslint-disable-next-line no-undef
    typeof global !== 'undefined' && global || {};
    var support = {
        searchParams: 'URLSearchParams' in g,
        iterable: 'Symbol' in g && 'iterator' in Symbol,
        blob: 'FileReader' in g && 'Blob' in g && function() {
            try {
                new Blob();
                return true;
            } catch (e) {
                return false;
            }
        }(),
        formData: 'FormData' in g,
        arrayBuffer: 'ArrayBuffer' in g
    };
    function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
    }
    if (support.arrayBuffer) {
        var viewClasses = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]'
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
    }
    function normalizeName(name) {
        if (typeof name !== 'string') {
            name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
        }
        return name.toLowerCase();
    }
    function normalizeValue(value) {
        if (typeof value !== 'string') {
            value = String(value);
        }
        return value;
    }
    // Build a destructive iterator for the value list
    function iteratorFor(items) {
        var iterator = {
            next: function() {
                var value = items.shift();
                return {
                    done: value === undefined,
                    value: value
                };
            }
        };
        if (support.iterable) {
            iterator[Symbol.iterator] = function() {
                return iterator;
            };
        }
        return iterator;
    }
    function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
                this.append(name, value);
            }, this);
        } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
                if (header.length != 2) {
                    throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length);
                }
                this.append(header[0], header[1]);
            }, this);
        } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
                this.append(name, headers[name]);
            }, this);
        }
    }
    Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ', ' + value : value;
    };
    Headers.prototype['delete'] = function(name) {
        delete this.map[normalizeName(name)];
    };
    Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
    };
    Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
    };
    Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
    };
    Headers.prototype.forEach = function(callback, thisArg) {
        for(var name in this.map){
            if (this.map.hasOwnProperty(name)) {
                callback.call(thisArg, this.map[name], name, this);
            }
        }
    };
    Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
            items.push(name);
        });
        return iteratorFor(items);
    };
    Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
            items.push(value);
        });
        return iteratorFor(items);
    };
    Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
            items.push([
                name,
                value
            ]);
        });
        return iteratorFor(items);
    };
    if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }
    function consumed(body) {
        if (body._noBody) return;
        if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'));
        }
        body.bodyUsed = true;
    }
    function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
            reader.onload = function() {
                resolve(reader.result);
            };
            reader.onerror = function() {
                reject(reader.error);
            };
        });
    }
    function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
    }
    function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
        var encoding = match ? match[1] : 'utf-8';
        reader.readAsText(blob, encoding);
        return promise;
    }
    function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for(var i = 0; i < view.length; i++){
            chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join('');
    }
    function bufferClone(buf) {
        if (buf.slice) {
            return buf.slice(0);
        } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
        }
    }
    function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
            /*
        fetch-mock wraps the Response object in an ES6 Proxy to
        provide useful test harness features such as flush. However, on
        ES5 browsers without fetch or Proxy support pollyfills must be used;
        the proxy-pollyfill is unable to proxy an attribute unless it exists
        on the object before the Proxy is created. This change ensures
        Response.bodyUsed exists on the instance, while maintaining the
        semantic of setting Request.bodyUsed in the constructor before
        _initBody is called.
      */ // eslint-disable-next-line no-self-assign
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
                this._noBody = true;
                this._bodyText = '';
            } else if (typeof body === 'string') {
                this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                // IE 10-11 can't handle a DataView body.
                this._bodyInit = new Blob([
                    this._bodyArrayBuffer
                ]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
            } else {
                this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get('content-type')) {
                if (typeof body === 'string') {
                    this.headers.set('content-type', 'text/plain;charset=UTF-8');
                } else if (this._bodyBlob && this._bodyBlob.type) {
                    this.headers.set('content-type', this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                }
            }
        };
        if (support.blob) {
            this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                    return rejected;
                }
                if (this._bodyBlob) {
                    return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                    return Promise.resolve(new Blob([
                        this._bodyArrayBuffer
                    ]));
                } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as blob');
                } else {
                    return Promise.resolve(new Blob([
                        this._bodyText
                    ]));
                }
            };
        }
        this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                    return isConsumed;
                } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                    return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
                } else {
                    return Promise.resolve(this._bodyArrayBuffer);
                }
            } else if (support.blob) {
                return this.blob().then(readBlobAsArrayBuffer);
            } else {
                throw new Error('could not read as ArrayBuffer');
            }
        };
        this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
                return rejected;
            }
            if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as text');
            } else {
                return Promise.resolve(this._bodyText);
            }
        };
        if (support.formData) {
            this.formData = function() {
                return this.text().then(decode);
            };
        }
        this.json = function() {
            return this.text().then(JSON.parse);
        };
        return this;
    }
    // HTTP methods whose capitalization should be normalized
    var methods = [
        'CONNECT',
        'DELETE',
        'GET',
        'HEAD',
        'OPTIONS',
        'PATCH',
        'POST',
        'PUT',
        'TRACE'
    ];
    function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
    }
    function Request(input, options) {
        if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        }
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
            if (input.bodyUsed) {
                throw new TypeError('Already read');
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
                this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
            }
        } else {
            this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || 'same-origin';
        if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || 'GET');
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal || function() {
            if ('AbortController' in g) {
                var ctrl = new AbortController();
                return ctrl.signal;
            }
        }();
        this.referrer = null;
        if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests');
        }
        this._initBody(body);
        if (this.method === 'GET' || this.method === 'HEAD') {
            if (options.cache === 'no-store' || options.cache === 'no-cache') {
                // Search for a '_' parameter in the query string
                var reParamSearch = /([?&])_=[^&]*/;
                if (reParamSearch.test(this.url)) {
                    // If it already exists then set the value with the current time
                    this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
                } else {
                    // Otherwise add a new '_' parameter to the end with the current time
                    var reQueryString = /\?/;
                    this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
                }
            }
        }
    }
    Request.prototype.clone = function() {
        return new Request(this, {
            body: this._bodyInit
        });
    };
    function decode(body) {
        var form = new FormData();
        body.trim().split('&').forEach(function(bytes) {
            if (bytes) {
                var split = bytes.split('=');
                var name = split.shift().replace(/\+/g, ' ');
                var value = split.join('=').replace(/\+/g, ' ');
                form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
        });
        return form;
    }
    function parseHeaders(rawHeaders) {
        var headers = new Headers();
        // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
        // https://tools.ietf.org/html/rfc7230#section-3.2
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
        // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
        // https://github.com/github/fetch/issues/748
        // https://github.com/zloirock/core-js/issues/751
        preProcessedHeaders.split('\r').map(function(header) {
            return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
        }).forEach(function(line) {
            var parts = line.split(':');
            var key = parts.shift().trim();
            if (key) {
                var value = parts.join(':').trim();
                try {
                    headers.append(key, value);
                } catch (error) {
                    console.warn('Response ' + error.message);
                }
            }
        });
        return headers;
    }
    Body.call(Request.prototype);
    function Response(bodyInit, options) {
        if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        }
        if (!options) {
            options = {};
        }
        this.type = 'default';
        this.status = options.status === undefined ? 200 : options.status;
        if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
        }
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
        this.headers = new Headers(options.headers);
        this.url = options.url || '';
        this._initBody(bodyInit);
    }
    Body.call(Response.prototype);
    Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
        });
    };
    Response.error = function() {
        var response = new Response(null, {
            status: 200,
            statusText: ''
        });
        response.ok = false;
        response.status = 0;
        response.type = 'error';
        return response;
    };
    var redirectStatuses = [
        301,
        302,
        303,
        307,
        308
    ];
    Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError('Invalid status code');
        }
        return new Response(null, {
            status: status,
            headers: {
                location: url
            }
        });
    };
    exports1.DOMException = g.DOMException;
    try {
        new exports1.DOMException();
    } catch (err) {
        exports1.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
        };
        exports1.DOMException.prototype = Object.create(Error.prototype);
        exports1.DOMException.prototype.constructor = exports1.DOMException;
    }
    function fetch(input, init) {
        return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
                return reject(new exports1.DOMException('Aborted', 'AbortError'));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
                xhr.abort();
            }
            xhr.onload = function() {
                var options = {
                    statusText: xhr.statusText,
                    headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                };
                // This check if specifically for when a user fetches a file locally from the file system
                // Only if the status is out of a normal range
                if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
                    options.status = 200;
                } else {
                    options.status = xhr.status;
                }
                options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                setTimeout(function() {
                    resolve(new Response(body, options));
                }, 0);
            };
            xhr.onerror = function() {
                setTimeout(function() {
                    reject(new TypeError('Network request failed'));
                }, 0);
            };
            xhr.ontimeout = function() {
                setTimeout(function() {
                    reject(new TypeError('Network request timed out'));
                }, 0);
            };
            xhr.onabort = function() {
                setTimeout(function() {
                    reject(new exports1.DOMException('Aborted', 'AbortError'));
                }, 0);
            };
            function fixUrl(url) {
                try {
                    return url === '' && g.location.href ? g.location.href : url;
                } catch (e) {
                    return url;
                }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === 'include') {
                xhr.withCredentials = true;
            } else if (request.credentials === 'omit') {
                xhr.withCredentials = false;
            }
            if ('responseType' in xhr) {
                if (support.blob) {
                    xhr.responseType = 'blob';
                } else if (support.arrayBuffer) {
                    xhr.responseType = 'arraybuffer';
                }
            }
            if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
                var names = [];
                Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                    names.push(normalizeName(name));
                    xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                });
                request.headers.forEach(function(value, name) {
                    if (names.indexOf(name) === -1) {
                        xhr.setRequestHeader(name, value);
                    }
                });
            } else {
                request.headers.forEach(function(value, name) {
                    xhr.setRequestHeader(name, value);
                });
            }
            if (request.signal) {
                request.signal.addEventListener('abort', abortXhr);
                xhr.onreadystatechange = function() {
                    // DONE (success or failure)
                    if (xhr.readyState === 4) {
                        request.signal.removeEventListener('abort', abortXhr);
                    }
                };
            }
            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
        });
    }
    fetch.polyfill = true;
    if (!g.fetch) {
        g.fetch = fetch;
        g.Headers = Headers;
        g.Request = Request;
        g.Response = Response;
    }
    exports1.Headers = Headers;
    exports1.Request = Request;
    exports1.Response = Response;
    exports1.fetch = fetch;
    Object.defineProperty(exports1, '__esModule', {
        value: true
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95dXN1a2V0c3Vub2RhL0RvY3VtZW50cy9jdXJzb3IvcHB0dHJhbnNsYXRvcmFwcC9ub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2Rpc3QvZmV0Y2gudW1kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5XSEFUV0dGZXRjaCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuICB2YXIgZyA9XG4gICAgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzKSB8fFxuICAgICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsKSB8fFxuICAgIHt9O1xuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gZyxcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gZyAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOlxuICAgICAgJ0ZpbGVSZWFkZXInIGluIGcgJiZcbiAgICAgICdCbG9iJyBpbiBnICYmXG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gZyxcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBnXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXTtcblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5eX2B8fiFdL2kudGVzdChuYW1lKSB8fCBuYW1lID09PSAnJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWU6IFwiJyArIG5hbWUgKyAnXCInKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgaWYgKGhlYWRlci5sZW5ndGggIT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlcnMgY29uc3RydWN0b3I6IGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQnICsgaGVhZGVyLmxlbmd0aClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV07XG4gICAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlICsgJywgJyArIHZhbHVlIDogdmFsdWU7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICBpdGVtcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5Ll9ub0JvZHkpIHJldHVyblxuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICAgIH07XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHZhciBtYXRjaCA9IC9jaGFyc2V0PShbQS1aYS16MC05Xy1dKykvLmV4ZWMoYmxvYi50eXBlKTtcbiAgICB2YXIgZW5jb2RpbmcgPSBtYXRjaCA/IG1hdGNoWzFdIDogJ3V0Zi04JztcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZyk7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICAvKlxuICAgICAgICBmZXRjaC1tb2NrIHdyYXBzIHRoZSBSZXNwb25zZSBvYmplY3QgaW4gYW4gRVM2IFByb3h5IHRvXG4gICAgICAgIHByb3ZpZGUgdXNlZnVsIHRlc3QgaGFybmVzcyBmZWF0dXJlcyBzdWNoIGFzIGZsdXNoLiBIb3dldmVyLCBvblxuICAgICAgICBFUzUgYnJvd3NlcnMgd2l0aG91dCBmZXRjaCBvciBQcm94eSBzdXBwb3J0IHBvbGx5ZmlsbHMgbXVzdCBiZSB1c2VkO1xuICAgICAgICB0aGUgcHJveHktcG9sbHlmaWxsIGlzIHVuYWJsZSB0byBwcm94eSBhbiBhdHRyaWJ1dGUgdW5sZXNzIGl0IGV4aXN0c1xuICAgICAgICBvbiB0aGUgb2JqZWN0IGJlZm9yZSB0aGUgUHJveHkgaXMgY3JlYXRlZC4gVGhpcyBjaGFuZ2UgZW5zdXJlc1xuICAgICAgICBSZXNwb25zZS5ib2R5VXNlZCBleGlzdHMgb24gdGhlIGluc3RhbmNlLCB3aGlsZSBtYWludGFpbmluZyB0aGVcbiAgICAgICAgc2VtYW50aWMgb2Ygc2V0dGluZyBSZXF1ZXN0LmJvZHlVc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgICAgX2luaXRCb2R5IGlzIGNhbGxlZC5cbiAgICAgICovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgIHRoaXMuYm9keVVzZWQgPSB0aGlzLmJvZHlVc2VkO1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX25vQm9keSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpO1xuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdmFyIGlzQ29uc3VtZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgaWYgKGlzQ29uc3VtZWQpIHtcbiAgICAgICAgICByZXR1cm4gaXNDb25zdW1lZFxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCArIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIGFzIEFycmF5QnVmZmVyJylcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnQ09OTkVDVCcsICdERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQQVRDSCcsICdQT1NUJywgJ1BVVCcsICdUUkFDRSddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbCB8fCAoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCdBYm9ydENvbnRyb2xsZXInIGluIGcpIHtcbiAgICAgICAgdmFyIGN0cmwgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBjdHJsLnNpZ25hbDtcbiAgICAgIH1cbiAgICB9KCkpO1xuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsO1xuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KTtcblxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgaWYgKG9wdGlvbnMuY2FjaGUgPT09ICduby1zdG9yZScgfHwgb3B0aW9ucy5jYWNoZSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgICAvLyBTZWFyY2ggZm9yIGEgJ18nIHBhcmFtZXRlciBpbiB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICAgIHZhciByZVBhcmFtU2VhcmNoID0gLyhbPyZdKV89W14mXSovO1xuICAgICAgICBpZiAocmVQYXJhbVNlYXJjaC50ZXN0KHRoaXMudXJsKSkge1xuICAgICAgICAgIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzIHRoZW4gc2V0IHRoZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnJlcGxhY2UocmVQYXJhbVNlYXJjaCwgJyQxXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgYSBuZXcgJ18nIHBhcmFtZXRlciB0byB0aGUgZW5kIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICAgIHZhciByZVF1ZXJ5U3RyaW5nID0gL1xcPy87XG4gICAgICAgICAgdGhpcy51cmwgKz0gKHJlUXVlcnlTdHJpbmcudGVzdCh0aGlzLnVybCkgPyAnJicgOiAnPycpICsgJ189JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbiAgfTtcblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgYm9keVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KCcmJylcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gICAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJyk7XG4gICAgLy8gQXZvaWRpbmcgc3BsaXQgdmlhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgY29tbW9uIElFMTEgYnVnIHdpdGggdGhlIGNvcmUtanMgMy42LjAgcmVnZXggcG9seWZpbGxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoL2lzc3Vlcy83NDhcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNzUxXG4gICAgcHJlUHJvY2Vzc2VkSGVhZGVyc1xuICAgICAgLnNwbGl0KCdcXHInKVxuICAgICAgLm1hcChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlci5pbmRleE9mKCdcXG4nKSA9PT0gMCA/IGhlYWRlci5zdWJzdHIoMSwgaGVhZGVyLmxlbmd0aCkgOiBoZWFkZXJcbiAgICAgIH0pXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVzcG9uc2UgJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gICAgfVxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0JztcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1cztcbiAgICBpZiAodGhpcy5zdGF0dXMgPCAyMDAgfHwgdGhpcy5zdGF0dXMgPiA1OTkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzcG9uc2UnOiBUaGUgc3RhdHVzIHByb3ZpZGVkICgwKSBpcyBvdXRzaWRlIHRoZSByYW5nZSBbMjAwLCA1OTldLlwiKVxuICAgIH1cbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiAnJyArIG9wdGlvbnMuc3RhdHVzVGV4dDtcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJyc7XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpO1xuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfTtcblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAyMDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2Uub2sgPSBmYWxzZTtcbiAgICByZXNwb25zZS5zdGF0dXMgPSAwO1xuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InO1xuICAgIHJldHVybiByZXNwb25zZVxuICB9O1xuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTtcblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9O1xuXG4gIGV4cG9ydHMuRE9NRXhjZXB0aW9uID0gZy5ET01FeGNlcHRpb247XG4gIHRyeSB7XG4gICAgbmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbmFtZSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKTtcbiAgICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB9O1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBleHBvcnRzLkRPTUV4Y2VwdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdCk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH1cblxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICBmdW5jdGlvbiBhYm9ydFhocigpIHtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICB9XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBjaGVjayBpZiBzcGVjaWZpY2FsbHkgZm9yIHdoZW4gYSB1c2VyIGZldGNoZXMgYSBmaWxlIGxvY2FsbHkgZnJvbSB0aGUgZmlsZSBzeXN0ZW1cbiAgICAgICAgLy8gT25seSBpZiB0aGUgc3RhdHVzIGlzIG91dCBvZiBhIG5vcm1hbCByYW5nZVxuICAgICAgICBpZiAocmVxdWVzdC51cmwuaW5kZXhPZignZmlsZTovLycpID09PSAwICYmICh4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPiA1OTkpKSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSAyMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJyk7XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IHRpbWVkIG91dCcpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBmaXhVcmwodXJsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVybCA9PT0gJycgJiYgZy5sb2NhdGlvbi5ocmVmID8gZy5sb2NhdGlvbi5ocmVmIDogdXJsXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gdXJsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIGZpeFVybChyZXF1ZXN0LnVybCksIHRydWUpO1xuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHN1cHBvcnQuYXJyYXlCdWZmZXJcbiAgICAgICAgKSB7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQuaGVhZGVycyA9PT0gJ29iamVjdCcgJiYgIShpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzIHx8IChnLkhlYWRlcnMgJiYgaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgZy5IZWFkZXJzKSkpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgbmFtZXMucHVzaChub3JtYWxpemVOYW1lKG5hbWUpKTtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBub3JtYWxpemVWYWx1ZShpbml0LmhlYWRlcnNbbmFtZV0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgaWYgKG5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7XG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpO1xuICAgIH0pXG4gIH1cblxuICBmZXRjaC5wb2x5ZmlsbCA9IHRydWU7XG5cbiAgaWYgKCFnLmZldGNoKSB7XG4gICAgZy5mZXRjaCA9IGZldGNoO1xuICAgIGcuSGVhZGVycyA9IEhlYWRlcnM7XG4gICAgZy5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICBnLlJlc3BvbnNlID0gUmVzcG9uc2U7XG4gIH1cblxuICBleHBvcnRzLkhlYWRlcnMgPSBIZWFkZXJzO1xuICBleHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICBleHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG4gIGV4cG9ydHMuZmV0Y2ggPSBmZXRjaDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiV0hBVFdHRmV0Y2giLCJnIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJzdXBwb3J0Iiwic2VhcmNoUGFyYW1zIiwiaXRlcmFibGUiLCJTeW1ib2wiLCJibG9iIiwiQmxvYiIsImUiLCJmb3JtRGF0YSIsImFycmF5QnVmZmVyIiwiaXNEYXRhVmlldyIsIm9iaiIsIkRhdGFWaWV3IiwicHJvdG90eXBlIiwiaXNQcm90b3R5cGVPZiIsInZpZXdDbGFzc2VzIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImluZGV4T2YiLCJPYmplY3QiLCJ0b1N0cmluZyIsImNhbGwiLCJub3JtYWxpemVOYW1lIiwibmFtZSIsIlN0cmluZyIsInRlc3QiLCJUeXBlRXJyb3IiLCJ0b0xvd2VyQ2FzZSIsIm5vcm1hbGl6ZVZhbHVlIiwidmFsdWUiLCJpdGVyYXRvckZvciIsIml0ZW1zIiwiaXRlcmF0b3IiLCJuZXh0Iiwic2hpZnQiLCJkb25lIiwidW5kZWZpbmVkIiwiSGVhZGVycyIsImhlYWRlcnMiLCJtYXAiLCJmb3JFYWNoIiwiYXBwZW5kIiwiQXJyYXkiLCJpc0FycmF5IiwiaGVhZGVyIiwibGVuZ3RoIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9sZFZhbHVlIiwiZ2V0IiwiaGFzIiwiaGFzT3duUHJvcGVydHkiLCJzZXQiLCJjYWxsYmFjayIsInRoaXNBcmciLCJrZXlzIiwicHVzaCIsInZhbHVlcyIsImVudHJpZXMiLCJjb25zdW1lZCIsImJvZHkiLCJfbm9Cb2R5IiwiYm9keVVzZWQiLCJQcm9taXNlIiwicmVqZWN0IiwiZmlsZVJlYWRlclJlYWR5IiwicmVhZGVyIiwicmVzb2x2ZSIsIm9ubG9hZCIsInJlc3VsdCIsIm9uZXJyb3IiLCJlcnJvciIsInJlYWRCbG9iQXNBcnJheUJ1ZmZlciIsIkZpbGVSZWFkZXIiLCJwcm9taXNlIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJyZWFkQmxvYkFzVGV4dCIsIm1hdGNoIiwiZXhlYyIsInR5cGUiLCJlbmNvZGluZyIsInJlYWRBc1RleHQiLCJyZWFkQXJyYXlCdWZmZXJBc1RleHQiLCJidWYiLCJ2aWV3IiwiVWludDhBcnJheSIsImNoYXJzIiwiaSIsImZyb21DaGFyQ29kZSIsImpvaW4iLCJidWZmZXJDbG9uZSIsInNsaWNlIiwiYnl0ZUxlbmd0aCIsImJ1ZmZlciIsIkJvZHkiLCJfaW5pdEJvZHkiLCJfYm9keUluaXQiLCJfYm9keVRleHQiLCJfYm9keUJsb2IiLCJGb3JtRGF0YSIsIl9ib2R5Rm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJfYm9keUFycmF5QnVmZmVyIiwicmVqZWN0ZWQiLCJFcnJvciIsImlzQ29uc3VtZWQiLCJieXRlT2Zmc2V0IiwidGhlbiIsInRleHQiLCJkZWNvZGUiLCJqc29uIiwiSlNPTiIsInBhcnNlIiwibWV0aG9kcyIsIm5vcm1hbGl6ZU1ldGhvZCIsIm1ldGhvZCIsInVwY2FzZWQiLCJ0b1VwcGVyQ2FzZSIsIlJlcXVlc3QiLCJpbnB1dCIsIm9wdGlvbnMiLCJ1cmwiLCJjcmVkZW50aWFscyIsIm1vZGUiLCJzaWduYWwiLCJjdHJsIiwiQWJvcnRDb250cm9sbGVyIiwicmVmZXJyZXIiLCJjYWNoZSIsInJlUGFyYW1TZWFyY2giLCJyZXBsYWNlIiwiRGF0ZSIsImdldFRpbWUiLCJyZVF1ZXJ5U3RyaW5nIiwiY2xvbmUiLCJmb3JtIiwidHJpbSIsInNwbGl0IiwiYnl0ZXMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXJzZUhlYWRlcnMiLCJyYXdIZWFkZXJzIiwicHJlUHJvY2Vzc2VkSGVhZGVycyIsInN1YnN0ciIsImxpbmUiLCJwYXJ0cyIsImtleSIsImNvbnNvbGUiLCJ3YXJuIiwibWVzc2FnZSIsIlJlc3BvbnNlIiwiYm9keUluaXQiLCJzdGF0dXMiLCJSYW5nZUVycm9yIiwib2siLCJzdGF0dXNUZXh0IiwicmVzcG9uc2UiLCJyZWRpcmVjdFN0YXR1c2VzIiwicmVkaXJlY3QiLCJsb2NhdGlvbiIsIkRPTUV4Y2VwdGlvbiIsImVyciIsInN0YWNrIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJmZXRjaCIsImluaXQiLCJyZXF1ZXN0IiwiYWJvcnRlZCIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwiYWJvcnRYaHIiLCJhYm9ydCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlVVJMIiwicmVzcG9uc2VUZXh0Iiwic2V0VGltZW91dCIsIm9udGltZW91dCIsIm9uYWJvcnQiLCJmaXhVcmwiLCJocmVmIiwib3BlbiIsIndpdGhDcmVkZW50aWFscyIsInJlc3BvbnNlVHlwZSIsIm5hbWVzIiwic2V0UmVxdWVzdEhlYWRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNlbmQiLCJwb2x5ZmlsbCIsImRlZmluZVByb3BlcnR5Il0sIm1hcHBpbmdzIjoiO0FBQUMsQ0FBQSxTQUFVQSxPQUFNLEVBQUVDLE9BQU87SUFDeEIsT0FBT0MsWUFBWSxZQUFZLE9BQU9DLFdBQVcsY0FBY0YsUUFBUUMsV0FDdkUsT0FBT0UsV0FBVyxjQUFjQSxPQUFPQyxHQUFHLEdBQUdELE9BQU87UUFBQztLQUFVLEVBQUVILFdBQ2hFQSxRQUFTRCxRQUFPTSxXQUFXLEdBQUcsQ0FBQztBQUNsQyxDQUFBLEVBQUUsUUFBTyxTQUFVSixRQUFPO0lBQUk7SUFFNUIsd0NBQXdDLEdBQ3hDLElBQUlLLElBQ0YsQUFBQyxPQUFPQyxlQUFlLGVBQWVBLGNBQ3JDLE9BQU9DLFNBQVMsZUFBZUEsUUFDaEMsb0NBQW9DO0lBQ25DLE9BQU9ULFdBQVcsZUFBZUEsVUFDbEMsQ0FBQztJQUVILElBQUlVLFVBQVU7UUFDWkMsY0FBYyxxQkFBcUJKO1FBQ25DSyxVQUFVLFlBQVlMLEtBQUssY0FBY007UUFDekNDLE1BQ0UsZ0JBQWdCUCxLQUNoQixVQUFVQSxLQUNWLEFBQUM7WUFDQyxJQUFJO2dCQUNGLElBQUlRO2dCQUNKLE9BQU87WUFDVCxFQUFFLE9BQU9DLEdBQUc7Z0JBQ1YsT0FBTztZQUNUO1FBQ0Y7UUFDRkMsVUFBVSxjQUFjVjtR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