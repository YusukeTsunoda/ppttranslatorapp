7fce992093c9e1e3986a2a7da86e3249
'use strict';
const ansiStyles = require('ansi-styles');
const { stdout: stdoutColor, stderr: stderrColor } = require('supports-color');
const { stringReplaceAll, stringEncaseCRLFWithFirstIndex } = require('./util');
// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = [
    'ansi',
    'ansi',
    'ansi256',
    'ansi16m'
];
const styles = Object.create(null);
const applyOptions = (object, options = {})=>{
    if (options.level > 3 || options.level < 0) {
        throw new Error('The `level` option should be an integer from 0 to 3');
    }
    // Detect level if not set manually
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === undefined ? colorLevel : options.level;
};
class ChalkClass {
    constructor(options){
        return chalkFactory(options);
    }
}
const chalkFactory = (options)=>{
    const chalk = {};
    applyOptions(chalk, options);
    chalk.template = (...arguments_)=>chalkTag(chalk.template, ...arguments_);
    Object.setPrototypeOf(chalk, Chalk.prototype);
    Object.setPrototypeOf(chalk.template, chalk);
    chalk.template.constructor = ()=>{
        throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
    };
    chalk.template.Instance = ChalkClass;
    return chalk.template;
};
function Chalk(options) {
    return chalkFactory(options);
}
for (const [styleName, style] of Object.entries(ansiStyles)){
    styles[styleName] = {
        get () {
            const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
            Object.defineProperty(this, styleName, {
                value: builder
            });
            return builder;
        }
    };
}
styles.visible = {
    get () {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, 'visible', {
            value: builder
        });
        return builder;
    }
};
const usedModels = [
    'rgb',
    'hex',
    'keyword',
    'hsl',
    'hsv',
    'hwb',
    'ansi',
    'ansi256'
];
for (const model of usedModels){
    styles[model] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
                return createBuilder(this, styler, this._isEmpty);
            };
        }
    };
}
for (const model of usedModels){
    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
        get () {
            const { level } = this;
            return function(...arguments_) {
                const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
                return createBuilder(this, styler, this._isEmpty);
            };
        }
    };
}
const proto = Object.defineProperties(()=>{}, {
    ...styles,
    level: {
        enumerable: true,
        get () {
            return this._generator.level;
        },
        set (level) {
            this._generator.level = level;
        }
    }
});
const createStyler = (open, close, parent)=>{
    let openAll;
    let closeAll;
    if (parent === undefined) {
        openAll = open;
        closeAll = close;
    } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
    }
    return {
        open,
        close,
        openAll,
        closeAll,
        parent
    };
};
const createBuilder = (self, _styler, _isEmpty)=>{
    const builder = (...arguments_)=>{
        // Single argument is hot path, implicit coercion is faster than anything
        // eslint-disable-next-line no-implicit-coercion
        return applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
    };
    // `__proto__` is used because we must return a function, but there is
    // no way to create a function with a different prototype
    builder.__proto__ = proto; // eslint-disable-line no-proto
    builder._generator = self;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
};
const applyStyle = (self, string)=>{
    if (self.level <= 0 || !string) {
        return self._isEmpty ? '' : string;
    }
    let styler = self._styler;
    if (styler === undefined) {
        return string;
    }
    const { openAll, closeAll } = styler;
    if (string.indexOf('\u001B') !== -1) {
        while(styler !== undefined){
            // Replace any instances already present with a re-opening code
            // otherwise only the part of the string until said closing code
            // will be colored, and the rest will simply be 'plain'.
            string = stringReplaceAll(string, styler.close, styler.open);
            styler = styler.parent;
        }
    }
    // We can move both next actions out of loop, because remaining actions in loop won't have
    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
    const lfIndex = string.indexOf('\n');
    if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
};
let template;
const chalkTag = (chalk, ...strings)=>{
    const [firstString] = strings;
    if (!Array.isArray(firstString)) {
        // If chalk() was called by itself or with a string,
        // return the string itself as a string.
        return strings.join(' ');
    }
    const arguments_ = strings.slice(1);
    const parts = [
        firstString.raw[0]
    ];
    for(let i = 1; i < firstString.length; i++){
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
    }
    if (template === undefined) {
        template = require('./templates');
    }
    return template(chalk, parts.join(''));
};
Object.defineProperties(Chalk.prototype, styles);
const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({
    level: stderrColor ? stderrColor.level : 0
}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;
// For TypeScript
chalk.Level = {
    None: 0,
    Basic: 1,
    Ansi256: 2,
    TrueColor: 3,
    0: 'None',
    1: 'Basic',
    2: 'Ansi256',
    3: 'TrueColor'
};
module.exports = chalk;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95dXN1a2V0c3Vub2RhL0RvY3VtZW50cy9jdXJzb3IvcHB0dHJhbnNsYXRvcmFwcC9ub2RlX21vZHVsZXMvQHRlc3RpbmctbGlicmFyeS9qZXN0LWRvbS9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGFuc2lTdHlsZXMgPSByZXF1aXJlKCdhbnNpLXN0eWxlcycpO1xuY29uc3Qge3N0ZG91dDogc3Rkb3V0Q29sb3IsIHN0ZGVycjogc3RkZXJyQ29sb3J9ID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcbmNvbnN0IHtcblx0c3RyaW5nUmVwbGFjZUFsbCxcblx0c3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4XG59ID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIGBzdXBwb3J0c0NvbG9yLmxldmVsYCDihpIgYGFuc2lTdHlsZXMuY29sb3JbbmFtZV1gIG1hcHBpbmdcbmNvbnN0IGxldmVsTWFwcGluZyA9IFtcblx0J2Fuc2knLFxuXHQnYW5zaScsXG5cdCdhbnNpMjU2Jyxcblx0J2Fuc2kxNm0nXG5dO1xuXG5jb25zdCBzdHlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5jb25zdCBhcHBseU9wdGlvbnMgPSAob2JqZWN0LCBvcHRpb25zID0ge30pID0+IHtcblx0aWYgKG9wdGlvbnMubGV2ZWwgPiAzIHx8IG9wdGlvbnMubGV2ZWwgPCAwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgYGxldmVsYCBvcHRpb24gc2hvdWxkIGJlIGFuIGludGVnZXIgZnJvbSAwIHRvIDMnKTtcblx0fVxuXG5cdC8vIERldGVjdCBsZXZlbCBpZiBub3Qgc2V0IG1hbnVhbGx5XG5cdGNvbnN0IGNvbG9yTGV2ZWwgPSBzdGRvdXRDb2xvciA/IHN0ZG91dENvbG9yLmxldmVsIDogMDtcblx0b2JqZWN0LmxldmVsID0gb3B0aW9ucy5sZXZlbCA9PT0gdW5kZWZpbmVkID8gY29sb3JMZXZlbCA6IG9wdGlvbnMubGV2ZWw7XG59O1xuXG5jbGFzcyBDaGFsa0NsYXNzIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHJldHVybiBjaGFsa0ZhY3Rvcnkob3B0aW9ucyk7XG5cdH1cbn1cblxuY29uc3QgY2hhbGtGYWN0b3J5ID0gb3B0aW9ucyA9PiB7XG5cdGNvbnN0IGNoYWxrID0ge307XG5cdGFwcGx5T3B0aW9ucyhjaGFsaywgb3B0aW9ucyk7XG5cblx0Y2hhbGsudGVtcGxhdGUgPSAoLi4uYXJndW1lbnRzXykgPT4gY2hhbGtUYWcoY2hhbGsudGVtcGxhdGUsIC4uLmFyZ3VtZW50c18pO1xuXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFsaywgQ2hhbGsucHJvdG90eXBlKTtcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGNoYWxrLnRlbXBsYXRlLCBjaGFsayk7XG5cblx0Y2hhbGsudGVtcGxhdGUuY29uc3RydWN0b3IgPSAoKSA9PiB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdgY2hhbGsuY29uc3RydWN0b3IoKWAgaXMgZGVwcmVjYXRlZC4gVXNlIGBuZXcgY2hhbGsuSW5zdGFuY2UoKWAgaW5zdGVhZC4nKTtcblx0fTtcblxuXHRjaGFsay50ZW1wbGF0ZS5JbnN0YW5jZSA9IENoYWxrQ2xhc3M7XG5cblx0cmV0dXJuIGNoYWxrLnRlbXBsYXRlO1xufTtcblxuZnVuY3Rpb24gQ2hhbGsob3B0aW9ucykge1xuXHRyZXR1cm4gY2hhbGtGYWN0b3J5KG9wdGlvbnMpO1xufVxuXG5mb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlXSBvZiBPYmplY3QuZW50cmllcyhhbnNpU3R5bGVzKSkge1xuXHRzdHlsZXNbc3R5bGVOYW1lXSA9IHtcblx0XHRnZXQoKSB7XG5cdFx0XHRjb25zdCBidWlsZGVyID0gY3JlYXRlQnVpbGRlcih0aGlzLCBjcmVhdGVTdHlsZXIoc3R5bGUub3Blbiwgc3R5bGUuY2xvc2UsIHRoaXMuX3N0eWxlciksIHRoaXMuX2lzRW1wdHkpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHN0eWxlTmFtZSwge3ZhbHVlOiBidWlsZGVyfSk7XG5cdFx0XHRyZXR1cm4gYnVpbGRlcjtcblx0XHR9XG5cdH07XG59XG5cbnN0eWxlcy52aXNpYmxlID0ge1xuXHRnZXQoKSB7XG5cdFx0Y29uc3QgYnVpbGRlciA9IGNyZWF0ZUJ1aWxkZXIodGhpcywgdGhpcy5fc3R5bGVyLCB0cnVlKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Zpc2libGUnLCB7dmFsdWU6IGJ1aWxkZXJ9KTtcblx0XHRyZXR1cm4gYnVpbGRlcjtcblx0fVxufTtcblxuY29uc3QgdXNlZE1vZGVscyA9IFsncmdiJywgJ2hleCcsICdrZXl3b3JkJywgJ2hzbCcsICdoc3YnLCAnaHdiJywgJ2Fuc2knLCAnYW5zaTI1NiddO1xuXG5mb3IgKGNvbnN0IG1vZGVsIG9mIHVzZWRNb2RlbHMpIHtcblx0c3R5bGVzW21vZGVsXSA9IHtcblx0XHRnZXQoKSB7XG5cdFx0XHRjb25zdCB7bGV2ZWx9ID0gdGhpcztcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRcdFx0XHRjb25zdCBzdHlsZXIgPSBjcmVhdGVTdHlsZXIoYW5zaVN0eWxlcy5jb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0oLi4uYXJndW1lbnRzXyksIGFuc2lTdHlsZXMuY29sb3IuY2xvc2UsIHRoaXMuX3N0eWxlcik7XG5cdFx0XHRcdHJldHVybiBjcmVhdGVCdWlsZGVyKHRoaXMsIHN0eWxlciwgdGhpcy5faXNFbXB0eSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcbn1cblxuZm9yIChjb25zdCBtb2RlbCBvZiB1c2VkTW9kZWxzKSB7XG5cdGNvbnN0IGJnTW9kZWwgPSAnYmcnICsgbW9kZWxbMF0udG9VcHBlckNhc2UoKSArIG1vZGVsLnNsaWNlKDEpO1xuXHRzdHlsZXNbYmdNb2RlbF0gPSB7XG5cdFx0Z2V0KCkge1xuXHRcdFx0Y29uc3Qge2xldmVsfSA9IHRoaXM7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcblx0XHRcdFx0Y29uc3Qgc3R5bGVyID0gY3JlYXRlU3R5bGVyKGFuc2lTdHlsZXMuYmdDb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0oLi4uYXJndW1lbnRzXyksIGFuc2lTdHlsZXMuYmdDb2xvci5jbG9zZSwgdGhpcy5fc3R5bGVyKTtcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZUJ1aWxkZXIodGhpcywgc3R5bGVyLCB0aGlzLl9pc0VtcHR5KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xufVxuXG5jb25zdCBwcm90byA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCgpID0+IHt9LCB7XG5cdC4uLnN0eWxlcyxcblx0bGV2ZWw6IHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9nZW5lcmF0b3IubGV2ZWw7XG5cdFx0fSxcblx0XHRzZXQobGV2ZWwpIHtcblx0XHRcdHRoaXMuX2dlbmVyYXRvci5sZXZlbCA9IGxldmVsO1xuXHRcdH1cblx0fVxufSk7XG5cbmNvbnN0IGNyZWF0ZVN0eWxlciA9IChvcGVuLCBjbG9zZSwgcGFyZW50KSA9PiB7XG5cdGxldCBvcGVuQWxsO1xuXHRsZXQgY2xvc2VBbGw7XG5cdGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wZW5BbGwgPSBvcGVuO1xuXHRcdGNsb3NlQWxsID0gY2xvc2U7XG5cdH0gZWxzZSB7XG5cdFx0b3BlbkFsbCA9IHBhcmVudC5vcGVuQWxsICsgb3Blbjtcblx0XHRjbG9zZUFsbCA9IGNsb3NlICsgcGFyZW50LmNsb3NlQWxsO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRvcGVuLFxuXHRcdGNsb3NlLFxuXHRcdG9wZW5BbGwsXG5cdFx0Y2xvc2VBbGwsXG5cdFx0cGFyZW50XG5cdH07XG59O1xuXG5jb25zdCBjcmVhdGVCdWlsZGVyID0gKHNlbGYsIF9zdHlsZXIsIF9pc0VtcHR5KSA9PiB7XG5cdGNvbnN0IGJ1aWxkZXIgPSAoLi4uYXJndW1lbnRzXykgPT4ge1xuXHRcdC8vIFNpbmdsZSBhcmd1bWVudCBpcyBob3QgcGF0aCwgaW1wbGljaXQgY29lcmNpb24gaXMgZmFzdGVyIHRoYW4gYW55dGhpbmdcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRyZXR1cm4gYXBwbHlTdHlsZShidWlsZGVyLCAoYXJndW1lbnRzXy5sZW5ndGggPT09IDEpID8gKCcnICsgYXJndW1lbnRzX1swXSkgOiBhcmd1bWVudHNfLmpvaW4oJyAnKSk7XG5cdH07XG5cblx0Ly8gYF9fcHJvdG9fX2AgaXMgdXNlZCBiZWNhdXNlIHdlIG11c3QgcmV0dXJuIGEgZnVuY3Rpb24sIGJ1dCB0aGVyZSBpc1xuXHQvLyBubyB3YXkgdG8gY3JlYXRlIGEgZnVuY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBwcm90b3R5cGVcblx0YnVpbGRlci5fX3Byb3RvX18gPSBwcm90bzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG5cdGJ1aWxkZXIuX2dlbmVyYXRvciA9IHNlbGY7XG5cdGJ1aWxkZXIuX3N0eWxlciA9IF9zdHlsZXI7XG5cdGJ1aWxkZXIuX2lzRW1wdHkgPSBfaXNFbXB0eTtcblxuXHRyZXR1cm4gYnVpbGRlcjtcbn07XG5cbmNvbnN0IGFwcGx5U3R5bGUgPSAoc2VsZiwgc3RyaW5nKSA9PiB7XG5cdGlmIChzZWxmLmxldmVsIDw9IDAgfHwgIXN0cmluZykge1xuXHRcdHJldHVybiBzZWxmLl9pc0VtcHR5ID8gJycgOiBzdHJpbmc7XG5cdH1cblxuXHRsZXQgc3R5bGVyID0gc2VsZi5fc3R5bGVyO1xuXG5cdGlmIChzdHlsZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBzdHJpbmc7XG5cdH1cblxuXHRjb25zdCB7b3BlbkFsbCwgY2xvc2VBbGx9ID0gc3R5bGVyO1xuXHRpZiAoc3RyaW5nLmluZGV4T2YoJ1xcdTAwMUInKSAhPT0gLTEpIHtcblx0XHR3aGlsZSAoc3R5bGVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIFJlcGxhY2UgYW55IGluc3RhbmNlcyBhbHJlYWR5IHByZXNlbnQgd2l0aCBhIHJlLW9wZW5pbmcgY29kZVxuXHRcdFx0Ly8gb3RoZXJ3aXNlIG9ubHkgdGhlIHBhcnQgb2YgdGhlIHN0cmluZyB1bnRpbCBzYWlkIGNsb3NpbmcgY29kZVxuXHRcdFx0Ly8gd2lsbCBiZSBjb2xvcmVkLCBhbmQgdGhlIHJlc3Qgd2lsbCBzaW1wbHkgYmUgJ3BsYWluJy5cblx0XHRcdHN0cmluZyA9IHN0cmluZ1JlcGxhY2VBbGwoc3RyaW5nLCBzdHlsZXIuY2xvc2UsIHN0eWxlci5vcGVuKTtcblxuXHRcdFx0c3R5bGVyID0gc3R5bGVyLnBhcmVudDtcblx0XHR9XG5cdH1cblxuXHQvLyBXZSBjYW4gbW92ZSBib3RoIG5leHQgYWN0aW9ucyBvdXQgb2YgbG9vcCwgYmVjYXVzZSByZW1haW5pbmcgYWN0aW9ucyBpbiBsb29wIHdvbid0IGhhdmVcblx0Ly8gYW55L3Zpc2libGUgZWZmZWN0IG9uIHBhcnRzIHdlIGFkZCBoZXJlLiBDbG9zZSB0aGUgc3R5bGluZyBiZWZvcmUgYSBsaW5lYnJlYWsgYW5kIHJlb3BlblxuXHQvLyBhZnRlciBuZXh0IGxpbmUgdG8gZml4IGEgYmxlZWQgaXNzdWUgb24gbWFjT1M6IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFsay9jaGFsay9wdWxsLzkyXG5cdGNvbnN0IGxmSW5kZXggPSBzdHJpbmcuaW5kZXhPZignXFxuJyk7XG5cdGlmIChsZkluZGV4ICE9PSAtMSkge1xuXHRcdHN0cmluZyA9IHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleChzdHJpbmcsIGNsb3NlQWxsLCBvcGVuQWxsLCBsZkluZGV4KTtcblx0fVxuXG5cdHJldHVybiBvcGVuQWxsICsgc3RyaW5nICsgY2xvc2VBbGw7XG59O1xuXG5sZXQgdGVtcGxhdGU7XG5jb25zdCBjaGFsa1RhZyA9IChjaGFsaywgLi4uc3RyaW5ncykgPT4ge1xuXHRjb25zdCBbZmlyc3RTdHJpbmddID0gc3RyaW5ncztcblxuXHRpZiAoIUFycmF5LmlzQXJyYXkoZmlyc3RTdHJpbmcpKSB7XG5cdFx0Ly8gSWYgY2hhbGsoKSB3YXMgY2FsbGVkIGJ5IGl0c2VsZiBvciB3aXRoIGEgc3RyaW5nLFxuXHRcdC8vIHJldHVybiB0aGUgc3RyaW5nIGl0c2VsZiBhcyBhIHN0cmluZy5cblx0XHRyZXR1cm4gc3RyaW5ncy5qb2luKCcgJyk7XG5cdH1cblxuXHRjb25zdCBhcmd1bWVudHNfID0gc3RyaW5ncy5zbGljZSgxKTtcblx0Y29uc3QgcGFydHMgPSBbZmlyc3RTdHJpbmcucmF3WzBdXTtcblxuXHRmb3IgKGxldCBpID0gMTsgaSA8IGZpcnN0U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG5cdFx0cGFydHMucHVzaChcblx0XHRcdFN0cmluZyhhcmd1bWVudHNfW2kgLSAxXSkucmVwbGFjZSgvW3t9XFxcXF0vZywgJ1xcXFwkJicpLFxuXHRcdFx0U3RyaW5nKGZpcnN0U3RyaW5nLnJhd1tpXSlcblx0XHQpO1xuXHR9XG5cblx0aWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcblx0XHR0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzJyk7XG5cdH1cblxuXHRyZXR1cm4gdGVtcGxhdGUoY2hhbGssIHBhcnRzLmpvaW4oJycpKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYWxrLnByb3RvdHlwZSwgc3R5bGVzKTtcblxuY29uc3QgY2hhbGsgPSBDaGFsaygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbmNoYWxrLnN1cHBvcnRzQ29sb3IgPSBzdGRvdXRDb2xvcjtcbmNoYWxrLnN0ZGVyciA9IENoYWxrKHtsZXZlbDogc3RkZXJyQ29sb3IgPyBzdGRlcnJDb2xvci5sZXZlbCA6IDB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5jaGFsay5zdGRlcnIuc3VwcG9ydHNDb2xvciA9IHN0ZGVyckNvbG9yO1xuXG4vLyBGb3IgVHlwZVNjcmlwdFxuY2hhbGsuTGV2ZWwgPSB7XG5cdE5vbmU6IDAsXG5cdEJhc2ljOiAxLFxuXHRBbnNpMjU2OiAyLFxuXHRUcnVlQ29sb3I6IDMsXG5cdDA6ICdOb25lJyxcblx0MTogJ0Jhc2ljJyxcblx0MjogJ0Fuc2kyNTYnLFxuXHQzOiAnVHJ1ZUNvbG9yJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFsaztcbiJdLCJuYW1lcyI6WyJhbnNpU3R5bGVzIiwicmVxdWlyZSIsInN0ZG91dCIsInN0ZG91dENvbG9yIiwic3RkZXJyIiwic3RkZXJyQ29sb3IiLCJzdHJpbmdSZXBsYWNlQWxsIiwic3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4IiwibGV2ZWxNYXBwaW5nIiwic3R5bGVzIiwiT2JqZWN0IiwiY3JlYXRlIiwiYXBwbHlPcHRpb25zIiwib2JqZWN0Iiwib3B0aW9ucyIsImxldmVsIiwiRXJyb3IiLCJjb2xvckxldmVsIiwidW5kZWZpbmVkIiwiQ2hhbGtDbGFzcyIsImNvbnN0cnVjdG9yIiwiY2hhbGtGYWN0b3J5IiwiY2hhbGsiLCJ0ZW1wbGF0ZSIsImFyZ3VtZW50c18iLCJjaGFsa1RhZyIsInNldFByb3RvdHlwZU9mIiwiQ2hhbGsiLCJwcm90b3R5cGUiLCJJbnN0YW5jZSIsInN0eWxlTmFtZSIsInN0eWxlIiwiZW50cmllcyIsImdldCIsImJ1aWxkZXIiLCJjcmVhdGVCdWlsZGVyIiwiY3JlYXRlU3R5bGVyIiwib3BlbiIsImNsb3NlIiwiX3N0eWxlciIsIl9pc0VtcHR5IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsInZpc2libGUiLCJ1c2VkTW9kZWxzIiwibW9kZWwiLCJzdHlsZXIiLCJjb2xvciIsImJnTW9kZWwiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiYmdDb2xvciIsInByb3RvIiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJfZ2VuZXJhdG9yIiwic2V0IiwicGFyZW50Iiwib3BlbkFsbCIsImNsb3NlQWxsIiwic2VsZiIsImFwcGx5U3R5bGUiLCJsZW5ndGgiLCJqb2luIiwiX19wcm90b19fIiwic3RyaW5nIiwiaW5kZXhPZiIsImxmSW5kZXgiLCJzdHJpbmdzIiwiZmlyc3RTdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJwYXJ0cyIsInJhdyIsImkiLCJwdXNoIiwiU3RyaW5nIiwicmVwbGFjZSIsInN1cHBvcnRzQ29sb3IiLCJMZXZlbCIsIk5vbmUiLCJCYXNpYyIsIkFuc2kyNTYiLCJUcnVlQ29sb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU1BLGFBQWFDLFFBQVE7QUFDM0IsTUFBTSxFQUFDQyxRQUFRQyxXQUFXLEVBQUVDLFFBQVFDLFdBQVcsRUFBQyxHQUFHSixRQUFRO0FBQzNELE1BQU0sRUFDTEssZ0JBQWdCLEVBQ2hCQyw4QkFBOEIsRUFDOUIsR0FBR04sUUFBUTtBQUVaLDJEQUEyRDtBQUMzRCxNQUFNTyxlQUFlO0lBQ3BCO0lBQ0E7SUFDQTtJQUNBO0NBQ0E7QUFFRCxNQUFNQyxTQUFTQyxPQUFPQyxNQUFNLENBQUM7QUFFN0IsTUFBTUMsZUFBZSxDQUFDQyxRQUFRQyxVQUFVLENBQUMsQ0FBQztJQUN6QyxJQUFJQSxRQUFRQyxLQUFLLEdBQUcsS0FBS0QsUUFBUUMsS0FBSyxHQUFHLEdBQUc7UUFDM0MsTUFBTSxJQUFJQyxNQUFNO0lBQ2pCO0lBRUEsbUNBQW1DO0lBQ25DLE1BQU1DLGFBQWFkLGNBQWNBLFlBQVlZLEtBQUssR0FBRztJQUNyREYsT0FBT0UsS0FBSyxHQUFHRCxRQUFRQyxLQUFLLEtBQUtHLFlBQVlELGFBQWFILFFBQVFDLEtBQUs7QUFDeEU7QUFFQSxNQUFNSTtJQUNMQyxZQUFZTixPQUFPLENBQUU7UUFDcEIsT0FBT08sYUFBYVA7SUFDckI7QUFDRDtBQUVBLE1BQU1PLGVBQWVQLENBQUFBO0lBQ3BCLE1BQU1RLFFBQVEsQ0FBQztJQUNmVixhQUFhVSxPQUFPUjtJQUVwQlEsTUFBTUMsUUFBUSxHQUFHLENBQUMs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