{"version":3,"sources":["/Users/yusuketsunoda/Documents/cursor/ppttranslatorapp/worktrees/1-text-position-fix/lib/translation/history.ts"],"sourcesContent":["/**\n * 翻訳履歴管理モジュール\n * 翻訳履歴の記録とクレジット管理を担当\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { translationPrisma, userPrisma } from '@/lib/db/prisma';\nimport { Language, TranslationStatus } from '@prisma/client';\nimport { TranslationHistoryData } from './types';\n\n/**\n * 翻訳履歴を作成\n * @param userId ユーザーID\n * @param fileId ファイルID\n * @param fileName ファイル名\n * @param sourceLang ソース言語\n * @param targetLang ターゲット言語\n * @param model 使用モデル\n * @param textCount テキスト総数\n * @param translatedCount 翻訳完了数\n * @param processingTimeMs 処理時間(ms)\n * @param error エラー情報\n * @returns 作成された履歴データ\n */\nexport async function createTranslationHistory(\n  userId: string,\n  fileId: string,\n  fileName: string,\n  sourceLang: Language,\n  targetLang: Language,\n  model: string,\n  textCount: number,\n  translatedCount: number,\n  processingTimeMs: number,\n  error: string | null\n): Promise<TranslationHistoryData> {\n  // 履歴IDを生成\n  const historyId = uuidv4();\n  \n  // 履歴ステータスを決定\n  const historyStatus = error && translatedCount < textCount \n    ? TranslationStatus.FAILED \n    : TranslationStatus.COMPLETED;\n  \n  // 履歴データを作成\n  const historyData: TranslationHistoryData = {\n    id: historyId,\n    userId,\n    fileId,\n    fileName,\n    sourceLanguage: sourceLang,\n    targetLanguage: targetLang,\n    status: historyStatus,\n    model,\n    textCount,\n    translatedCount,\n    processingTimeMs,\n    error\n  };\n  \n  try {\n    // データベースに履歴を記録\n    await translationPrisma().translationHistory.create({\n      data: {\n        id: historyData.id,\n        userId: historyData.userId,\n        fileId: historyData.fileId,\n        creditsUsed: textCount, // 使用クレジット数はテキスト数と同じ\n        sourceLang: historyData.sourceLanguage,\n        targetLang: historyData.targetLanguage,\n        status: historyData.status,\n        model: historyData.model,\n        processingTime: historyData.processingTimeMs,\n        errorMessage: historyData.error,\n        pageCount: textCount, // ページ数としてテキスト数を記録\n        metadata: {\n          translatedCount: historyData.translatedCount,\n          fileName: historyData.fileName\n        }\n      },\n    });\n    \n    return historyData;\n  } catch (error) {\n    console.error('翻訳履歴作成エラー:', error);\n    throw error;\n  }\n}\n\n/**\n * ユーザーの翻訳履歴を取得\n * @param userId ユーザーID\n * @param limit 取得件数\n * @param offset オフセット\n * @returns 翻訳履歴リスト\n */\nexport async function getUserTranslationHistory(\n  userId: string,\n  limit: number = 20,\n  offset: number = 0\n) {\n  try {\n    const histories = await translationPrisma().translationHistory.findMany({\n      where: {\n        userId,\n      },\n      orderBy: {\n        createdAt: 'desc',\n      },\n      take: limit,\n      skip: offset,\n    });\n    \n    return histories;\n  } catch (error) {\n    console.error('翻訳履歴取得エラー:', error);\n    throw error;\n  }\n}\n\n/**\n * 翻訳に必要なクレジットを計算\n * @param textCount テキスト数\n * @returns 必要クレジット数\n */\nexport function calculateRequiredCredits(textCount: number): number {\n  // 基本的には1テキストあたり1クレジット\n  return textCount;\n}\n\n/**\n * ユーザーのクレジット残高を確認\n * @param userId ユーザーID\n * @returns クレジット残高\n */\nexport async function getUserCredits(userId: string): Promise<number> {\n  try {\n    const user = await userPrisma().user.findUnique({\n      where: { id: userId },\n      select: { credits: true }\n    });\n    \n    if (!user) {\n      throw new Error('ユーザーが見つかりません');\n    }\n    \n    return user.credits;\n  } catch (error) {\n    console.error('クレジット取得エラー:', error);\n    throw error;\n  }\n}\n\n/**\n * ユーザーのクレジットを消費\n * @param userId ユーザーID\n * @param credits 消費クレジット数\n * @returns 更新後のクレジット残高\n */\nexport async function consumeUserCredits(\n  userId: string,\n  credits: number\n): Promise<number> {\n  try {\n    const updatedUser = await userPrisma().user.update({\n      where: { id: userId },\n      data: { credits: { decrement: credits } },\n      select: { credits: true }\n    });\n    \n    return updatedUser.credits;\n  } catch (error) {\n    console.error('クレジット消費エラー:', error);\n    throw error;\n  }\n}\n\n/**\n * クレジット残高が十分かチェック\n * @param userId ユーザーID\n * @param requiredCredits 必要クレジット数\n * @returns クレジットが十分ならtrue、不足ならfalse\n */\nexport async function checkSufficientCredits(\n  userId: string,\n  requiredCredits: number\n): Promise<{ isEnough: boolean; available: number }> {\n  const availableCredits = await getUserCredits(userId);\n  \n  return {\n    isEnough: availableCredits >= requiredCredits,\n    available: availableCredits\n  };\n}\n"],"names":["calculateRequiredCredits","checkSufficientCredits","consumeUserCredits","createTranslationHistory","getUserCredits","getUserTranslationHistory","userId","fileId","fileName","sourceLang","targetLang","model","textCount","translatedCount","processingTimeMs","error","historyId","uuidv4","historyStatus","TranslationStatus","FAILED","COMPLETED","historyData","id","sourceLanguage","targetLanguage","status","translationPrisma","translationHistory","create","data","creditsUsed","processingTime","errorMessage","pageCount","metadata","console","limit","offset","histories","findMany","where","orderBy","createdAt","take","skip","user","userPrisma","findUnique","select","credits","Error","updatedUser","update","decrement","requiredCredits","availableCredits","isEnough","available"],"mappings":"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"}